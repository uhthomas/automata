// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go k8s.io/apimachinery/pkg/labels

package labels

// Selector represents a label selector.
#Selector: _

_#nothingSelector: {}

// Token represents constant definition for lexer token
#Token: int // #enumToken

#enumToken:
	#ErrorToken |
	#EndOfStringToken |
	#ClosedParToken |
	#CommaToken |
	#DoesNotExistToken |
	#DoubleEqualsToken |
	#EqualsToken |
	#GreaterThanToken |
	#IdentifierToken |
	#InToken |
	#LessThanToken |
	#NotEqualsToken |
	#NotInToken |
	#OpenParToken

#values_Token: {
	ErrorToken:        #ErrorToken
	EndOfStringToken:  #EndOfStringToken
	ClosedParToken:    #ClosedParToken
	CommaToken:        #CommaToken
	DoesNotExistToken: #DoesNotExistToken
	DoubleEqualsToken: #DoubleEqualsToken
	EqualsToken:       #EqualsToken
	GreaterThanToken:  #GreaterThanToken
	IdentifierToken:   #IdentifierToken
	InToken:           #InToken
	LessThanToken:     #LessThanToken
	NotEqualsToken:    #NotEqualsToken
	NotInToken:        #NotInToken
	OpenParToken:      #OpenParToken
}

// ErrorToken represents scan error
#ErrorToken: #Token & 0

// EndOfStringToken represents end of string
#EndOfStringToken: #Token & 1

// ClosedParToken represents close parenthesis
#ClosedParToken: #Token & 2

// CommaToken represents the comma
#CommaToken: #Token & 3

// DoesNotExistToken represents logic not
#DoesNotExistToken: #Token & 4

// DoubleEqualsToken represents double equals
#DoubleEqualsToken: #Token & 5

// EqualsToken represents equal
#EqualsToken: #Token & 6

// GreaterThanToken represents greater than
#GreaterThanToken: #Token & 7

// IdentifierToken represents identifier, e.g. keys and values
#IdentifierToken: #Token & 8

// InToken represents in
#InToken: #Token & 9

// LessThanToken represents less than
#LessThanToken: #Token & 10

// NotEqualsToken represents not equal
#NotEqualsToken: #Token & 11

// NotInToken represents not in
#NotInToken: #Token & 12

// OpenParToken represents open parenthesis
#OpenParToken: #Token & 13

// ParserContext represents context during parsing:
// some literal for example 'in' and 'notin' can be
// recognized as operator for example 'x in (a)' but
// it can be recognized as value for example 'value in (in)'
#ParserContext: int // #enumParserContext

#enumParserContext:
	#KeyAndOperator |
	#Values

#values_ParserContext: {
	KeyAndOperator: #KeyAndOperator
	Values:         #Values
}

// KeyAndOperator represents key and operator
#KeyAndOperator: #ParserContext & 0

// Values represents values
#Values: #ParserContext & 1

// ValidatedSetSelector wraps a Set, allowing it to implement the Selector interface. Unlike
// Set.AsSelectorPreValidated (which copies the input Set), this type simply wraps the underlying
// Set. As a result, it is substantially more efficient. A nil and empty Sets are considered
// equivalent to Everything().
//
// Callers MUST ensure the underlying Set is not mutated, and that it is already validated. If these
// constraints are not met, Set.AsValidatedSelector should be preferred
//
// None of the Selector methods mutate the underlying Set, but Add() and Requirements() convert to
// the less optimized version.
#ValidatedSetSelector: #Set
