// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go k8s.io/api/resource/v1alpha3

package v1alpha3

import metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

// DeviceSelector must have exactly one field set.
#DeviceSelector: {
	// CEL contains a CEL expression for selecting a device.
	//
	// +optional
	// +oneOf=SelectorType
	cel?: null | #CELDeviceSelector @go(CEL,*CELDeviceSelector) @protobuf(1,bytes,opt)
}

// CELDeviceSelector contains a CEL expression for selecting a device.
#CELDeviceSelector: {
	// Expression is a CEL expression which evaluates a single device. It
	// must evaluate to true when the device under consideration satisfies
	// the desired criteria, and false when it does not. Any other result
	// is an error and causes allocation of devices to abort.
	//
	// The expression's input is an object named "device", which carries
	// the following properties:
	//  - driver (string): the name of the driver which defines this device.
	//  - attributes (map[string]object): the device's attributes, grouped by prefix
	//    (e.g. device.attributes["dra.example.com"] evaluates to an object with all
	//    of the attributes which were prefixed by "dra.example.com".
	//  - capacity (map[string]object): the device's capacities, grouped by prefix.
	//
	// Example: Consider a device with driver="dra.example.com", which exposes
	// two attributes named "model" and "ext.example.com/family" and which
	// exposes one capacity named "modules". This input to this expression
	// would have the following fields:
	//
	//     device.driver
	//     device.attributes["dra.example.com"].model
	//     device.attributes["ext.example.com"].family
	//     device.capacity["dra.example.com"].modules
	//
	// The device.driver field can be used to check for a specific driver,
	// either as a high-level precondition (i.e. you only want to consider
	// devices from this driver) or as part of a multi-clause expression
	// that is meant to consider devices from different drivers.
	//
	// The value type of each attribute is defined by the device
	// definition, and users who write these expressions must consult the
	// documentation for their specific drivers. The value type of each
	// capacity is Quantity.
	//
	// If an unknown prefix is used as a lookup in either device.attributes
	// or device.capacity, an empty map will be returned. Any reference to
	// an unknown field will cause an evaluation error and allocation to
	// abort.
	//
	// A robust expression should check for the existence of attributes
	// before referencing them.
	//
	// For ease of use, the cel.bind() function is enabled, and can be used
	// to simplify expressions that access multiple attributes with the
	// same domain. For example:
	//
	//     cel.bind(dra, device.attributes["dra.example.com"], dra.someBool && dra.anotherBool)
	//
	// The length of the expression must be smaller or equal to 10 Ki. The
	// cost of evaluating it is also limited based on the estimated number
	// of logical steps.
	//
	// +required
	expression: string @go(Expression) @protobuf(1,bytes)
}

#CELSelectorExpressionMaxCost: 1000000

#CELSelectorExpressionMaxLength: 10240

// The device this taint is attached to has the "effect" on
// any claim which does not tolerate the taint and, through the claim,
// to pods using the claim.
//
// +protobuf.options.(gogoproto.goproto_stringer)=false
#DeviceTaint: {
	// The taint key to be applied to a device.
	// Must be a label name.
	//
	// +required
	key: string @go(Key) @protobuf(1,bytes)

	// The taint value corresponding to the taint key.
	// Must be a label value.
	//
	// +optional
	value?: string @go(Value) @protobuf(2,bytes,opt)

	// The effect of the taint on claims that do not tolerate the taint
	// and through such claims on the pods using them.
	// Valid effects are NoSchedule and NoExecute. PreferNoSchedule as used for
	// nodes is not valid here.
	//
	// +required
	effect: #DeviceTaintEffect @go(Effect) @protobuf(3,bytes,casttype=DeviceTaintEffect)

	// TimeAdded represents the time at which the taint was added.
	// Added automatically during create or update if not set.
	//
	// +optional
	timeAdded?: null | metav1.#Time @go(TimeAdded,*metav1.Time) @protobuf(4,bytes,opt)
}

// +enum
#DeviceTaintEffect: string // #enumDeviceTaintEffect

#enumDeviceTaintEffect:
	#DeviceTaintEffectNoSchedule |
	#DeviceTaintEffectNoExecute

// Do not allow new pods to schedule which use a tainted device unless they tolerate the taint,
// but allow all pods submitted to Kubelet without going through the scheduler
// to start, and allow all already-running pods to continue running.
#DeviceTaintEffectNoSchedule: #DeviceTaintEffect & "NoSchedule"

// Evict any already-running pods that do not tolerate the device taint.
#DeviceTaintEffectNoExecute: #DeviceTaintEffect & "NoExecute"

// DeviceTaintRule adds one taint to all devices which match the selector.
// This has the same effect as if the taint was specified directly
// in the ResourceSlice by the DRA driver.
#DeviceTaintRule: {
	metav1.#TypeMeta

	// Standard object metadata
	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Spec specifies the selector and one taint.
	//
	// Changing the spec automatically increments the metadata.generation number.
	spec: #DeviceTaintRuleSpec @go(Spec) @protobuf(2,bytes)
}

// DeviceTaintRuleSpec specifies the selector and one taint.
#DeviceTaintRuleSpec: {
	// DeviceSelector defines which device(s) the taint is applied to.
	// All selector criteria must be satified for a device to
	// match. The empty selector matches all devices. Without
	// a selector, no devices are matches.
	//
	// +optional
	deviceSelector?: null | #DeviceTaintSelector @go(DeviceSelector,*DeviceTaintSelector) @protobuf(1,bytes,opt)

	// The taint that gets applied to matching devices.
	//
	// +required
	taint?: #DeviceTaint @go(Taint) @protobuf(2,bytes,rep)
}

// DeviceTaintSelector defines which device(s) a DeviceTaintRule applies to.
// The empty selector matches all devices. Without a selector, no devices
// are matched.
#DeviceTaintSelector: {
	// If DeviceClassName is set, the selectors defined there must be
	// satisfied by a device to be selected. This field corresponds
	// to class.metadata.name.
	//
	// +optional
	deviceClassName?: null | string @go(DeviceClassName,*string) @protobuf(1,bytes,opt)

	// If driver is set, only devices from that driver are selected.
	// This fields corresponds to slice.spec.driver.
	//
	// +optional
	driver?: null | string @go(Driver,*string) @protobuf(2,bytes,opt)

	// If pool is set, only devices in that pool are selected.
	//
	// Also setting the driver name may be useful to avoid
	// ambiguity when different drivers use the same pool name,
	// but this is not required because selecting pools from
	// different drivers may also be useful, for example when
	// drivers with node-local devices use the node name as
	// their pool name.
	//
	// +optional
	pool?: null | string @go(Pool,*string) @protobuf(3,bytes,opt)

	// If device is set, only devices with that name are selected.
	// This field corresponds to slice.spec.devices[].name.
	//
	// Setting also driver and pool may be required to avoid ambiguity,
	// but is not required.
	//
	// +optional
	device?: null | string @go(Device,*string) @protobuf(4,bytes,opt)

	// Selectors contains the same selection criteria as a ResourceClaim.
	// Currently, CEL expressions are supported. All of these selectors
	// must be satisfied.
	//
	// +optional
	// +listType=atomic
	selectors?: [...#DeviceSelector] @go(Selectors,[]DeviceSelector) @protobuf(5,bytes,rep)
}

// DeviceTaintRuleList is a collection of DeviceTaintRules.
#DeviceTaintRuleList: {
	metav1.#TypeMeta

	// Standard list metadata
	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// Items is the list of DeviceTaintRules.
	items: [...#DeviceTaintRule] @go(Items,[]DeviceTaintRule) @protobuf(2,bytes,rep)
}
