// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go k8s.io/kube-aggregator/pkg/apis/apiregistration/v1

package v1

import metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

// APIServiceList is a list of APIService objects.
#APIServiceList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)
	items: [...#APIService] @go(Items,[]APIService) @protobuf(2,bytes,rep)
}

// ServiceReference holds a reference to Service.legacy.k8s.io
#ServiceReference: {
	// Namespace is the namespace of the service
	namespace?: string @go(Namespace) @protobuf(1,bytes,opt)

	// Name is the name of the service
	name?: string @go(Name) @protobuf(2,bytes,opt)

	// If specified, the port on the service that hosting webhook.
	// Default to 443 for backward compatibility.
	// `port` should be a valid port number (1-65535, inclusive).
	// +optional
	port?: null | int32 @go(Port,*int32) @protobuf(3,varint,opt)
}

// APIServiceSpec contains information for locating and communicating with a server.
// Only https is supported, though you are able to disable certificate verification.
#APIServiceSpec: {
	// Service is a reference to the service for this API server.  It must communicate
	// on port 443.
	// If the Service is nil, that means the handling for the API groupversion is handled locally on this server.
	// The call will simply delegate to the normal handler chain to be fulfilled.
	// +optional
	service?: null | #ServiceReference @go(Service,*ServiceReference) @protobuf(1,bytes,opt)

	// Group is the API group name this server hosts
	group?: string @go(Group) @protobuf(2,bytes,opt)

	// Version is the API version this server hosts.  For example, "v1"
	version?: string @go(Version) @protobuf(3,bytes,opt)

	// InsecureSkipTLSVerify disables TLS certificate verification when communicating with this server.
	// This is strongly discouraged.  You should use the CABundle instead.
	insecureSkipTLSVerify?: bool @go(InsecureSkipTLSVerify) @protobuf(4,varint,opt)

	// CABundle is a PEM encoded CA bundle which will be used to validate an API server's serving certificate.
	// If unspecified, system trust roots on the apiserver are used.
	// +listType=atomic
	// +optional
	caBundle?: bytes @go(CABundle,[]byte) @protobuf(5,bytes,opt)

	// GroupPriorityMininum is the priority this group should have at least. Higher priority means that the group is preferred by clients over lower priority ones.
	// Note that other versions of this group might specify even higher GroupPriorityMininum values such that the whole group gets a higher priority.
	// The primary sort is based on GroupPriorityMinimum, ordered highest number to lowest (20 before 10).
	// The secondary sort is based on the alphabetical comparison of the name of the object.  (v1.bar before v1.foo)
	// We'd recommend something like: *.k8s.io (except extensions) at 18000 and
	// PaaSes (OpenShift, Deis) are recommended to be in the 2000s
	groupPriorityMinimum: int32 @go(GroupPriorityMinimum) @protobuf(7,varint,opt)

	// VersionPriority controls the ordering of this API version inside of its group.  Must be greater than zero.
	// The primary sort is based on VersionPriority, ordered highest to lowest (20 before 10).
	// Since it's inside of a group, the number can be small, probably in the 10s.
	// In case of equal version priorities, the version string will be used to compute the order inside a group.
	// If the version string is "kube-like", it will sort above non "kube-like" version strings, which are ordered
	// lexicographically. "Kube-like" versions start with a "v", then are followed by a number (the major version),
	// then optionally the string "alpha" or "beta" and another number (the minor version). These are sorted first
	// by GA > beta > alpha (where GA is a version with no suffix such as beta or alpha), and then by comparing major
	// version, then minor version. An example sorted list of versions:
	// v10, v2, v1, v11beta2, v10beta3, v3beta1, v12alpha1, v11alpha2, foo1, foo10.
	versionPriority: int32 @go(VersionPriority) @protobuf(8,varint,opt)
}

// ConditionStatus indicates the status of a condition (true, false, or unknown).
#ConditionStatus: string // #enumConditionStatus

#enumConditionStatus:
	#ConditionTrue |
	#ConditionFalse |
	#ConditionUnknown

#ConditionTrue:    #ConditionStatus & "True"
#ConditionFalse:   #ConditionStatus & "False"
#ConditionUnknown: #ConditionStatus & "Unknown"

// APIServiceConditionType is a valid value for APIServiceCondition.Type
#APIServiceConditionType: string // #enumAPIServiceConditionType

#enumAPIServiceConditionType:
	#Available

// Available indicates that the service exists and is reachable
#Available: #APIServiceConditionType & "Available"

// APIServiceCondition describes the state of an APIService at a particular point
#APIServiceCondition: {
	// Type is the type of the condition.
	type: #APIServiceConditionType @go(Type) @protobuf(1,bytes,opt,casttype=APIServiceConditionType)

	// Status is the status of the condition.
	// Can be True, False, Unknown.
	status: #ConditionStatus @go(Status) @protobuf(2,bytes,opt,casttype=ConditionStatus)

	// Last time the condition transitioned from one status to another.
	// +optional
	lastTransitionTime?: metav1.#Time @go(LastTransitionTime) @protobuf(3,bytes,opt)

	// Unique, one-word, CamelCase reason for the condition's last transition.
	// +optional
	reason?: string @go(Reason) @protobuf(4,bytes,opt)

	// Human-readable message indicating details about last transition.
	// +optional
	message?: string @go(Message) @protobuf(5,bytes,opt)
}

// APIServiceStatus contains derived information about an API server
#APIServiceStatus: {
	// Current service state of apiService.
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=type
	conditions?: [...#APIServiceCondition] @go(Conditions,[]APIServiceCondition) @protobuf(1,bytes,rep)
}

// APIService represents a server for a particular GroupVersion.
// Name must be "version.group".
#APIService: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Spec contains information for locating and communicating with a server
	spec?: #APIServiceSpec @go(Spec) @protobuf(2,bytes,opt)

	// Status contains derived information about an API server
	status?: #APIServiceStatus @go(Status) @protobuf(3,bytes,opt)
}
