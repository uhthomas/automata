// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go go.etcd.io/etcd/api/v3/etcdserverpb

package etcdserverpb

import (
	"go.etcd.io/etcd/api/v3/mvccpb"
	"go.etcd.io/etcd/api/v3/authpb"
	"google.golang.org/grpc"
)

#AlarmType: int32 // #enumAlarmType

#enumAlarmType:
	#AlarmType_NONE |
	#AlarmType_NOSPACE |
	#AlarmType_CORRUPT

#values_AlarmType: {
	AlarmType_NONE:    #AlarmType_NONE
	AlarmType_NOSPACE: #AlarmType_NOSPACE
	AlarmType_CORRUPT: #AlarmType_CORRUPT
}

#AlarmType_NONE:    #AlarmType & 0
#AlarmType_NOSPACE: #AlarmType & 1
#AlarmType_CORRUPT: #AlarmType & 2

#RangeRequest_SortOrder: int32 // #enumRangeRequest_SortOrder

#enumRangeRequest_SortOrder:
	#RangeRequest_NONE |
	#RangeRequest_ASCEND |
	#RangeRequest_DESCEND

#values_RangeRequest_SortOrder: {
	RangeRequest_NONE:    #RangeRequest_NONE
	RangeRequest_ASCEND:  #RangeRequest_ASCEND
	RangeRequest_DESCEND: #RangeRequest_DESCEND
}

#RangeRequest_NONE:    #RangeRequest_SortOrder & 0
#RangeRequest_ASCEND:  #RangeRequest_SortOrder & 1
#RangeRequest_DESCEND: #RangeRequest_SortOrder & 2

#RangeRequest_SortTarget: int32 // #enumRangeRequest_SortTarget

#enumRangeRequest_SortTarget:
	#RangeRequest_KEY |
	#RangeRequest_VERSION |
	#RangeRequest_CREATE |
	#RangeRequest_MOD |
	#RangeRequest_VALUE

#values_RangeRequest_SortTarget: {
	RangeRequest_KEY:     #RangeRequest_KEY
	RangeRequest_VERSION: #RangeRequest_VERSION
	RangeRequest_CREATE:  #RangeRequest_CREATE
	RangeRequest_MOD:     #RangeRequest_MOD
	RangeRequest_VALUE:   #RangeRequest_VALUE
}

#RangeRequest_KEY:     #RangeRequest_SortTarget & 0
#RangeRequest_VERSION: #RangeRequest_SortTarget & 1
#RangeRequest_CREATE:  #RangeRequest_SortTarget & 2
#RangeRequest_MOD:     #RangeRequest_SortTarget & 3
#RangeRequest_VALUE:   #RangeRequest_SortTarget & 4

#Compare_CompareResult: int32 // #enumCompare_CompareResult

#enumCompare_CompareResult:
	#Compare_EQUAL |
	#Compare_GREATER |
	#Compare_LESS |
	#Compare_NOT_EQUAL

#values_Compare_CompareResult: {
	Compare_EQUAL:     #Compare_EQUAL
	Compare_GREATER:   #Compare_GREATER
	Compare_LESS:      #Compare_LESS
	Compare_NOT_EQUAL: #Compare_NOT_EQUAL
}

#Compare_EQUAL:     #Compare_CompareResult & 0
#Compare_GREATER:   #Compare_CompareResult & 1
#Compare_LESS:      #Compare_CompareResult & 2
#Compare_NOT_EQUAL: #Compare_CompareResult & 3

#Compare_CompareTarget: int32 // #enumCompare_CompareTarget

#enumCompare_CompareTarget:
	#Compare_VERSION |
	#Compare_CREATE |
	#Compare_MOD |
	#Compare_VALUE |
	#Compare_LEASE

#values_Compare_CompareTarget: {
	Compare_VERSION: #Compare_VERSION
	Compare_CREATE:  #Compare_CREATE
	Compare_MOD:     #Compare_MOD
	Compare_VALUE:   #Compare_VALUE
	Compare_LEASE:   #Compare_LEASE
}

#Compare_VERSION: #Compare_CompareTarget & 0
#Compare_CREATE:  #Compare_CompareTarget & 1
#Compare_MOD:     #Compare_CompareTarget & 2
#Compare_VALUE:   #Compare_CompareTarget & 3
#Compare_LEASE:   #Compare_CompareTarget & 4

#WatchCreateRequest_FilterType: int32 // #enumWatchCreateRequest_FilterType

#enumWatchCreateRequest_FilterType:
	#WatchCreateRequest_NOPUT |
	#WatchCreateRequest_NODELETE

#values_WatchCreateRequest_FilterType: {
	WatchCreateRequest_NOPUT:    #WatchCreateRequest_NOPUT
	WatchCreateRequest_NODELETE: #WatchCreateRequest_NODELETE
}

// filter out put event.
#WatchCreateRequest_NOPUT: #WatchCreateRequest_FilterType & 0

// filter out delete event.
#WatchCreateRequest_NODELETE: #WatchCreateRequest_FilterType & 1

#AlarmRequest_AlarmAction: int32 // #enumAlarmRequest_AlarmAction

#enumAlarmRequest_AlarmAction:
	#AlarmRequest_GET |
	#AlarmRequest_ACTIVATE |
	#AlarmRequest_DEACTIVATE

#values_AlarmRequest_AlarmAction: {
	AlarmRequest_GET:        #AlarmRequest_GET
	AlarmRequest_ACTIVATE:   #AlarmRequest_ACTIVATE
	AlarmRequest_DEACTIVATE: #AlarmRequest_DEACTIVATE
}

#AlarmRequest_GET:        #AlarmRequest_AlarmAction & 0
#AlarmRequest_ACTIVATE:   #AlarmRequest_AlarmAction & 1
#AlarmRequest_DEACTIVATE: #AlarmRequest_AlarmAction & 2

#DowngradeRequest_DowngradeAction: int32 // #enumDowngradeRequest_DowngradeAction

#enumDowngradeRequest_DowngradeAction:
	#DowngradeRequest_VALIDATE |
	#DowngradeRequest_ENABLE |
	#DowngradeRequest_CANCEL

#values_DowngradeRequest_DowngradeAction: {
	DowngradeRequest_VALIDATE: #DowngradeRequest_VALIDATE
	DowngradeRequest_ENABLE:   #DowngradeRequest_ENABLE
	DowngradeRequest_CANCEL:   #DowngradeRequest_CANCEL
}

#DowngradeRequest_VALIDATE: #DowngradeRequest_DowngradeAction & 0
#DowngradeRequest_ENABLE:   #DowngradeRequest_DowngradeAction & 1
#DowngradeRequest_CANCEL:   #DowngradeRequest_DowngradeAction & 2

#ResponseHeader: {
	// cluster_id is the ID of the cluster which sent the response.
	cluster_id?: uint64 @go(ClusterId) @protobuf(1,varint,opt,json=clusterId,proto3)

	// member_id is the ID of the member which sent the response.
	member_id?: uint64 @go(MemberId) @protobuf(2,varint,opt,json=memberId,proto3)

	// revision is the key-value store revision when the request was applied, and it's
	// unset (so 0) in case of calls not interacting with key-value store.
	// For watch progress responses, the header.revision indicates progress. All future events
	// received in this stream are guaranteed to have a higher revision number than the
	// header.revision number.
	revision?: int64 @go(Revision) @protobuf(3,varint,opt,proto3)

	// raft_term is the raft term when the request was applied.
	raft_term?: uint64 @go(RaftTerm) @protobuf(4,varint,opt,json=raftTerm,proto3)
}

#RangeRequest: {
	// key is the first key for the range. If range_end is not given, the request only looks up key.
	key?: bytes @go(Key,[]byte) @protobuf(1,bytes,opt,proto3)

	// range_end is the upper bound on the requested range [key, range_end).
	// If range_end is '\0', the range is all keys >= key.
	// If range_end is key plus one (e.g., "aa"+1 == "ab", "a\xff"+1 == "b"),
	// then the range request gets all keys prefixed with key.
	// If both key and range_end are '\0', then the range request returns all keys.
	range_end?: bytes @go(RangeEnd,[]byte) @protobuf(2,bytes,opt,json=rangeEnd,proto3)

	// limit is a limit on the number of keys returned for the request. When limit is set to 0,
	// it is treated as no limit.
	limit?: int64 @go(Limit) @protobuf(3,varint,opt,proto3)

	// revision is the point-in-time of the key-value store to use for the range.
	// If revision is less or equal to zero, the range is over the newest key-value store.
	// If the revision has been compacted, ErrCompacted is returned as a response.
	revision?: int64 @go(Revision) @protobuf(4,varint,opt,proto3)

	// sort_order is the order for returned sorted results.
	sort_order?: #RangeRequest_SortOrder @go(SortOrder) @protobuf(5,varint,opt,json=sortOrder,proto3,enum=etcdserverpb.RangeRequest_SortOrder)

	// sort_target is the key-value field to use for sorting.
	sort_target?: #RangeRequest_SortTarget @go(SortTarget) @protobuf(6,varint,opt,json=sortTarget,proto3,enum=etcdserverpb.RangeRequest_SortTarget)

	// serializable sets the range request to use serializable member-local reads.
	// Range requests are linearizable by default; linearizable requests have higher
	// latency and lower throughput than serializable requests but reflect the current
	// consensus of the cluster. For better performance, in exchange for possible stale reads,
	// a serializable range request is served locally without needing to reach consensus
	// with other nodes in the cluster.
	serializable?: bool @go(Serializable) @protobuf(7,varint,opt,proto3)

	// keys_only when set returns only the keys and not the values.
	keys_only?: bool @go(KeysOnly) @protobuf(8,varint,opt,json=keysOnly,proto3)

	// count_only when set returns only the count of the keys in the range.
	count_only?: bool @go(CountOnly) @protobuf(9,varint,opt,json=countOnly,proto3)

	// min_mod_revision is the lower bound for returned key mod revisions; all keys with
	// lesser mod revisions will be filtered away.
	min_mod_revision?: int64 @go(MinModRevision) @protobuf(10,varint,opt,json=minModRevision,proto3)

	// max_mod_revision is the upper bound for returned key mod revisions; all keys with
	// greater mod revisions will be filtered away.
	max_mod_revision?: int64 @go(MaxModRevision) @protobuf(11,varint,opt,json=maxModRevision,proto3)

	// min_create_revision is the lower bound for returned key create revisions; all keys with
	// lesser create revisions will be filtered away.
	min_create_revision?: int64 @go(MinCreateRevision) @protobuf(12,varint,opt,json=minCreateRevision,proto3)

	// max_create_revision is the upper bound for returned key create revisions; all keys with
	// greater create revisions will be filtered away.
	max_create_revision?: int64 @go(MaxCreateRevision) @protobuf(13,varint,opt,json=maxCreateRevision,proto3)
}

#RangeResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// kvs is the list of key-value pairs matched by the range request.
	// kvs is empty when count is requested.
	kvs?: [...null | mvccpb.#KeyValue] @go(Kvs,[]*mvccpb.KeyValue) @protobuf(2,bytes,rep,proto3)

	// more indicates if there are more keys to return in the requested range.
	more?: bool @go(More) @protobuf(3,varint,opt,proto3)

	// count is set to the actual number of keys within the range when requested.
	// Unlike Kvs, it is unaffected by limits and filters (e.g., Min/Max, Create/Modify, Revisions)
	// and reflects the full count within the specified range.
	count?: int64 @go(Count) @protobuf(4,varint,opt,proto3)
}

#PutRequest: {
	// key is the key, in bytes, to put into the key-value store.
	key?: bytes @go(Key,[]byte) @protobuf(1,bytes,opt,proto3)

	// value is the value, in bytes, to associate with the key in the key-value store.
	value?: bytes @go(Value,[]byte) @protobuf(2,bytes,opt,proto3)

	// lease is the lease ID to associate with the key in the key-value store. A lease
	// value of 0 indicates no lease.
	lease?: int64 @go(Lease) @protobuf(3,varint,opt,proto3)

	// If prev_kv is set, etcd gets the previous key-value pair before changing it.
	// The previous key-value pair will be returned in the put response.
	prev_kv?: bool @go(PrevKv) @protobuf(4,varint,opt,json=prevKv,proto3)

	// If ignore_value is set, etcd updates the key using its current value.
	// Returns an error if the key does not exist.
	ignore_value?: bool @go(IgnoreValue) @protobuf(5,varint,opt,json=ignoreValue,proto3)

	// If ignore_lease is set, etcd updates the key using its current lease.
	// Returns an error if the key does not exist.
	ignore_lease?: bool @go(IgnoreLease) @protobuf(6,varint,opt,json=ignoreLease,proto3)
}

#PutResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// if prev_kv is set in the request, the previous key-value pair will be returned.
	prev_kv?: null | mvccpb.#KeyValue @go(PrevKv,*mvccpb.KeyValue) @protobuf(2,bytes,opt,json=prevKv,proto3)
}

#DeleteRangeRequest: {
	// key is the first key to delete in the range.
	key?: bytes @go(Key,[]byte) @protobuf(1,bytes,opt,proto3)

	// range_end is the key following the last key to delete for the range [key, range_end).
	// If range_end is not given, the range is defined to contain only the key argument.
	// If range_end is one bit larger than the given key, then the range is all the keys
	// with the prefix (the given key).
	// If range_end is '\0', the range is all keys greater than or equal to the key argument.
	range_end?: bytes @go(RangeEnd,[]byte) @protobuf(2,bytes,opt,json=rangeEnd,proto3)

	// If prev_kv is set, etcd gets the previous key-value pairs before deleting it.
	// The previous key-value pairs will be returned in the delete response.
	prev_kv?: bool @go(PrevKv) @protobuf(3,varint,opt,json=prevKv,proto3)
}

#DeleteRangeResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// deleted is the number of keys deleted by the delete range request.
	deleted?: int64 @go(Deleted) @protobuf(2,varint,opt,proto3)

	// if prev_kv is set in the request, the previous key-value pairs will be returned.
	prev_kvs?: [...null | mvccpb.#KeyValue] @go(PrevKvs,[]*mvccpb.KeyValue) @protobuf(3,bytes,rep,json=prevKvs,proto3)
}

#RequestOp: {
	// request is a union of request types accepted by a transaction.
	//
	// Types that are valid to be assigned to Request:
	//	*RequestOp_RequestRange
	//	*RequestOp_RequestPut
	//	*RequestOp_RequestDeleteRange
	//	*RequestOp_RequestTxn
	Request: _#isRequestOp_Request
}

_#isRequestOp_Request: _

#RequestOp_RequestRange: {
	request_range?: null | #RangeRequest @go(RequestRange,*RangeRequest) @protobuf(1,bytes,opt,json=requestRange,proto3,oneof)
}

#RequestOp_RequestPut: {
	request_put?: null | #PutRequest @go(RequestPut,*PutRequest) @protobuf(2,bytes,opt,json=requestPut,proto3,oneof)
}

#RequestOp_RequestDeleteRange: {
	request_delete_range?: null | #DeleteRangeRequest @go(RequestDeleteRange,*DeleteRangeRequest) @protobuf(3,bytes,opt,json=requestDeleteRange,proto3,oneof)
}

#RequestOp_RequestTxn: {
	request_txn?: null | #TxnRequest @go(RequestTxn,*TxnRequest) @protobuf(4,bytes,opt,json=requestTxn,proto3,oneof)
}

#ResponseOp: {
	// response is a union of response types returned by a transaction.
	//
	// Types that are valid to be assigned to Response:
	//	*ResponseOp_ResponseRange
	//	*ResponseOp_ResponsePut
	//	*ResponseOp_ResponseDeleteRange
	//	*ResponseOp_ResponseTxn
	Response: _#isResponseOp_Response
}

_#isResponseOp_Response: _

#ResponseOp_ResponseRange: {
	response_range?: null | #RangeResponse @go(ResponseRange,*RangeResponse) @protobuf(1,bytes,opt,json=responseRange,proto3,oneof)
}

#ResponseOp_ResponsePut: {
	response_put?: null | #PutResponse @go(ResponsePut,*PutResponse) @protobuf(2,bytes,opt,json=responsePut,proto3,oneof)
}

#ResponseOp_ResponseDeleteRange: {
	response_delete_range?: null | #DeleteRangeResponse @go(ResponseDeleteRange,*DeleteRangeResponse) @protobuf(3,bytes,opt,json=responseDeleteRange,proto3,oneof)
}

#ResponseOp_ResponseTxn: {
	response_txn?: null | #TxnResponse @go(ResponseTxn,*TxnResponse) @protobuf(4,bytes,opt,json=responseTxn,proto3,oneof)
}

#Compare: {
	// result is logical comparison operation for this comparison.
	result?: #Compare_CompareResult @go(Result) @protobuf(1,varint,opt,proto3,enum=etcdserverpb.Compare_CompareResult)

	// target is the key-value field to inspect for the comparison.
	target?: #Compare_CompareTarget @go(Target) @protobuf(2,varint,opt,proto3,enum=etcdserverpb.Compare_CompareTarget)

	// key is the subject key for the comparison operation.
	key?: bytes @go(Key,[]byte) @protobuf(3,bytes,opt,proto3)

	// Types that are valid to be assigned to TargetUnion:
	//	*Compare_Version
	//	*Compare_CreateRevision
	//	*Compare_ModRevision
	//	*Compare_Value
	//	*Compare_Lease
	TargetUnion: _#isCompare_TargetUnion

	// range_end compares the given target to all keys in the range [key, range_end).
	// See RangeRequest for more details on key ranges.
	range_end?: bytes @go(RangeEnd,[]byte) @protobuf(64,bytes,opt,json=rangeEnd,proto3)
}

_#isCompare_TargetUnion: _

#Compare_Version: {
	version?: int64 @go(Version) @protobuf(4,varint,opt,proto3,oneof)
}

#Compare_CreateRevision: {
	create_revision?: int64 @go(CreateRevision) @protobuf(5,varint,opt,json=createRevision,proto3,oneof)
}

#Compare_ModRevision: {
	mod_revision?: int64 @go(ModRevision) @protobuf(6,varint,opt,json=modRevision,proto3,oneof)
}

#Compare_Value: {
	value?: bytes @go(Value,[]byte) @protobuf(7,bytes,opt,proto3,oneof)
}

#Compare_Lease: {
	lease?: int64 @go(Lease) @protobuf(8,varint,opt,proto3,oneof)
}

// From google paxosdb paper:
// Our implementation hinges around a powerful primitive which we call MultiOp. All other database
// operations except for iteration are implemented as a single call to MultiOp. A MultiOp is applied atomically
// and consists of three components:
// 1. A list of tests called guard. Each test in guard checks a single entry in the database. It may check
// for the absence or presence of a value, or compare with a given value. Two different tests in the guard
// may apply to the same or different entries in the database. All tests in the guard are applied and
// MultiOp returns the results. If all tests are true, MultiOp executes t op (see item 2 below), otherwise
// it executes f op (see item 3 below).
// 2. A list of database operations called t op. Each operation in the list is either an insert, delete, or
// lookup operation, and applies to a single database entry. Two different operations in the list may apply
// to the same or different entries in the database. These operations are executed
// if guard evaluates to
// true.
// 3. A list of database operations called f op. Like t op, but executed if guard evaluates to false.
#TxnRequest: {
	// compare is a list of predicates representing a conjunction of terms.
	// If the comparisons succeed, then the success requests will be processed in order,
	// and the response will contain their respective responses in order.
	// If the comparisons fail, then the failure requests will be processed in order,
	// and the response will contain their respective responses in order.
	compare?: [...null | #Compare] @go(Compare,[]*Compare) @protobuf(1,bytes,rep,proto3)

	// success is a list of requests which will be applied when compare evaluates to true.
	success?: [...null | #RequestOp] @go(Success,[]*RequestOp) @protobuf(2,bytes,rep,proto3)

	// failure is a list of requests which will be applied when compare evaluates to false.
	failure?: [...null | #RequestOp] @go(Failure,[]*RequestOp) @protobuf(3,bytes,rep,proto3)
}

#TxnResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// succeeded is set to true if the compare evaluated to true or false otherwise.
	succeeded?: bool @go(Succeeded) @protobuf(2,varint,opt,proto3)

	// responses is a list of responses corresponding to the results from applying
	// success if succeeded is true or failure if succeeded is false.
	responses?: [...null | #ResponseOp] @go(Responses,[]*ResponseOp) @protobuf(3,bytes,rep,proto3)
}

// CompactionRequest compacts the key-value store up to a given revision. All superseded keys
// with a revision less than the compaction revision will be removed.
#CompactionRequest: {
	// revision is the key-value store revision for the compaction operation.
	revision?: int64 @go(Revision) @protobuf(1,varint,opt,proto3)

	// physical is set so the RPC will wait until the compaction is physically
	// applied to the local database such that compacted entries are totally
	// removed from the backend database.
	physical?: bool @go(Physical) @protobuf(2,varint,opt,proto3)
}

#CompactionResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#HashRequest: {}

#HashKVRequest: {
	// revision is the key-value store revision for the hash operation.
	revision?: int64 @go(Revision) @protobuf(1,varint,opt,proto3)
}

#HashKVResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// hash is the hash value computed from the responding member's MVCC keys up to a given revision.
	hash?: uint32 @go(Hash) @protobuf(2,varint,opt,proto3)

	// compact_revision is the compacted revision of key-value store when hash begins.
	compact_revision?: int64 @go(CompactRevision) @protobuf(3,varint,opt,json=compactRevision,proto3)

	// hash_revision is the revision up to which the hash is calculated.
	hash_revision?: int64 @go(HashRevision) @protobuf(4,varint,opt,json=hashRevision,proto3)
}

#HashResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// hash is the hash value computed from the responding member's KV's backend.
	hash?: uint32 @go(Hash) @protobuf(2,varint,opt,proto3)
}

#SnapshotRequest: {}

#SnapshotResponse: {
	// header has the current key-value store information. The first header in the snapshot
	// stream indicates the point in time of the snapshot.
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// remaining_bytes is the number of blob bytes to be sent after this message
	remaining_bytes?: uint64 @go(RemainingBytes) @protobuf(2,varint,opt,json=remainingBytes,proto3)

	// blob contains the next chunk of the snapshot in the snapshot stream.
	blob?: bytes @go(Blob,[]byte) @protobuf(3,bytes,opt,proto3)

	// local version of server that created the snapshot.
	// In cluster with binaries with different version, each cluster can return different result.
	// Informs which etcd server version should be used when restoring the snapshot.
	version?: string @go(Version) @protobuf(4,bytes,opt,proto3)
}

#WatchRequest: {
	// request_union is a request to either create a new watcher or cancel an existing watcher.
	//
	// Types that are valid to be assigned to RequestUnion:
	//	*WatchRequest_CreateRequest
	//	*WatchRequest_CancelRequest
	//	*WatchRequest_ProgressRequest
	RequestUnion: _#isWatchRequest_RequestUnion
}

_#isWatchRequest_RequestUnion: _

#WatchRequest_CreateRequest: {
	create_request?: null | #WatchCreateRequest @go(CreateRequest,*WatchCreateRequest) @protobuf(1,bytes,opt,json=createRequest,proto3,oneof)
}

#WatchRequest_CancelRequest: {
	cancel_request?: null | #WatchCancelRequest @go(CancelRequest,*WatchCancelRequest) @protobuf(2,bytes,opt,json=cancelRequest,proto3,oneof)
}

#WatchRequest_ProgressRequest: {
	progress_request?: null | #WatchProgressRequest @go(ProgressRequest,*WatchProgressRequest) @protobuf(3,bytes,opt,json=progressRequest,proto3,oneof)
}

#WatchCreateRequest: {
	// key is the key to register for watching.
	key?: bytes @go(Key,[]byte) @protobuf(1,bytes,opt,proto3)

	// range_end is the end of the range [key, range_end) to watch. If range_end is not given,
	// only the key argument is watched. If range_end is equal to '\0', all keys greater than
	// or equal to the key argument are watched.
	// If the range_end is one bit larger than the given key,
	// then all keys with the prefix (the given key) will be watched.
	range_end?: bytes @go(RangeEnd,[]byte) @protobuf(2,bytes,opt,json=rangeEnd,proto3)

	// start_revision is an optional revision to watch from (inclusive). No start_revision is "now".
	start_revision?: int64 @go(StartRevision) @protobuf(3,varint,opt,json=startRevision,proto3)

	// progress_notify is set so that the etcd server will periodically send a WatchResponse with
	// no events to the new watcher if there are no recent events. It is useful when clients
	// wish to recover a disconnected watcher starting from a recent known revision.
	// The etcd server may decide how often it will send notifications based on current load.
	progress_notify?: bool @go(ProgressNotify) @protobuf(4,varint,opt,json=progressNotify,proto3)

	// filters filter the events at server side before it sends back to the watcher.
	filters?: [...#WatchCreateRequest_FilterType] @go(Filters,[]WatchCreateRequest_FilterType) @protobuf(5,varint,rep,packed,proto3,enum=etcdserverpb.WatchCreateRequest_FilterType)

	// If prev_kv is set, created watcher gets the previous KV before the event happens.
	// If the previous KV is already compacted, nothing will be returned.
	prev_kv?: bool @go(PrevKv) @protobuf(6,varint,opt,json=prevKv,proto3)

	// If watch_id is provided and non-zero, it will be assigned to this watcher.
	// Since creating a watcher in etcd is not a synchronous operation,
	// this can be used ensure that ordering is correct when creating multiple
	// watchers on the same stream. Creating a watcher with an ID already in
	// use on the stream will cause an error to be returned.
	watch_id?: int64 @go(WatchId) @protobuf(7,varint,opt,json=watchId,proto3)

	// fragment enables splitting large revisions into multiple watch responses.
	fragment?: bool @go(Fragment) @protobuf(8,varint,opt,proto3)
}

#WatchCancelRequest: {
	// watch_id is the watcher id to cancel so that no more events are transmitted.
	watch_id?: int64 @go(WatchId) @protobuf(1,varint,opt,json=watchId,proto3)
}

// Requests the a watch stream progress status be sent in the watch response stream as soon as
// possible.
#WatchProgressRequest: {}

#WatchResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// watch_id is the ID of the watcher that corresponds to the response.
	watch_id?: int64 @go(WatchId) @protobuf(2,varint,opt,json=watchId,proto3)

	// created is set to true if the response is for a create watch request.
	// The client should record the watch_id and expect to receive events for
	// the created watcher from the same stream.
	// All events sent to the created watcher will attach with the same watch_id.
	created?: bool @go(Created) @protobuf(3,varint,opt,proto3)

	// canceled is set to true if the response is for a cancel watch request
	// or if the start_revision has already been compacted.
	// No further events will be sent to the canceled watcher.
	canceled?: bool @go(Canceled) @protobuf(4,varint,opt,proto3)

	// compact_revision is set to the minimum index if a watcher tries to watch
	// at a compacted index.
	//
	// This happens when creating a watcher at a compacted revision or the watcher cannot
	// catch up with the progress of the key-value store.
	//
	// The client should treat the watcher as canceled and should not try to create any
	// watcher with the same start_revision again.
	compact_revision?: int64 @go(CompactRevision) @protobuf(5,varint,opt,json=compactRevision,proto3)

	// cancel_reason indicates the reason for canceling the watcher.
	cancel_reason?: string @go(CancelReason) @protobuf(6,bytes,opt,json=cancelReason,proto3)

	// framgment is true if large watch response was split over multiple responses.
	fragment?: bool @go(Fragment) @protobuf(7,varint,opt,proto3)
	events?: [...null | mvccpb.#Event] @go(Events,[]*mvccpb.Event) @protobuf(11,bytes,rep,proto3)
}

#LeaseGrantRequest: {
	// TTL is the advisory time-to-live in seconds. Expired lease will return -1.
	TTL?: int64 @protobuf(1,varint,opt,proto3)

	// ID is the requested ID for the lease. If ID is set to 0, the lessor chooses an ID.
	ID?: int64 @protobuf(2,varint,opt,proto3)
}

#LeaseGrantResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// ID is the lease ID for the granted lease.
	ID?: int64 @protobuf(2,varint,opt,proto3)

	// TTL is the server chosen lease time-to-live in seconds.
	TTL?:   int64  @protobuf(3,varint,opt,proto3)
	error?: string @go(Error) @protobuf(4,bytes,opt,proto3)
}

#LeaseRevokeRequest: {
	// ID is the lease ID to revoke. When the ID is revoked, all associated keys will be deleted.
	ID?: int64 @protobuf(1,varint,opt,proto3)
}

#LeaseRevokeResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#LeaseCheckpoint: {
	// ID is the lease ID to checkpoint.
	ID?: int64 @protobuf(1,varint,opt,proto3)

	// Remaining_TTL is the remaining time until expiry of the lease.
	remaining_TTL?: int64 @go(Remaining_TTL) @protobuf(2,varint,opt,json=remainingTTL,proto3)
}

#LeaseCheckpointRequest: {
	checkpoints?: [...null | #LeaseCheckpoint] @go(Checkpoints,[]*LeaseCheckpoint) @protobuf(1,bytes,rep,proto3)
}

#LeaseCheckpointResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#LeaseKeepAliveRequest: {
	// ID is the lease ID for the lease to keep alive.
	ID?: int64 @protobuf(1,varint,opt,proto3)
}

#LeaseKeepAliveResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// ID is the lease ID from the keep alive request.
	ID?: int64 @protobuf(2,varint,opt,proto3)

	// TTL is the new time-to-live for the lease.
	TTL?: int64 @protobuf(3,varint,opt,proto3)
}

#LeaseTimeToLiveRequest: {
	// ID is the lease ID for the lease.
	ID?: int64 @protobuf(1,varint,opt,proto3)

	// keys is true to query all the keys attached to this lease.
	keys?: bool @go(Keys) @protobuf(2,varint,opt,proto3)
}

#LeaseTimeToLiveResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// ID is the lease ID from the keep alive request.
	ID?: int64 @protobuf(2,varint,opt,proto3)

	// TTL is the remaining TTL in seconds for the lease; the lease will expire in under TTL+1 seconds.
	TTL?: int64 @protobuf(3,varint,opt,proto3)

	// GrantedTTL is the initial granted time in seconds upon lease creation/renewal.
	grantedTTL?: int64 @go(GrantedTTL) @protobuf(4,varint,opt,proto3)

	// Keys is the list of keys attached to this lease.
	keys?: [...bytes] @go(Keys,[][]byte) @protobuf(5,bytes,rep,proto3)
}

#LeaseLeasesRequest: {}

#LeaseStatus: {
	ID?: int64 @protobuf(1,varint,opt,proto3)
}

#LeaseLeasesResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
	leases?: [...null | #LeaseStatus] @go(Leases,[]*LeaseStatus) @protobuf(2,bytes,rep,proto3)
}

#Member: {
	// ID is the member ID for this member.
	ID?: uint64 @protobuf(1,varint,opt,proto3)

	// name is the human-readable name of the member. If the member is not started, the name will be an empty string.
	name?: string @go(Name) @protobuf(2,bytes,opt,proto3)

	// peerURLs is the list of URLs the member exposes to the cluster for communication.
	peerURLs?: [...string] @go(PeerURLs,[]string) @protobuf(3,bytes,rep,proto3)

	// clientURLs is the list of URLs the member exposes to clients for communication. If the member is not started, clientURLs will be empty.
	clientURLs?: [...string] @go(ClientURLs,[]string) @protobuf(4,bytes,rep,proto3)

	// isLearner indicates if the member is raft learner.
	isLearner?: bool @go(IsLearner) @protobuf(5,varint,opt,proto3)
}

#MemberAddRequest: {
	// peerURLs is the list of URLs the added member will use to communicate with the cluster.
	peerURLs?: [...string] @go(PeerURLs,[]string) @protobuf(1,bytes,rep,proto3)

	// isLearner indicates if the added member is raft learner.
	isLearner?: bool @go(IsLearner) @protobuf(2,varint,opt,proto3)
}

#MemberAddResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// member is the member information for the added member.
	member?: null | #Member @go(Member,*Member) @protobuf(2,bytes,opt,proto3)

	// members is a list of all members after adding the new member.
	members?: [...null | #Member] @go(Members,[]*Member) @protobuf(3,bytes,rep,proto3)
}

#MemberRemoveRequest: {
	// ID is the member ID of the member to remove.
	ID?: uint64 @protobuf(1,varint,opt,proto3)
}

#MemberRemoveResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// members is a list of all members after removing the member.
	members?: [...null | #Member] @go(Members,[]*Member) @protobuf(2,bytes,rep,proto3)
}

#MemberUpdateRequest: {
	// ID is the member ID of the member to update.
	ID?: uint64 @protobuf(1,varint,opt,proto3)

	// peerURLs is the new list of URLs the member will use to communicate with the cluster.
	peerURLs?: [...string] @go(PeerURLs,[]string) @protobuf(2,bytes,rep,proto3)
}

#MemberUpdateResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// members is a list of all members after updating the member.
	members?: [...null | #Member] @go(Members,[]*Member) @protobuf(2,bytes,rep,proto3)
}

#MemberListRequest: {
	linearizable?: bool @go(Linearizable) @protobuf(1,varint,opt,proto3)
}

#MemberListResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// members is a list of all members associated with the cluster.
	members?: [...null | #Member] @go(Members,[]*Member) @protobuf(2,bytes,rep,proto3)
}

#MemberPromoteRequest: {
	// ID is the member ID of the member to promote.
	ID?: uint64 @protobuf(1,varint,opt,proto3)
}

#MemberPromoteResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// members is a list of all members after promoting the member.
	members?: [...null | #Member] @go(Members,[]*Member) @protobuf(2,bytes,rep,proto3)
}

#DefragmentRequest: {}

#DefragmentResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#MoveLeaderRequest: {
	// targetID is the node ID for the new leader.
	targetID?: uint64 @go(TargetID) @protobuf(1,varint,opt,proto3)
}

#MoveLeaderResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#AlarmRequest: {
	// action is the kind of alarm request to issue. The action
	// may GET alarm statuses, ACTIVATE an alarm, or DEACTIVATE a
	// raised alarm.
	action?: #AlarmRequest_AlarmAction @go(Action) @protobuf(1,varint,opt,proto3,enum=etcdserverpb.AlarmRequest_AlarmAction)

	// memberID is the ID of the member associated with the alarm. If memberID is 0, the
	// alarm request covers all members.
	memberID?: uint64 @go(MemberID) @protobuf(2,varint,opt,proto3)

	// alarm is the type of alarm to consider for this request.
	alarm?: #AlarmType @go(Alarm) @protobuf(3,varint,opt,proto3,enum=etcdserverpb.AlarmType)
}

#AlarmMember: {
	// memberID is the ID of the member associated with the raised alarm.
	memberID?: uint64 @go(MemberID) @protobuf(1,varint,opt,proto3)

	// alarm is the type of alarm which has been raised.
	alarm?: #AlarmType @go(Alarm) @protobuf(2,varint,opt,proto3,enum=etcdserverpb.AlarmType)
}

#AlarmResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// alarms is a list of alarms associated with the alarm request.
	alarms?: [...null | #AlarmMember] @go(Alarms,[]*AlarmMember) @protobuf(2,bytes,rep,proto3)
}

#DowngradeRequest: {
	// action is the kind of downgrade request to issue. The action may
	// VALIDATE the target version, DOWNGRADE the cluster version,
	// or CANCEL the current downgrading job.
	action?: #DowngradeRequest_DowngradeAction @go(Action) @protobuf(1,varint,opt,proto3,enum=etcdserverpb.DowngradeRequest_DowngradeAction)

	// version is the target version to downgrade.
	version?: string @go(Version) @protobuf(2,bytes,opt,proto3)
}

#DowngradeResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// version is the current cluster version.
	version?: string @go(Version) @protobuf(2,bytes,opt,proto3)
}

// DowngradeVersionTestRequest is used for test only. The version in
// this request will be read as the WAL record version.If the downgrade
// target version is less than this version, then the downgrade(online)
// or migration(offline) isn't safe, so shouldn't be allowed.
#DowngradeVersionTestRequest: {
	ver?: string @go(Ver) @protobuf(1,bytes,opt,proto3)
}

#StatusRequest: {}

#StatusResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// version is the cluster protocol version used by the responding member.
	version?: string @go(Version) @protobuf(2,bytes,opt,proto3)

	// dbSize is the size of the backend database physically allocated, in bytes, of the responding member.
	dbSize?: int64 @go(DbSize) @protobuf(3,varint,opt,proto3)

	// leader is the member ID which the responding member believes is the current leader.
	leader?: uint64 @go(Leader) @protobuf(4,varint,opt,proto3)

	// raftIndex is the current raft committed index of the responding member.
	raftIndex?: uint64 @go(RaftIndex) @protobuf(5,varint,opt,proto3)

	// raftTerm is the current raft term of the responding member.
	raftTerm?: uint64 @go(RaftTerm) @protobuf(6,varint,opt,proto3)

	// raftAppliedIndex is the current raft applied index of the responding member.
	raftAppliedIndex?: uint64 @go(RaftAppliedIndex) @protobuf(7,varint,opt,proto3)

	// errors contains alarm/health information and status.
	errors?: [...string] @go(Errors,[]string) @protobuf(8,bytes,rep,proto3)

	// dbSizeInUse is the size of the backend database logically in use, in bytes, of the responding member.
	dbSizeInUse?: int64 @go(DbSizeInUse) @protobuf(9,varint,opt,proto3)

	// isLearner indicates if the member is raft learner.
	isLearner?: bool @go(IsLearner) @protobuf(10,varint,opt,proto3)

	// storageVersion is the version of the db file. It might be updated with delay in relationship to the target cluster version.
	storageVersion?: string @go(StorageVersion) @protobuf(11,bytes,opt,proto3)

	// dbSizeQuota is the configured etcd storage quota in bytes (the value passed to etcd instance by flag --quota-backend-bytes)
	dbSizeQuota?: int64 @go(DbSizeQuota) @protobuf(12,varint,opt,proto3)

	// downgradeInfo indicates if there is downgrade process.
	downgradeInfo?: null | #DowngradeInfo @go(DowngradeInfo,*DowngradeInfo) @protobuf(13,bytes,opt,proto3)
}

#DowngradeInfo: {
	// enabled indicates whether the cluster is enabled to downgrade.
	enabled?: bool @go(Enabled) @protobuf(1,varint,opt,proto3)

	// targetVersion is the target downgrade version.
	targetVersion?: string @go(TargetVersion) @protobuf(2,bytes,opt,proto3)
}

#AuthEnableRequest: {}

#AuthDisableRequest: {}

#AuthStatusRequest: {}

#AuthenticateRequest: {
	name?:     string @go(Name) @protobuf(1,bytes,opt,proto3)
	password?: string @go(Password) @protobuf(2,bytes,opt,proto3)
}

#AuthUserAddRequest: {
	name?:           string                        @go(Name) @protobuf(1,bytes,opt,proto3)
	password?:       string                        @go(Password) @protobuf(2,bytes,opt,proto3)
	options?:        null | authpb.#UserAddOptions @go(Options,*authpb.UserAddOptions) @protobuf(3,bytes,opt,proto3)
	hashedPassword?: string                        @go(HashedPassword) @protobuf(4,bytes,opt,proto3)
}

#AuthUserGetRequest: {
	name?: string @go(Name) @protobuf(1,bytes,opt,proto3)
}

#AuthUserDeleteRequest: {
	// name is the name of the user to delete.
	name?: string @go(Name) @protobuf(1,bytes,opt,proto3)
}

#AuthUserChangePasswordRequest: {
	// name is the name of the user whose password is being changed.
	name?: string @go(Name) @protobuf(1,bytes,opt,proto3)

	// password is the new password for the user. Note that this field will be removed in the API layer.
	password?: string @go(Password) @protobuf(2,bytes,opt,proto3)

	// hashedPassword is the new password for the user. Note that this field will be initialized in the API layer.
	hashedPassword?: string @go(HashedPassword) @protobuf(3,bytes,opt,proto3)
}

#AuthUserGrantRoleRequest: {
	// user is the name of the user which should be granted a given role.
	user?: string @go(User) @protobuf(1,bytes,opt,proto3)

	// role is the name of the role to grant to the user.
	role?: string @go(Role) @protobuf(2,bytes,opt,proto3)
}

#AuthUserRevokeRoleRequest: {
	name?: string @go(Name) @protobuf(1,bytes,opt,proto3)
	role?: string @go(Role) @protobuf(2,bytes,opt,proto3)
}

#AuthRoleAddRequest: {
	// name is the name of the role to add to the authentication system.
	name?: string @go(Name) @protobuf(1,bytes,opt,proto3)
}

#AuthRoleGetRequest: {
	role?: string @go(Role) @protobuf(1,bytes,opt,proto3)
}

#AuthUserListRequest: {}

#AuthRoleListRequest: {}

#AuthRoleDeleteRequest: {
	role?: string @go(Role) @protobuf(1,bytes,opt,proto3)
}

#AuthRoleGrantPermissionRequest: {
	// name is the name of the role which will be granted the permission.
	name?: string @go(Name) @protobuf(1,bytes,opt,proto3)

	// perm is the permission to grant to the role.
	perm?: null | authpb.#Permission @go(Perm,*authpb.Permission) @protobuf(2,bytes,opt,proto3)
}

#AuthRoleRevokePermissionRequest: {
	role?:      string @go(Role) @protobuf(1,bytes,opt,proto3)
	key?:       bytes  @go(Key,[]byte) @protobuf(2,bytes,opt,proto3)
	range_end?: bytes  @go(RangeEnd,[]byte) @protobuf(3,bytes,opt,json=rangeEnd,proto3)
}

#AuthEnableResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#AuthDisableResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#AuthStatusResponse: {
	header?:  null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
	enabled?: bool                   @go(Enabled) @protobuf(2,varint,opt,proto3)

	// authRevision is the current revision of auth store
	authRevision?: uint64 @go(AuthRevision) @protobuf(3,varint,opt,proto3)
}

#AuthenticateResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)

	// token is an authorized token that can be used in succeeding RPCs
	token?: string @go(Token) @protobuf(2,bytes,opt,proto3)
}

#AuthUserAddResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#AuthUserGetResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
	roles?: [...string] @go(Roles,[]string) @protobuf(2,bytes,rep,proto3)
}

#AuthUserDeleteResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#AuthUserChangePasswordResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#AuthUserGrantRoleResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#AuthUserRevokeRoleResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#AuthRoleAddResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#AuthRoleGetResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
	perm?: [...null | authpb.#Permission] @go(Perm,[]*authpb.Permission) @protobuf(2,bytes,rep,proto3)
}

#AuthRoleListResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
	roles?: [...string] @go(Roles,[]string) @protobuf(2,bytes,rep,proto3)
}

#AuthUserListResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
	users?: [...string] @go(Users,[]string) @protobuf(2,bytes,rep,proto3)
}

#AuthRoleDeleteResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#AuthRoleGrantPermissionResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

#AuthRoleRevokePermissionResponse: {
	header?: null | #ResponseHeader @go(Header,*ResponseHeader) @protobuf(1,bytes,opt,proto3)
}

// KVClient is the client API for KV service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
#KVClient: _

// KVServer is the server API for KV service.
#KVServer: _

// UnimplementedKVServer can be embedded to have forward compatible implementations.
#UnimplementedKVServer: {}

// WatchClient is the client API for Watch service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
#WatchClient: _

#Watch_WatchClient: _

_#watchWatchClient: ClientStream: grpc.#ClientStream

// WatchServer is the server API for Watch service.
#WatchServer: _

// UnimplementedWatchServer can be embedded to have forward compatible implementations.
#UnimplementedWatchServer: {}

#Watch_WatchServer: _

_#watchWatchServer: ServerStream: grpc.#ServerStream

// LeaseClient is the client API for Lease service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
#LeaseClient: _

#Lease_LeaseKeepAliveClient: _

_#leaseLeaseKeepAliveClient: ClientStream: grpc.#ClientStream

// LeaseServer is the server API for Lease service.
#LeaseServer: _

// UnimplementedLeaseServer can be embedded to have forward compatible implementations.
#UnimplementedLeaseServer: {}

#Lease_LeaseKeepAliveServer: _

_#leaseLeaseKeepAliveServer: ServerStream: grpc.#ServerStream

// ClusterClient is the client API for Cluster service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
#ClusterClient: _

// ClusterServer is the server API for Cluster service.
#ClusterServer: _

// UnimplementedClusterServer can be embedded to have forward compatible implementations.
#UnimplementedClusterServer: {}

// MaintenanceClient is the client API for Maintenance service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
#MaintenanceClient: _

#Maintenance_SnapshotClient: _

_#maintenanceSnapshotClient: ClientStream: grpc.#ClientStream

// MaintenanceServer is the server API for Maintenance service.
#MaintenanceServer: _

// UnimplementedMaintenanceServer can be embedded to have forward compatible implementations.
#UnimplementedMaintenanceServer: {}

#Maintenance_SnapshotServer: _

_#maintenanceSnapshotServer: ServerStream: grpc.#ServerStream

// AuthClient is the client API for Auth service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
#AuthClient: _

// AuthServer is the server API for Auth service.
#AuthServer: _

// UnimplementedAuthServer can be embedded to have forward compatible implementations.
#UnimplementedAuthServer: {}
