// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/cilium/cilium/pkg/k8s/slim/k8s/api/core/v1

package v1

import (
	slim_metav1 "github.com/cilium/cilium/pkg/k8s/slim/k8s/apis/meta/v1"
	"github.com/cilium/cilium/pkg/k8s/slim/k8s/apis/util/intstr"
)

// NamespaceDefault means the object is in the default namespace which is applied when not specified by clients
#NamespaceDefault: "default"

// NamespaceAll is the default argument to specify on a context when you want to list or filter resources across all namespaces
#NamespaceAll: ""

// NamespaceNodeLease is the namespace where we place node lease objects (used for node heartbeats)
#NamespaceNodeLease: "kube-node-lease"

// Protocol defines network protocols supported for things like container ports.
// +enum
#Protocol: string // #enumProtocol

#enumProtocol:
	#ProtocolTCP |
	#ProtocolUDP |
	#ProtocolSCTP

// ProtocolTCP is the TCP protocol.
#ProtocolTCP: #Protocol & "TCP"

// ProtocolUDP is the UDP protocol.
#ProtocolUDP: #Protocol & "UDP"

// ProtocolSCTP is the SCTP protocol.
#ProtocolSCTP: #Protocol & "SCTP"

// ContainerPort represents a network port in a single container.
#ContainerPort: {
	// If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
	// named port in a pod must have a unique name. Name for the port that can be
	// referred to by services.
	// +optional
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// Number of port to expose on the host.
	// If specified, this must be a valid port number, 0 < x < 65536.
	// If HostNetwork is specified, this must match ContainerPort.
	// Most containers do not need this.
	// +optional
	hostPort?: int32 @go(HostPort) @protobuf(2,varint,opt)

	// Number of port to expose on the pod's IP address.
	// This must be a valid port number, 0 < x < 65536.
	containerPort: int32 @go(ContainerPort) @protobuf(3,varint,opt)

	// Protocol for port. Must be UDP, TCP, or SCTP.
	// Defaults to "TCP".
	// +optional
	// +default="TCP"
	protocol?: #Protocol @go(Protocol) @protobuf(4,bytes,opt,casttype=Protocol)

	// What host IP to bind the external port to.
	// +optional
	hostIP?: string @go(HostIP) @protobuf(5,bytes,opt)
}

// VolumeMount describes a mounting of a Volume within a container.
#VolumeMount: {
	// Path within the container at which the volume should be mounted.  Must
	// not contain ':'.
	mountPath: string @go(MountPath) @protobuf(3,bytes,opt)
}

// A single application container that you want to run within a pod.
#Container: {
	// Name of the container specified as a DNS_LABEL.
	// Each container in a pod must have a unique name (DNS_LABEL).
	// Cannot be updated.
	name: string @go(Name) @protobuf(1,bytes,opt)

	// Container image name.
	// More info: https://kubernetes.io/docs/concepts/containers/images
	// This field is optional to allow higher level config management to default or override
	// container images in workload controllers like Deployments and StatefulSets.
	// +optional
	image?: string @go(Image) @protobuf(2,bytes,opt)

	// List of ports to expose from the container. Not specifying a port here
	// DOES NOT prevent that port from being exposed. Any port which is
	// listening on the default "0.0.0.0" address inside a container will be
	// accessible from the network.
	// Modifying this array with strategic merge patch may corrupt the data.
	// For more information See https://github.com/kubernetes/kubernetes/issues/108255.
	// Cannot be updated.
	// +optional
	// +patchMergeKey=containerPort
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=containerPort
	// +listMapKey=protocol
	ports?: [...#ContainerPort] @go(Ports,[]ContainerPort) @protobuf(6,bytes,rep)

	// Pod volumes to mount into the container's filesystem.
	// Cannot be updated.
	// +optional
	// +patchMergeKey=mountPath
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=mountPath
	volumeMounts?: [...#VolumeMount] @go(VolumeMounts,[]VolumeMount) @protobuf(9,bytes,rep)
}

#ConditionStatus: string // #enumConditionStatus

#enumConditionStatus:
	#ConditionTrue |
	#ConditionFalse |
	#ConditionUnknown

#ConditionTrue:    #ConditionStatus & "True"
#ConditionFalse:   #ConditionStatus & "False"
#ConditionUnknown: #ConditionStatus & "Unknown"

// ContainerStateRunning is a running state of a container.
#ContainerStateRunning: {
	// Time at which the container was last (re-)started
	// +optional
	startedAt?: slim_metav1.#Time @go(StartedAt) @protobuf(1,bytes,opt)
}

// ContainerState holds a possible state of container.
// Only one of its members may be specified.
// If none of them is specified, the default one is ContainerStateWaiting.
#ContainerState: {
	// Details about a running container
	// +optional
	running?: null | #ContainerStateRunning @go(Running,*ContainerStateRunning) @protobuf(2,bytes,opt)
}

// ContainerStatus contains details for the current status of this container.
#ContainerStatus: {
	// State holds details about the container's current condition.
	// +optional
	state?: #ContainerState @go(State) @protobuf(2,bytes,opt)

	// ContainerID is the ID of the container in the format '<type>://<container_id>'.
	// Where type is a container runtime identifier, returned from Version call of CRI API
	// (for example "containerd").
	// +optional
	containerID?: string @go(ContainerID) @protobuf(8,bytes,opt)
}

// PodPhase is a label for the condition of a pod at the current time.
// +enum
#PodPhase: string // #enumPodPhase

#enumPodPhase:
	#PodPending |
	#PodRunning |
	#PodSucceeded |
	#PodFailed |
	#PodUnknown

// PodPending means the pod has been accepted by the system, but one or more of the containers
// has not been started. This includes time before being bound to a node, as well as time spent
// pulling images onto the host.
#PodPending: #PodPhase & "Pending"

// PodRunning means the pod has been bound to a node and all of the containers have been started.
// At least one container is still running or is in the process of being restarted.
#PodRunning: #PodPhase & "Running"

// PodSucceeded means that all containers in the pod have voluntarily terminated
// with a container exit code of 0, and the system is not going to restart any of these containers.
#PodSucceeded: #PodPhase & "Succeeded"

// PodFailed means that all containers in the pod have terminated, and at least one container has
// terminated in a failure (exited with a non-zero exit code or was stopped by the system).
#PodFailed: #PodPhase & "Failed"

// PodUnknown means that for some reason the state of the pod could not be obtained, typically due
// to an error in communicating with the host of the pod.
// Deprecated: It isn't being set since 2015 (74da3b14b0c0f658b3bb8d2def5094686d0e9095)
#PodUnknown: #PodPhase & "Unknown"

// PodConditionType is a valid value for PodCondition.Type
#PodConditionType: string // #enumPodConditionType

#enumPodConditionType:
	#ContainersReady |
	#PodInitialized |
	#PodReady |
	#PodScheduled |
	#DisruptionTarget |
	#PodReadyToStartContainers |
	#PodResizePending |
	#PodResizeInProgress

// ContainersReady indicates whether all containers in the pod are ready.
#ContainersReady: #PodConditionType & "ContainersReady"

// PodInitialized means that all init containers in the pod have started successfully.
#PodInitialized: #PodConditionType & "Initialized"

// PodReady means the pod is able to service requests and should be added to the
// load balancing pools of all matching services.
#PodReady: #PodConditionType & "Ready"

// PodScheduled represents status of the scheduling process for this pod.
#PodScheduled: #PodConditionType & "PodScheduled"

// DisruptionTarget indicates the pod is about to be terminated due to a
// disruption (such as preemption, eviction API or garbage-collection).
#DisruptionTarget: #PodConditionType & "DisruptionTarget"

// PodReadyToStartContainers pod sandbox is successfully configured and
// the pod is ready to launch containers.
#PodReadyToStartContainers: #PodConditionType & "PodReadyToStartContainers"

// PodResizePending indicates that the pod has been resized, but kubelet has not
// yet allocated the resources. If both PodResizePending and PodResizeInProgress
// are set, it means that a new resize was requested in the middle of a previous
// pod resize that is still in progress.
#PodResizePending: #PodConditionType & "PodResizePending"

// PodResizeInProgress indicates that a resize is in progress, and is present whenever
// the Kubelet has allocated resources for the resize, but has not yet actuated all of
// the required changes.
// If both PodResizePending and PodResizeInProgress are set, it means that a new resize was
// requested in the middle of a previous pod resize that is still in progress.
#PodResizeInProgress: #PodConditionType & "PodResizeInProgress"

// PodReasonUnschedulable reason in PodScheduled PodCondition means that the scheduler
// can't schedule the pod right now, for example due to insufficient resources in the cluster.
#PodReasonUnschedulable: "Unschedulable"

// PodReasonSchedulingGated reason in PodScheduled PodCondition means that the scheduler
// skips scheduling the pod because one or more scheduling gates are still present.
#PodReasonSchedulingGated: "SchedulingGated"

// PodReasonSchedulerError reason in PodScheduled PodCondition means that some internal error happens
// during scheduling, for example due to nodeAffinity parsing errors.
#PodReasonSchedulerError: "SchedulerError"

// PodReasonTerminationByKubelet reason in DisruptionTarget pod condition indicates that the termination
// is initiated by kubelet
#PodReasonTerminationByKubelet: "TerminationByKubelet"

// PodReasonPreemptionByScheduler reason in DisruptionTarget pod condition indicates that the
// disruption was initiated by scheduler's preemption.
#PodReasonPreemptionByScheduler: "PreemptionByScheduler"

// PodReasonDeferred reason in PodResizePending pod condition indicates the proposed resize is feasible in
// theory (it fits on this node) but is not possible right now.
#PodReasonDeferred: "Deferred"

// PodReasonInfeasible reason in PodResizePending pod condition indicates the proposed resize is not
// feasible and is rejected; it may not be re-evaluated
#PodReasonInfeasible: "Infeasible"

// PodReasonError reason in PodResizeInProgress pod condition indicates that an error occurred while
// actuating the resize.
#PodReasonError: "Error"

// PodCondition contains details for the current condition of this pod.
#PodCondition: {
	// Type is the type of the condition.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	type: #PodConditionType @go(Type) @protobuf(1,bytes,opt,casttype=PodConditionType)

	// Status is the status of the condition.
	// Can be True, False, Unknown.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	status: #ConditionStatus @go(Status) @protobuf(2,bytes,opt,casttype=ConditionStatus)

	// Last time we probed the condition.
	// +optional
	lastProbeTime?: slim_metav1.#Time @go(LastProbeTime) @protobuf(3,bytes,opt)

	// Last time the condition transitioned from one status to another.
	// +optional
	lastTransitionTime?: slim_metav1.#Time @go(LastTransitionTime) @protobuf(4,bytes,opt)

	// Unique, one-word, CamelCase reason for the condition's last transition.
	// +optional
	reason?: string @go(Reason) @protobuf(5,bytes,opt)

	// Human-readable message indicating details about last transition.
	// +optional
	message?: string @go(Message) @protobuf(6,bytes,opt)
}

// DefaultTerminationGracePeriodSeconds indicates the default duration in
// seconds a pod needs to terminate gracefully.
#DefaultTerminationGracePeriodSeconds: 30

// The node this Taint is attached to has the "effect" on
// any pod that does not tolerate the Taint.
#Taint: {
	// Required. The taint key to be applied to a node.
	key: string @go(Key) @protobuf(1,bytes,opt)

	// The taint value corresponding to the taint key.
	// +optional
	value?: string @go(Value) @protobuf(2,bytes,opt)

	// Required. The effect of the taint on pods
	// that do not tolerate the taint.
	// Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
	effect: #TaintEffect @go(Effect) @protobuf(3,bytes,opt,casttype=TaintEffect)

	// TimeAdded represents the time at which the taint was added.
	// It is only written for NoExecute taints.
	// +optional
	timeAdded?: null | slim_metav1.#Time @go(TimeAdded,*slim_metav1.Time) @protobuf(4,bytes,opt)
}

// +enum
#TaintEffect: string // #enumTaintEffect

#enumTaintEffect:
	#TaintEffectNoSchedule |
	#TaintEffectPreferNoSchedule |
	#TaintEffectNoExecute

// Do not allow new pods to schedule onto the node unless they tolerate the taint,
// but allow all pods submitted to Kubelet without going through the scheduler
// to start, and allow all already-running pods to continue running.
// Enforced by the scheduler.
#TaintEffectNoSchedule: #TaintEffect & "NoSchedule"

// Like TaintEffectNoSchedule, but the scheduler tries not to schedule
// new pods onto the node, rather than prohibiting new pods from scheduling
// onto the node entirely. Enforced by the scheduler.
#TaintEffectPreferNoSchedule: #TaintEffect & "PreferNoSchedule"

// Evict any already-running pods that do not tolerate the taint.
// Currently enforced by NodeController.
#TaintEffectNoExecute: #TaintEffect & "NoExecute"

// PodReadinessGate contains the reference to a pod condition
#PodReadinessGate: {
	// ConditionType refers to a condition in the pod's condition list with matching type.
	conditionType: #PodConditionType @go(ConditionType) @protobuf(1,bytes,opt,casttype=PodConditionType)
}

// PodSpec is a description of a pod.
#PodSpec: {
	// List of initialization containers belonging to the pod.
	// Init containers are executed in order prior to containers being started. If any
	// init container fails, the pod is considered to have failed and is handled according
	// to its restartPolicy. The name for an init container or normal container must be
	// unique among all containers.
	// Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
	// The resourceRequirements of an init container are taken into account during scheduling
	// by finding the highest request/limit for each resource type, and then using the max of
	// that value or the sum of the normal containers. Limits are applied to init containers
	// in a similar fashion.
	// Init containers cannot currently be added or removed.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
	// +patchMergeKey=name
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=name
	initContainers?: [...#Container] @go(InitContainers,[]Container) @protobuf(20,bytes,rep)

	// List of containers belonging to the pod.
	// Containers cannot currently be added or removed.
	// There must be at least one container in a Pod.
	// Cannot be updated.
	// +patchMergeKey=name
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=name
	containers: [...#Container] @go(Containers,[]Container) @protobuf(2,bytes,rep)

	// ServiceAccountName is the name of the ServiceAccount to use to run this pod.
	// More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
	// +optional
	serviceAccountName?: string @go(ServiceAccountName) @protobuf(8,bytes,opt)

	// NodeName indicates in which node this pod is scheduled.
	// If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName.
	// Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod.
	// This field should not be used to express a desire for the pod to be scheduled on a specific node.
	// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename
	// +optional
	nodeName?: string @go(NodeName) @protobuf(10,bytes,opt)

	// Host networking requested for this pod. Use the host's network namespace.
	// If this option is set, the ports that will be used must be specified.
	// Default to false.
	// +k8s:conversion-gen=false
	// +optional
	hostNetwork?: bool @go(HostNetwork) @protobuf(11,varint,opt)
}

// PodQOSClass defines the supported qos classes of Pods.
// +enum
#PodQOSClass: string // #enumPodQOSClass

#enumPodQOSClass:
	#PodQOSGuaranteed |
	#PodQOSBurstable |
	#PodQOSBestEffort

// PodQOSGuaranteed is the Guaranteed qos class.
#PodQOSGuaranteed: #PodQOSClass & "Guaranteed"

// PodQOSBurstable is the Burstable qos class.
#PodQOSBurstable: #PodQOSClass & "Burstable"

// PodQOSBestEffort is the BestEffort qos class.
#PodQOSBestEffort: #PodQOSClass & "BestEffort"

// PodIP represents a single IP address allocated to the pod.
#PodIP: {
	// IP is the IP address assigned to the pod
	// +required
	ip: string @go(IP) @protobuf(1,bytes,opt)
}

// PodStatus represents information about the status of a pod. Status may trail the actual
// state of a system, especially if the node that hosts the pod cannot contact the control
// plane.
#PodStatus: {
	// The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
	// The conditions array, the reason and message fields, and the individual container status
	// arrays contain more detail about the pod's status.
	// There are five possible phase values:
	//
	// Pending: The pod has been accepted by the Kubernetes system, but one or more of the
	// container images has not been created. This includes time before being scheduled as
	// well as time spent downloading images over the network, which could take a while.
	// Running: The pod has been bound to a node, and all of the containers have been created.
	// At least one container is still running, or is in the process of starting or restarting.
	// Succeeded: All containers in the pod have terminated in success, and will not be restarted.
	// Failed: All containers in the pod have terminated, and at least one container has
	// terminated in failure. The container either exited with non-zero status or was terminated
	// by the system.
	// Unknown: For some reason the state of the pod could not be obtained, typically due to an
	// error in communicating with the host of the pod.
	//
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
	// +optional
	phase?: #PodPhase @go(Phase) @protobuf(1,bytes,opt,casttype=PodPhase)

	// Current service state of pod.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=type
	conditions?: [...#PodCondition] @go(Conditions,[]PodCondition) @protobuf(2,bytes,rep)

	// hostIP holds the IP address of the host to which the pod is assigned. Empty if the pod has not started yet.
	// A pod can be assigned to a node that has a problem in kubelet which in turns mean that HostIP will
	// not be updated even if there is a node is assigned to pod
	// +optional
	hostIP?: string @go(HostIP) @protobuf(5,bytes,opt)

	// podIP address allocated to the pod. Routable at least within the cluster.
	// Empty if not yet allocated.
	// +optional
	podIP?: string @go(PodIP) @protobuf(6,bytes,opt)

	// podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
	// match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
	// is empty if no IPs have been allocated yet.
	// +optional
	// +patchStrategy=merge
	// +patchMergeKey=ip
	// +listType=map
	// +listMapKey=ip
	podIPs?: [...#PodIP] @go(PodIPs,[]PodIP) @protobuf(12,bytes,rep)

	// RFC 3339 date and time at which the object was acknowledged by the Kubelet.
	// This is before the Kubelet pulled the container image(s) for the pod.
	// +optional
	startTime?: null | slim_metav1.#Time @go(StartTime,*slim_metav1.Time) @protobuf(7,bytes,opt)

	// Statuses of containers in this pod.
	// Each container in the pod should have at most one status in this list,
	// and all statuses should be for containers in the pod.
	// However this is not enforced.
	// If a status for a non-existent container is present in the list, or the list has duplicate names,
	// the behavior of various Kubernetes components is not defined and those statuses might be
	// ignored.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
	// +optional
	// +listType=atomic
	containerStatuses?: [...#ContainerStatus] @go(ContainerStatuses,[]ContainerStatus) @protobuf(8,bytes,rep)

	// The Quality of Service (QOS) classification assigned to the pod based on resource requirements
	// See PodQOSClass type for available QOS classes
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
	// +optional
	qosClass?: #PodQOSClass @go(QOSClass) @protobuf(9,bytes,rep)
}

// Pod is a collection of containers that can run on a host. This resource is created
// by clients and scheduled onto hosts.
#Pod: {
	slim_metav1.#TypeMeta

	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	metadata?: slim_metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Specification of the desired behavior of the pod.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	spec?: #PodSpec @go(Spec) @protobuf(2,bytes,opt)

	// Most recently observed status of the pod.
	// This data may not be up to date.
	// Populated by the system.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	status?: #PodStatus @go(Status) @protobuf(3,bytes,opt)
}

// PodList is a list of Pods.
#PodList: {
	slim_metav1.#TypeMeta

	// Standard list metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	metadata?: slim_metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// List of pods.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	items: [...#Pod] @go(Items,[]Pod) @protobuf(2,bytes,rep)
}

// Session Affinity Type string
// +enum
#ServiceAffinity: string // #enumServiceAffinity

#enumServiceAffinity:
	#ServiceAffinityClientIP |
	#ServiceAffinityNone

// ServiceAffinityClientIP is the Client IP based.
#ServiceAffinityClientIP: #ServiceAffinity & "ClientIP"

// ServiceAffinityNone - no session affinity.
#ServiceAffinityNone: #ServiceAffinity & "None"

#DefaultClientIPServiceAffinitySeconds: int32 & 10800

// SessionAffinityConfig represents the configurations of session affinity.
#SessionAffinityConfig: {
	// clientIP contains the configurations of Client IP based session affinity.
	// +optional
	clientIP?: null | #ClientIPConfig @go(ClientIP,*ClientIPConfig) @protobuf(1,bytes,opt)
}

// ClientIPConfig represents the configurations of Client IP based session affinity.
#ClientIPConfig: {
	// timeoutSeconds specifies the seconds of ClientIP type session sticky time.
	// The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
	// Default value is 10800(for 3 hours).
	// +optional
	timeoutSeconds?: null | int32 @go(TimeoutSeconds,*int32) @protobuf(1,varint,opt)
}

// Service Type string describes ingress methods for a service
// +enum
#ServiceType: string // #enumServiceType

#enumServiceType:
	#ServiceTypeClusterIP |
	#ServiceTypeNodePort |
	#ServiceTypeLoadBalancer |
	#ServiceTypeExternalName

// ServiceTypeClusterIP means a service will only be accessible inside the
// cluster, via the cluster IP.
#ServiceTypeClusterIP: #ServiceType & "ClusterIP"

// ServiceTypeNodePort means a service will be exposed on one port of
// every node, in addition to 'ClusterIP' type.
#ServiceTypeNodePort: #ServiceType & "NodePort"

// ServiceTypeLoadBalancer means a service will be exposed via an
// external load balancer (if the cloud provider supports it), in addition
// to 'NodePort' type.
#ServiceTypeLoadBalancer: #ServiceType & "LoadBalancer"

// ServiceTypeExternalName means a service consists of only a reference to
// an external name that kubedns or equivalent will return as a CNAME
// record, with no exposing or proxying of any pods involved.
#ServiceTypeExternalName: #ServiceType & "ExternalName"

// ServiceInternalTrafficPolicy describes how nodes distribute service traffic they
// receive on the ClusterIP.
// +enum
#ServiceInternalTrafficPolicy: string // #enumServiceInternalTrafficPolicy

#enumServiceInternalTrafficPolicy:
	#ServiceInternalTrafficPolicyCluster |
	#ServiceInternalTrafficPolicyLocal

// ServiceInternalTrafficPolicyCluster routes traffic to all endpoints.
#ServiceInternalTrafficPolicyCluster: #ServiceInternalTrafficPolicy & "Cluster"

// ServiceInternalTrafficPolicyLocal routes traffic only to endpoints on the same
// node as the client pod (dropping the traffic if there are no local endpoints).
#ServiceInternalTrafficPolicyLocal: #ServiceInternalTrafficPolicy & "Local"

// for backwards compat
// +enum
#ServiceInternalTrafficPolicyType: #ServiceInternalTrafficPolicy

// ServiceExternalTrafficPolicy describes how nodes distribute service traffic they
// receive on one of the Service's "externally-facing" addresses (NodePorts, ExternalIPs,
// and LoadBalancer IPs.
// +enum
#ServiceExternalTrafficPolicy: string // #enumServiceExternalTrafficPolicy

#enumServiceExternalTrafficPolicy:
	#ServiceExternalTrafficPolicyCluster |
	#ServiceExternalTrafficPolicyLocal

// ServiceExternalTrafficPolicyCluster routes traffic to all endpoints.
#ServiceExternalTrafficPolicyCluster: #ServiceExternalTrafficPolicy & "Cluster"

// ServiceExternalTrafficPolicyLocal preserves the source IP of the traffic by
// routing only to endpoints on the same node as the traffic was received on
// (dropping the traffic if there are no local endpoints).
#ServiceExternalTrafficPolicyLocal: #ServiceExternalTrafficPolicy & "Local"

// for backwards compat
// +enum
#ServiceExternalTrafficPolicyType: #ServiceExternalTrafficPolicy

// LoadBalancerPortsError represents the condition of the requested ports
// on the cloud load balancer instance.
#LoadBalancerPortsError: "LoadBalancerPortsError"

// LoadBalancerPortsErrorReason reason in ServiceStatus condition LoadBalancerPortsError
// means the LoadBalancer was not able to be configured correctly.
#LoadBalancerPortsErrorReason: "LoadBalancerMixedProtocolNotSupported"

// ServiceStatus represents the current status of a service.
#ServiceStatus: {
	// LoadBalancer contains the current status of the load-balancer,
	// if one is present.
	// +optional
	loadBalancer?: #LoadBalancerStatus @go(LoadBalancer) @protobuf(1,bytes,opt)

	// Current service state
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=type
	conditions?: [...slim_metav1.#Condition] @go(Conditions,[]slim_metav1.Condition) @protobuf(2,bytes,rep)
}

// LoadBalancerStatus represents the status of a load-balancer.
#LoadBalancerStatus: {
	// Ingress is a list containing ingress points for the load-balancer.
	// Traffic intended for the service should be sent to these ingress points.
	// +optional
	// +listType=atomic
	ingress?: [...#LoadBalancerIngress] @go(Ingress,[]LoadBalancerIngress) @protobuf(1,bytes,rep)
}

// LoadBalancerIngress represents the status of a load-balancer ingress point:
// traffic intended for the service should be sent to an ingress point.
#LoadBalancerIngress: {
	// IP is set for load-balancer ingress points that are IP based
	// (typically GCE or OpenStack load-balancers)
	// +optional
	ip?: string @go(IP) @protobuf(1,bytes,opt)

	// Hostname is set for load-balancer ingress points that are DNS based
	// (typically AWS load-balancers)
	// +optional
	hostname?: string @go(Hostname) @protobuf(2,bytes,opt)

	// IPMode specifies how the load-balancer IP behaves, and may only be specified when the ip field is specified.
	// Setting this to "VIP" indicates that traffic is delivered to the node with
	// the destination set to the load-balancer's IP and port.
	// Setting this to "Proxy" indicates that traffic is delivered to the node or pod with
	// the destination set to the node's IP and node port or the pod's IP and port.
	// Service implementations may use this information to adjust traffic routing.
	// +optional
	ipMode?: null | #LoadBalancerIPMode @go(IPMode,*LoadBalancerIPMode) @protobuf(3,bytes,opt)

	// Ports is a list of records of service ports
	// If used, every port defined in the service should have an entry in it
	// +listType=atomic
	// +optional
	ports?: [...#PortStatus] @go(Ports,[]PortStatus) @protobuf(4,bytes,rep)
}

// IPFamily represents the IP Family (IPv4 or IPv6). This type is used
// to express the family of an IP expressed by a type (e.g. service.spec.ipFamilies).
// +enum
#IPFamily: string // #enumIPFamily

#enumIPFamily:
	#IPv4Protocol |
	#IPv6Protocol |
	#IPFamilyUnknown

// IPv4Protocol indicates that this IP is IPv4 protocol
#IPv4Protocol: #IPFamily & "IPv4"

// IPv6Protocol indicates that this IP is IPv6 protocol
#IPv6Protocol: #IPFamily & "IPv6"

// IPFamilyUnknown indicates that this IP is unknown protocol
#IPFamilyUnknown: #IPFamily & ""

// IPFamilyPolicy represents the dual-stack-ness requested or required by a Service
// +enum
#IPFamilyPolicy: string // #enumIPFamilyPolicy

#enumIPFamilyPolicy:
	#IPFamilyPolicySingleStack |
	#IPFamilyPolicyPreferDualStack |
	#IPFamilyPolicyRequireDualStack

// IPFamilyPolicySingleStack indicates that this service is required to have a single IPFamily.
// The IPFamily assigned is based on the default IPFamily used by the cluster
// or as identified by service.spec.ipFamilies field
#IPFamilyPolicySingleStack: #IPFamilyPolicy & "SingleStack"

// IPFamilyPolicyPreferDualStack indicates that this service prefers dual-stack when
// the cluster is configured for dual-stack. If the cluster is not configured
// for dual-stack the service will be assigned a single IPFamily. If the IPFamily is not
// set in service.spec.ipFamilies then the service will be assigned the default IPFamily
// configured on the cluster
#IPFamilyPolicyPreferDualStack: #IPFamilyPolicy & "PreferDualStack"

// IPFamilyPolicyRequireDualStack indicates that this service requires dual-stack. Using
// IPFamilyPolicyRequireDualStack on a single stack cluster will result in validation errors. The
// IPFamilies (and their order) assigned  to this service is based on service.spec.ipFamilies. If
// service.spec.ipFamilies was not provided then it will be assigned according to how they are
// configured on the cluster. If service.spec.ipFamilies has only one entry then the alternative
// IPFamily will be added by apiserver
#IPFamilyPolicyRequireDualStack: #IPFamilyPolicy & "RequireDualStack"

// for backwards compat
// +enum
#IPFamilyPolicyType: #IPFamilyPolicy

// ServiceSpec describes the attributes that a user creates on a service.
#ServiceSpec: {
	// The list of ports that are exposed by this service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	// +patchMergeKey=port
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=port
	// +listMapKey=protocol
	ports?: [...#ServicePort] @go(Ports,[]ServicePort) @protobuf(1,bytes,rep)

	// Route service traffic to pods with label keys and values matching this
	// selector. If empty or not present, the service is assumed to have an
	// external process managing its endpoints, which Kubernetes will not
	// modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
	// Ignored if type is ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	// +optional
	// +mapType=atomic
	selector?: {[string]: string} @go(Selector,map[string]string) @protobuf(2,bytes,rep)

	// clusterIP is the IP address of the service and is usually assigned
	// randomly. If an address is specified manually, is in-range (as per
	// system configuration), and is not in use, it will be allocated to the
	// service; otherwise creation of the service will fail. This field may not
	// be changed through updates unless the type field is also being changed
	// to ExternalName (which requires this field to be blank) or the type
	// field is being changed from ExternalName (in which case this field may
	// optionally be specified, as describe above).  Valid values are "None",
	// empty string (""), or a valid IP address. Setting this to "None" makes a
	// "headless service" (no virtual IP), which is useful when direct endpoint
	// connections are preferred and proxying is not required.  Only applies to
	// types ClusterIP, NodePort, and LoadBalancer. If this field is specified
	// when creating a Service of type ExternalName, creation will fail. This
	// field will be wiped when updating a Service to type ExternalName.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	// +optional
	clusterIP?: string @go(ClusterIP) @protobuf(3,bytes,opt)

	// ClusterIPs is a list of IP addresses assigned to this service, and are
	// usually assigned randomly.  If an address is specified manually, is
	// in-range (as per system configuration), and is not in use, it will be
	// allocated to the service; otherwise creation of the service will fail.
	// This field may not be changed through updates unless the type field is
	// also being changed to ExternalName (which requires this field to be
	// empty) or the type field is being changed from ExternalName (in which
	// case this field may optionally be specified, as describe above).  Valid
	// values are "None", empty string (""), or a valid IP address.  Setting
	// this to "None" makes a "headless service" (no virtual IP), which is
	// useful when direct endpoint connections are preferred and proxying is
	// not required.  Only applies to types ClusterIP, NodePort, and
	// LoadBalancer. If this field is specified when creating a Service of type
	// ExternalName, creation will fail. This field will be wiped when updating
	// a Service to type ExternalName.  If this field is not specified, it will
	// be initialized from the clusterIP field.  If this field is specified,
	// clients must ensure that clusterIPs[0] and clusterIP have the same
	// value.
	//
	// This field may hold a maximum of two entries (dual-stack IPs, in either order).
	// These IPs must correspond to the values of the ipFamilies field. Both
	// clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	// +listType=atomic
	// +optional
	clusterIPs?: [...string] @go(ClusterIPs,[]string) @protobuf(18,bytes,opt)

	// type determines how the Service is exposed. Defaults to ClusterIP. Valid
	// options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
	// "ClusterIP" allocates a cluster-internal IP address for load-balancing
	// to endpoints. Endpoints are determined by the selector or if that is not
	// specified, by manual construction of an Endpoints object or
	// EndpointSlice objects. If clusterIP is "None", no virtual IP is
	// allocated and the endpoints are published as a set of endpoints rather
	// than a virtual IP.
	// "NodePort" builds on ClusterIP and allocates a port on every node which
	// routes to the same endpoints as the clusterIP.
	// "LoadBalancer" builds on NodePort and creates an external load-balancer
	// (if supported in the current cloud) which routes to the same endpoints
	// as the clusterIP.
	// "ExternalName" aliases this service to the specified externalName.
	// Several other fields do not apply to ExternalName services.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
	// +optional
	type?: #ServiceType @go(Type) @protobuf(4,bytes,opt,casttype=ServiceType)

	// externalIPs is a list of IP addresses for which nodes in the cluster
	// will also accept traffic for this service.  These IPs are not managed by
	// Kubernetes.  The user is responsible for ensuring that traffic arrives
	// at a node with this IP.  A common example is external load-balancers
	// that are not part of the Kubernetes system.
	// +optional
	// +listType=atomic
	externalIPs?: [...string] @go(ExternalIPs,[]string) @protobuf(5,bytes,rep)

	// Supports "ClientIP" and "None". Used to maintain session affinity.
	// Enable client IP based session affinity.
	// Must be ClientIP or None.
	// Defaults to None.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
	// +optional
	sessionAffinity?: #ServiceAffinity @go(SessionAffinity) @protobuf(7,bytes,opt,casttype=ServiceAffinity)

	// Only applies to Service Type: LoadBalancer.
	// This feature depends on whether the underlying cloud-provider supports specifying
	// the loadBalancerIP when a load balancer is created.
	// This field will be ignored if the cloud-provider does not support the feature.
	// Deprecated: This field was under-specified and its meaning varies across implementations.
	// Using it is non-portable and it may not support dual-stack.
	// Users are encouraged to use implementation-specific annotations when available.
	// +optional
	loadBalancerIP?: string @go(LoadBalancerIP) @protobuf(8,bytes,opt)

	// If specified and supported by the platform, this will restrict traffic through the cloud-provider
	// load-balancer will be restricted to the specified client IPs. This field will be ignored if the
	// cloud-provider does not support the feature."
	// More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
	// +optional
	// +listType=atomic
	loadBalancerSourceRanges?: [...string] @go(LoadBalancerSourceRanges,[]string) @protobuf(9,bytes,opt)

	// externalTrafficPolicy describes how nodes distribute service traffic they
	// receive on one of the Service's "externally-facing" addresses (NodePorts,
	// ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
	// the service in a way that assumes that external load balancers will take care
	// of balancing the service traffic between nodes, and so each node will deliver
	// traffic only to the node-local endpoints of the service, without masquerading
	// the client source IP. (Traffic mistakenly sent to a node with no endpoints will
	// be dropped.) The default value, "Cluster", uses the standard behavior of
	// routing to all endpoints evenly (possibly modified by topology and other
	// features). Note that traffic sent to an External IP or LoadBalancer IP from
	// within the cluster will always get "Cluster" semantics, but clients sending to
	// a NodePort from within the cluster may need to take traffic policy into account
	// when picking a node.
	// +optional
	externalTrafficPolicy?: #ServiceExternalTrafficPolicy @go(ExternalTrafficPolicy) @protobuf(11,bytes,opt)

	// healthCheckNodePort specifies the healthcheck nodePort for the service.
	// This only applies when type is set to LoadBalancer and
	// externalTrafficPolicy is set to Local. If a value is specified, is
	// in-range, and is not in use, it will be used.  If not specified, a value
	// will be automatically allocated.  External systems (e.g. load-balancers)
	// can use this port to determine if a given node holds endpoints for this
	// service or not.  If this field is specified when creating a Service
	// which does not need it, creation will fail. This field will be wiped
	// when updating a Service to no longer need it (e.g. changing type).
	// This field cannot be updated once set.
	// +optional
	healthCheckNodePort?: int32 @go(HealthCheckNodePort) @protobuf(12,bytes,opt)

	// sessionAffinityConfig contains the configurations of session affinity.
	// +optional
	sessionAffinityConfig?: null | #SessionAffinityConfig @go(SessionAffinityConfig,*SessionAffinityConfig) @protobuf(14,bytes,opt)

	// IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
	// service. This field is usually assigned automatically based on cluster
	// configuration and the ipFamilyPolicy field. If this field is specified
	// manually, the requested family is available in the cluster,
	// and ipFamilyPolicy allows it, it will be used; otherwise creation of
	// the service will fail. This field is conditionally mutable: it allows
	// for adding or removing a secondary IP family, but it does not allow
	// changing the primary IP family of the Service. Valid values are "IPv4"
	// and "IPv6".  This field only applies to Services of types ClusterIP,
	// NodePort, and LoadBalancer, and does apply to "headless" services.
	// This field will be wiped when updating a Service to type ExternalName.
	//
	// This field may hold a maximum of two entries (dual-stack families, in
	// either order).  These families must correspond to the values of the
	// clusterIPs field, if specified. Both clusterIPs and ipFamilies are
	// governed by the ipFamilyPolicy field.
	// +listType=atomic
	// +optional
	ipFamilies?: [...#IPFamily] @go(IPFamilies,[]IPFamily) @protobuf(19,bytes,opt,casttype=IPFamily)

	// IPFamilyPolicy represents the dual-stack-ness requested or required by
	// this Service. If there is no value provided, then this field will be set
	// to SingleStack. Services can be "SingleStack" (a single IP family),
	// "PreferDualStack" (two IP families on dual-stack configured clusters or
	// a single IP family on single-stack clusters), or "RequireDualStack"
	// (two IP families on dual-stack configured clusters, otherwise fail). The
	// ipFamilies and clusterIPs fields depend on the value of this field. This
	// field will be wiped when updating a service to type ExternalName.
	// +optional
	ipFamilyPolicy?: null | #IPFamilyPolicy @go(IPFamilyPolicy,*IPFamilyPolicy) @protobuf(17,bytes,opt,casttype=IPFamilyPolicy)

	// loadBalancerClass is the class of the load balancer implementation this Service belongs to.
	// If specified, the value of this field must be a label-style identifier, with an optional prefix,
	// e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
	// This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
	// balancer implementation is used, today this is typically done through the cloud provider integration,
	// but should apply for any default implementation. If set, it is assumed that a load balancer
	// implementation is watching for Services with a matching class. Any default load balancer
	// implementation (e.g. cloud providers) should ignore Services that set this field.
	// This field can only be set when creating or updating a Service to type 'LoadBalancer'.
	// Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
	// +optional
	loadBalancerClass?: null | string @go(LoadBalancerClass,*string) @protobuf(21,bytes,opt)

	// InternalTrafficPolicy describes how nodes distribute service traffic they
	// receive on the ClusterIP. If set to "Local", the proxy will assume that pods
	// only want to talk to endpoints of the service on the same node as the pod,
	// dropping the traffic if there are no local endpoints. The default value,
	// "Cluster", uses the standard behavior of routing to all endpoints evenly
	// (possibly modified by topology and other features).
	// +optional
	internalTrafficPolicy?: null | #ServiceInternalTrafficPolicy @go(InternalTrafficPolicy,*ServiceInternalTrafficPolicy) @protobuf(22,bytes,opt)

	// TrafficDistribution offers a way to express preferences for how traffic
	// is distributed to Service endpoints. Implementations can use this field
	// as a hint, but are not required to guarantee strict adherence. If the
	// field is not set, the implementation will apply its default routing
	// strategy. If set to "PreferClose", implementations should prioritize
	// endpoints that are in the same zone.
	// +featureGate=ServiceTrafficDistribution
	// +optional
	trafficDistribution?: null | string @go(TrafficDistribution,*string) @protobuf(23,bytes,opt)
}

// ServicePort contains information on service's port.
#ServicePort: {
	// The name of this port within the service. This must be a DNS_LABEL.
	// All ports within a ServiceSpec must have unique names. When considering
	// the endpoints for a Service, this must match the 'name' field in the
	// EndpointPort.
	// Optional if only one ServicePort is defined on this service.
	// +optional
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
	// Default is TCP.
	// +default="TCP"
	// +optional
	protocol?: #Protocol @go(Protocol) @protobuf(2,bytes,opt,casttype=Protocol)

	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	// +optional
	appProtocol?: null | string @go(AppProtocol,*string) @protobuf(6,bytes,opt)

	// The port that will be exposed by this service.
	port: int32 @go(Port) @protobuf(3,varint,opt)

	// Number or name of the port to access on the pods targeted by the service.
	// Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
	// If this is a string, it will be looked up as a named port in the
	// target Pod's container ports. If this is not specified, the value
	// of the 'port' field is used (an identity map).
	// This field is ignored for services with clusterIP=None, and should be
	// omitted or set equal to the 'port' field.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
	// +optional
	targetPort?: intstr.#IntOrString @go(TargetPort) @protobuf(4,bytes,opt)

	// The port on each node on which this service is exposed when type is
	// NodePort or LoadBalancer.  Usually assigned by the system. If a value is
	// specified, in-range, and not in use it will be used, otherwise the
	// operation will fail.  If not specified, a port will be allocated if this
	// Service requires one.  If this field is specified when creating a
	// Service which does not need it, creation will fail. This field will be
	// wiped when updating a Service to no longer need it (e.g. changing type
	// from NodePort to ClusterIP).
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
	// +optional
	nodePort?: int32 @go(NodePort) @protobuf(5,varint,opt)
}

// Service is a named abstraction of software service (for example, mysql) consisting of local port
// (for example 3306) that the proxy listens on, and the selector that determines which pods
// will answer requests sent through the proxy.
#Service: {
	slim_metav1.#TypeMeta

	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	metadata?: slim_metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Spec defines the behavior of a service.
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	spec?: #ServiceSpec @go(Spec) @protobuf(2,bytes,opt)

	// Most recently observed status of the service.
	// Populated by the system.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	status?: #ServiceStatus @go(Status) @protobuf(3,bytes,opt)
}

// ClusterIPNone - do not assign a cluster IP
// no proxying required and no environment variables should be created for pods
#ClusterIPNone: "None"

// ServiceList holds a list of services.
#ServiceList: {
	slim_metav1.#TypeMeta

	// Standard list metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	metadata?: slim_metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// List of services
	items: [...#Service] @go(Items,[]Service) @protobuf(2,bytes,rep)
}

// Endpoints is a collection of endpoints that implement the actual service. Example:
//
//	 Name: "mysvc",
//	 Subsets: [
//	   {
//	     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
//	     Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
//	   },
//	   {
//	     Addresses: [{"ip": "10.10.3.3"}],
//	     Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
//	   },
//	]
//
// Endpoints is a legacy API and does not contain information about all Service features.
// Use discoveryv1.EndpointSlice for complete information about Service endpoints.
//
// Deprecated: This API is deprecated in v1.33+. Use discoveryv1.EndpointSlice.
#Endpoints: {
	slim_metav1.#TypeMeta

	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	metadata?: slim_metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// The set of all endpoints is the union of all subsets. Addresses are placed into
	// subsets according to the IPs they share. A single address with multiple ports,
	// some of which are ready and some of which are not (because they come from
	// different containers) will result in the address being displayed in different
	// subsets for the different ports. No address will appear in both Addresses and
	// NotReadyAddresses in the same subset.
	// Sets of addresses and ports that comprise a service.
	// +optional
	// +listType=atomic
	subsets?: [...#EndpointSubset] @go(Subsets,[]EndpointSubset) @protobuf(2,bytes,rep)
}

// EndpointSubset is a group of addresses with a common set of ports. The
// expanded set of endpoints is the Cartesian product of Addresses x Ports.
// For example, given:
//
//	{
//	  Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
//	  Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
//	}
//
// The resulting set of endpoints can be viewed as:
//
//	a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
//	b: [ 10.10.1.1:309, 10.10.2.2:309 ]
//
// Deprecated: This API is deprecated in v1.33+.
#EndpointSubset: {
	// IP addresses which offer the related ports that are marked as ready. These endpoints
	// should be considered safe for load balancers and clients to utilize.
	// +optional
	// +listType=atomic
	addresses?: [...#EndpointAddress] @go(Addresses,[]EndpointAddress) @protobuf(1,bytes,rep)

	// Port numbers available on the related IP addresses.
	// +optional
	// +listType=atomic
	ports?: [...#EndpointPort] @go(Ports,[]EndpointPort) @protobuf(3,bytes,rep)
}

// EndpointAddress is a tuple that describes single IP address.
// Deprecated: This API is deprecated in v1.33+.
// +structType=atomic
#EndpointAddress: {
	// The IP of this endpoint.
	// May not be loopback (127.0.0.0/8 or ::1), link-local (169.254.0.0/16 or fe80::/10),
	// or link-local multicast (224.0.0.0/24 or ff02::/16).
	ip: string @go(IP) @protobuf(1,bytes,opt)

	// The Hostname of this endpoint
	// +optional
	hostname?: string @go(Hostname) @protobuf(3,bytes,opt)

	// Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
	// +optional
	nodeName?: null | string @go(NodeName,*string) @protobuf(4,bytes,opt)
}

// EndpointPort is a tuple that describes a single port.
// Deprecated: This API is deprecated in v1.33+.
// +structType=atomic
#EndpointPort: {
	// The name of this port.  This must match the 'name' field in the
	// corresponding ServicePort.
	// Must be a DNS_LABEL.
	// Optional only if one port is defined.
	// +optional
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// The port number of the endpoint.
	port: int32 @go(Port) @protobuf(2,varint,opt)

	// The IP protocol for this port.
	// Must be UDP, TCP, or SCTP.
	// Default is TCP.
	// +optional
	protocol?: #Protocol @go(Protocol) @protobuf(3,bytes,opt,casttype=Protocol)

	// The application protocol for this port.
	// This is used as a hint for implementations to offer richer behavior for protocols that they understand.
	// This field follows standard Kubernetes label syntax.
	// Valid values are either:
	//
	// * Un-prefixed protocol names - reserved for IANA standard service names (as per
	// RFC-6335 and https://www.iana.org/assignments/service-names).
	//
	// * Kubernetes-defined prefixed names:
	//   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
	//   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
	//   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
	//
	// * Other protocols should use implementation-defined prefixed names such as
	// mycompany.com/my-custom-protocol.
	// +optional
	appProtocol?: null | string @go(AppProtocol,*string) @protobuf(4,bytes,opt)
}

// EndpointsList is a list of endpoints.
// Deprecated: This API is deprecated in v1.33+.
#EndpointsList: {
	slim_metav1.#TypeMeta

	// Standard list metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	metadata?: slim_metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// List of endpoints.
	items: [...#Endpoints] @go(Items,[]Endpoints) @protobuf(2,bytes,rep)
}

// NodeSpec describes the attributes that a node is created with.
#NodeSpec: {
	// PodCIDR represents the pod IP range assigned to the node.
	// +optional
	podCIDR?: string @go(PodCIDR) @protobuf(1,bytes,opt)

	// podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this
	// field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for
	// each of IPv4 and IPv6.
	// +optional
	// +patchStrategy=merge
	// +listType=set
	podCIDRs?: [...string] @go(PodCIDRs,[]string) @protobuf(7,bytes,opt)

	// ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>
	// +optional
	providerID?: string @go(ProviderID) @protobuf(3,bytes,opt)

	// If specified, the node's taints.
	// +optional
	// +listType=atomic
	taints?: [...#Taint] @go(Taints,[]Taint) @protobuf(5,bytes,opt)
}

// NodeStatus is information about the current status of a node.
#NodeStatus: {
	// Conditions is an array of current observed node conditions.
	// More info: https://kubernetes.io/docs/reference/node/node-status/#condition
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=type
	conditions?: [...#NodeCondition] @go(Conditions,[]NodeCondition) @protobuf(4,bytes,rep)

	// List of addresses reachable to the node.
	// Queried from cloud provider, if available.
	// More info: https://kubernetes.io/docs/reference/node/node-status/#addresses
	// Note: This field is declared as mergeable, but the merge key is not sufficiently
	// unique, which can cause data corruption when it is merged. Callers should instead
	// use a full-replacement patch. See https://pr.k8s.io/79391 for an example.
	// Consumers should assume that addresses can change during the
	// lifetime of a Node. However, there are some exceptions where this may not
	// be possible, such as Pods that inherit a Node's address in its own status or
	// consumers of the downward API (status.hostIP).
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=type
	addresses?: [...#NodeAddress] @go(Addresses,[]NodeAddress) @protobuf(5,bytes,rep)
}

// +enum
#NodePhase: string // #enumNodePhase

#enumNodePhase:
	#NodePending |
	#NodeRunning |
	#NodeTerminated

// NodePending means the node has been created/added by the system, but not configured.
#NodePending: #NodePhase & "Pending"

// NodeRunning means the node has been configured and has Kubernetes components running.
#NodeRunning: #NodePhase & "Running"

// NodeTerminated means the node has been removed from the cluster.
#NodeTerminated: #NodePhase & "Terminated"

#NodeConditionType: string // #enumNodeConditionType

#enumNodeConditionType:
	#NodeReady |
	#NodeMemoryPressure |
	#NodeDiskPressure |
	#NodePIDPressure |
	#NodeNetworkUnavailable

// NodeReady means kubelet is healthy and ready to accept pods.
#NodeReady: #NodeConditionType & "Ready"

// NodeMemoryPressure means the kubelet is under pressure due to insufficient available memory.
#NodeMemoryPressure: #NodeConditionType & "MemoryPressure"

// NodeDiskPressure means the kubelet is under pressure due to insufficient available disk.
#NodeDiskPressure: #NodeConditionType & "DiskPressure"

// NodePIDPressure means the kubelet is under pressure due to insufficient available PID.
#NodePIDPressure: #NodeConditionType & "PIDPressure"

// NodeNetworkUnavailable means that network for the node is not correctly configured.
#NodeNetworkUnavailable: #NodeConditionType & "NetworkUnavailable"

// NodeCondition contains condition information for a node.
#NodeCondition: {
	// Type of node condition.
	type: #NodeConditionType @go(Type) @protobuf(1,bytes,opt,casttype=NodeConditionType)

	// Status of the condition, one of True, False, Unknown.
	status: #ConditionStatus @go(Status) @protobuf(2,bytes,opt,casttype=ConditionStatus)

	// (brief) reason for the condition's last transition.
	// +optional
	reason?: string @go(Reason) @protobuf(5,bytes,opt)
}

#NodeAddressType: string // #enumNodeAddressType

#enumNodeAddressType:
	#NodeHostName |
	#NodeInternalIP |
	#NodeExternalIP |
	#NodeInternalDNS |
	#NodeExternalDNS

// NodeHostName identifies a name of the node. Although every node can be assumed
// to have a NodeAddress of this type, its exact syntax and semantics are not
// defined, and are not consistent between different clusters.
#NodeHostName: #NodeAddressType & "Hostname"

// NodeInternalIP identifies an IP address which is assigned to one of the node's
// network interfaces. Every node should have at least one address of this type.
//
// An internal IP is normally expected to be reachable from every other node, but
// may not be visible to hosts outside the cluster. By default it is assumed that
// kube-apiserver can reach node internal IPs, though it is possible to configure
// clusters where this is not the case.
//
// NodeInternalIP is the default type of node IP, and does not necessarily imply
// that the IP is ONLY reachable internally. If a node has multiple internal IPs,
// no specific semantics are assigned to the additional IPs.
#NodeInternalIP: #NodeAddressType & "InternalIP"

// NodeExternalIP identifies an IP address which is, in some way, intended to be
// more usable from outside the cluster then an internal IP, though no specific
// semantics are defined. It may be a globally routable IP, though it is not
// required to be.
//
// External IPs may be assigned directly to an interface on the node, like a
// NodeInternalIP, or alternatively, packets sent to the external IP may be NAT'ed
// to an internal node IP rather than being delivered directly (making the IP less
// efficient for node-to-node traffic than a NodeInternalIP).
#NodeExternalIP: #NodeAddressType & "ExternalIP"

// NodeInternalDNS identifies a DNS name which resolves to an IP address which has
// the characteristics of a NodeInternalIP. The IP it resolves to may or may not
// be a listed NodeInternalIP address.
#NodeInternalDNS: #NodeAddressType & "InternalDNS"

// NodeExternalDNS identifies a DNS name which resolves to an IP address which has
// the characteristics of a NodeExternalIP. The IP it resolves to may or may not
// be a listed NodeExternalIP address.
#NodeExternalDNS: #NodeAddressType & "ExternalDNS"

// NodeAddress contains information for the node's address.
#NodeAddress: {
	// Node address type, one of Hostname, ExternalIP or InternalIP.
	type: #NodeAddressType @go(Type) @protobuf(1,bytes,opt,casttype=NodeAddressType)

	// The node address.
	address: string @go(Address) @protobuf(2,bytes,opt)
}

// Node is a worker node in Kubernetes.
// Each node will have a unique identifier in the cache (i.e. in etcd).
#Node: {
	slim_metav1.#TypeMeta

	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	metadata?: slim_metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Spec defines the behavior of a node.
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	spec?: #NodeSpec @go(Spec) @protobuf(2,bytes,opt)

	// Most recently observed status of the node.
	// Populated by the system.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	status?: #NodeStatus @go(Status) @protobuf(3,bytes,opt)
}

// NodeList is the whole list of all Nodes which have been registered with master.
#NodeList: {
	slim_metav1.#TypeMeta

	// Standard list metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	metadata?: slim_metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// List of nodes
	items: [...#Node] @go(Items,[]Node) @protobuf(2,bytes,rep)
}

// Namespace provides a scope for Names.
// Use of multiple namespaces is optional.
#Namespace: {
	slim_metav1.#TypeMeta

	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	metadata?: slim_metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)
}

// NamespaceList is a list of Namespaces.
#NamespaceList: {
	slim_metav1.#TypeMeta

	// Standard list metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	metadata?: slim_metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// Items is the list of Namespace objects in the list.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	items: [...#Namespace] @go(Items,[]Namespace) @protobuf(2,bytes,rep)
}

// TypedLocalObjectReference contains enough information to let you locate the
// typed referenced object inside the same namespace.
// ---
// New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.
//  1. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular
//     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".
//     Those cannot be well described when embedded.
//  2. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.
//  3. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity
//     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple
//     and the version of the actual struct is irrelevant.
//  4. We cannot easily change it.  Because this type is embedded in many locations, updates to this type
//     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control.
//
// Instead of using this type, create a locally provided and used type that is well-focused on your reference.
// For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
// +structType=atomic
#TypedLocalObjectReference: {
	// APIGroup is the group for the resource being referenced.
	// If APIGroup is not specified, the specified Kind must be in the core API group.
	// For any other third-party types, APIGroup is required.
	// +optional
	apiGroup?: null | string @go(APIGroup,*string) @protobuf(1,bytes,opt)

	// Kind is the type of resource being referenced
	kind: string @go(Kind) @protobuf(2,bytes,opt)

	// Name is the name of resource being referenced
	name: string @go(Name) @protobuf(3,bytes,opt)
}

// Bytes type is used to avoid issue with deepequal
// deepequal.go:607 Hit an unsupported type []byte for map[string][]byte, from map[string][]byte
#Bytes: bytes

// Secret holds secret data of a certain type. The total bytes of the values in
// the Data field must be less than MaxSecretSize bytes.
#Secret: {
	slim_metav1.#TypeMeta

	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	metadata?: slim_metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Immutable, if set to true, ensures that data stored in the Secret cannot
	// be updated (only object metadata can be modified).
	// If not set to true, the field can be modified at any time.
	// Defaulted to nil.
	// +optional
	immutable?: null | bool @go(Immutable,*bool) @protobuf(5,varint,opt)

	// Data contains the secret data. Each key must consist of alphanumeric
	// characters, '-', '_' or '.'. The serialized form of the secret data is a
	// base64 encoded string, representing the arbitrary (possibly non-string)
	// data value here. Described in https://tools.ietf.org/html/rfc4648#section-4
	// +optional
	data?: {[string]: #Bytes} @go(Data,map[string]Bytes) @protobuf(2,bytes,rep)

	// stringData allows specifying non-binary secret data in string form.
	// It is provided as a write-only input field for convenience.
	// All keys and values are merged into the data field on write, overwriting any existing values.
	// The stringData field is never output when reading from the API.
	// +k8s:conversion-gen=false
	// +optional
	stringData?: {[string]: string} @go(StringData,map[string]string) @protobuf(4,bytes,rep)

	// Used to facilitate programmatic handling of secret data.
	// More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
	// +optional
	type?: #SecretType @go(Type) @protobuf(3,bytes,opt,casttype=SecretType)
}

#MaxSecretSize: 1048576

#SecretType: string // #enumSecretType

#enumSecretType:
	#SecretTypeOpaque |
	#SecretTypeServiceAccountToken |
	#SecretTypeDockercfg |
	#SecretTypeDockerConfigJson |
	#SecretTypeBasicAuth |
	#SecretTypeSSHAuth |
	#SecretTypeTLS |
	#SecretTypeBootstrapToken

// SecretTypeOpaque is the default. Arbitrary user-defined data
#SecretTypeOpaque: #SecretType & "Opaque"

// SecretTypeServiceAccountToken contains a token that identifies a service account to the API
//
// Required fields:
// - Secret.Annotations["kubernetes.io/service-account.name"] - the name of the ServiceAccount the token identifies
// - Secret.Annotations["kubernetes.io/service-account.uid"] - the UID of the ServiceAccount the token identifies
// - Secret.Data["token"] - a token that identifies the service account to the API
#SecretTypeServiceAccountToken: #SecretType & "kubernetes.io/service-account-token"

// ServiceAccountNameKey is the key of the required annotation for SecretTypeServiceAccountToken secrets
#ServiceAccountNameKey: "kubernetes.io/service-account.name"

// ServiceAccountUIDKey is the key of the required annotation for SecretTypeServiceAccountToken secrets
#ServiceAccountUIDKey: "kubernetes.io/service-account.uid"

// ServiceAccountTokenKey is the key of the required data for SecretTypeServiceAccountToken secrets
#ServiceAccountTokenKey: "token"

// ServiceAccountKubeconfigKey is the key of the optional kubeconfig data for SecretTypeServiceAccountToken secrets
#ServiceAccountKubeconfigKey: "kubernetes.kubeconfig"

// ServiceAccountRootCAKey is the key of the optional root certificate authority for SecretTypeServiceAccountToken secrets
#ServiceAccountRootCAKey: "ca.crt"

// ServiceAccountNamespaceKey is the key of the optional namespace to use as the default for namespaced API calls
#ServiceAccountNamespaceKey: "namespace"

// SecretTypeDockercfg contains a dockercfg file that follows the same format rules as ~/.dockercfg
//
// Required fields:
// - Secret.Data[".dockercfg"] - a serialized ~/.dockercfg file
#SecretTypeDockercfg: #SecretType & "kubernetes.io/dockercfg"

// DockerConfigKey is the key of the required data for SecretTypeDockercfg secrets
#DockerConfigKey: ".dockercfg"

// SecretTypeDockerConfigJson contains a dockercfg file that follows the same format rules as ~/.docker/config.json
//
// Required fields:
// - Secret.Data[".dockerconfigjson"] - a serialized ~/.docker/config.json file
#SecretTypeDockerConfigJson: #SecretType & "kubernetes.io/dockerconfigjson"

// DockerConfigJsonKey is the key of the required data for SecretTypeDockerConfigJson secrets
#DockerConfigJsonKey: ".dockerconfigjson"

// SecretTypeBasicAuth contains data needed for basic authentication.
//
// Required at least one of fields:
// - Secret.Data["username"] - username used for authentication
// - Secret.Data["password"] - password or token needed for authentication
#SecretTypeBasicAuth: #SecretType & "kubernetes.io/basic-auth"

// BasicAuthUsernameKey is the key of the username for SecretTypeBasicAuth secrets
#BasicAuthUsernameKey: "username"

// BasicAuthPasswordKey is the key of the password or token for SecretTypeBasicAuth secrets
#BasicAuthPasswordKey: "password"

// SecretTypeSSHAuth contains data needed for SSH authetication.
//
// Required field:
// - Secret.Data["ssh-privatekey"] - private SSH key needed for authentication
#SecretTypeSSHAuth: #SecretType & "kubernetes.io/ssh-auth"

// SSHAuthPrivateKey is the key of the required SSH private key for SecretTypeSSHAuth secrets
#SSHAuthPrivateKey: "ssh-privatekey"

// SecretTypeTLS contains information about a TLS client or server secret. It
// is primarily used with TLS termination of the Ingress resource, but may be
// used in other types.
//
// Required fields:
// - Secret.Data["tls.key"] - TLS private key.
//   Secret.Data["tls.crt"] - TLS certificate.
// TODO: Consider supporting different formats, specifying CA/destinationCA.
#SecretTypeTLS: #SecretType & "kubernetes.io/tls"

// TLSCertKey is the key for tls certificates in a TLS secret.
#TLSCertKey: "tls.crt"

// TLSPrivateKeyKey is the key for the private key field in a TLS secret.
#TLSPrivateKeyKey: "tls.key"

// SecretTypeBootstrapToken is used during the automated bootstrap process (first
// implemented by kubeadm). It stores tokens that are used to sign well known
// ConfigMaps. They are used for authn.
#SecretTypeBootstrapToken: #SecretType & "bootstrap.kubernetes.io/token"

// SecretList is a list of Secret.
#SecretList: {
	slim_metav1.#TypeMeta

	// Standard list metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	metadata?: slim_metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)

	// Items is a list of secret objects.
	// More info: https://kubernetes.io/docs/concepts/configuration/secret
	items: [...#Secret] @go(Items,[]Secret) @protobuf(2,bytes,rep)
}

// PortStatus represents the error condition of a service port
#PortStatus: {
	// Port is the port number of the service port of which status is recorded here
	port: int32 @go(Port) @protobuf(1,varint,opt)

	// Protocol is the protocol of the service port of which status is recorded here
	// The supported values are: "TCP", "UDP", "SCTP"
	protocol: #Protocol @go(Protocol) @protobuf(2,bytes,opt,casttype=Protocol)

	// Error is to record the problem with the service port
	// The format of the error shall comply with the following rules:
	// - built-in error values shall be specified in this file and those shall use
	//   CamelCase names
	// - cloud provider specific error values must have names that comply with the
	//   format foo.example.com/CamelCase.
	// ---
	// The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
	// +optional
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
	// +kubebuilder:validation:MaxLength=316
	error?: null | string @go(Error,*string) @protobuf(3,bytes,opt)
}

// LoadBalancerIPMode represents the mode of the LoadBalancer ingress IP
#LoadBalancerIPMode: string // #enumLoadBalancerIPMode

#enumLoadBalancerIPMode:
	#LoadBalancerIPModeVIP |
	#LoadBalancerIPModeProxy

// LoadBalancerIPModeVIP indicates that traffic is delivered to the node with
// the destination set to the load-balancer's IP and port.
#LoadBalancerIPModeVIP: #LoadBalancerIPMode & "VIP"

// LoadBalancerIPModeProxy indicates that traffic is delivered to the node or pod with
// the destination set to the node's IP and port or the pod's IP and port.
#LoadBalancerIPModeProxy: #LoadBalancerIPMode & "Proxy"
