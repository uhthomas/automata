// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/cilium/cilium/pkg/policy/api

package api

import "github.com/cilium/proxy/pkg/policy/api/kafka"

// L4Proto is a layer 4 protocol name
#L4Proto: string // #enumL4Proto

#enumL4Proto:
	#ProtoTCP |
	#ProtoUDP |
	#ProtoSCTP |
	#ProtoICMP |
	#ProtoICMPv6 |
	#ProtoAny

#ProtoTCP:        #L4Proto & "TCP"
#ProtoUDP:        #L4Proto & "UDP"
#ProtoSCTP:       #L4Proto & "SCTP"
#ProtoICMP:       #L4Proto & "ICMP"
#ProtoICMPv6:     #L4Proto & "ICMPV6"
#ProtoAny:        #L4Proto & "ANY"
#PortProtocolAny: "0/ANY"

// PortProtocol specifies an L4 port with an optional transport protocol
#PortProtocol: {
	// Port can be an L4 port number, or a name in the form of "http"
	// or "http-8080".
	//
	// +kubebuilder:validation:Pattern=`^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[0-9]{1,4})|([a-zA-Z0-9]-?)*[a-zA-Z](-?[a-zA-Z0-9])*$`
	port: string @go(Port)

	// EndPort can only be an L4 port number.
	//
	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=65535
	// +kubebuilder:validation:Optional
	endPort?: int32 @go(EndPort)

	// Protocol is the L4 protocol. If omitted or empty, any protocol
	// matches. Accepted values: "TCP", "UDP", "SCTP", "ANY"
	//
	// Matching on ICMP is not supported.
	//
	// Named port specified for a container may narrow this down, but may not
	// contradict this.
	//
	// +kubebuilder:validation:Enum=TCP;UDP;SCTP;ANY
	// +kubebuilder:validation:Optional
	protocol?: #L4Proto @go(Protocol)
}

// Secret is a reference to a secret, backed by k8s or local file system.
#Secret: {
	// Namespace is the namespace in which the secret exists. Context of use
	// determines the default value if left out (e.g., "default").
	//
	// +kubebuilder:validation:Optional
	namespace?: string @go(Namespace)

	// Name is the name of the secret.
	//
	// +kubebuilder:validation:Required
	name: string @go(Name)
}

// TLSContext provides TLS configuration via reference to either k8s secrets
// or via filepath. If both are set, directory is given priority over
// k8sSecrets.
#TLSContext: {
	// Secret is the secret that contains the certificates and private key for
	// the TLS context.
	// By default, Cilium will search in this secret for the following items:
	//  - 'ca.crt'  - Which represents the trusted CA to verify remote source.
	//  - 'tls.crt' - Which represents the public key certificate.
	//  - 'tls.key' - Which represents the private key matching the public key
	//                certificate.
	//
	// +kubebuilder:validation:Required
	secret?: null | #Secret @go(Secret,*Secret)

	// TrustedCA is the file name or k8s secret item name for the trusted CA.
	// If omitted, 'ca.crt' is assumed, if it exists. If given, the item must
	// exist.
	//
	// +kubebuilder:validation:Optional
	trustedCA?: string @go(TrustedCA)

	// Certificate is the file name or k8s secret item name for the certificate
	// chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the
	// item must exist.
	//
	// +kubebuilder:validation:Optional
	certificate?: string @go(Certificate)

	// PrivateKey is the file name or k8s secret item name for the private key
	// matching the certificate chain. If omitted, 'tls.key' is assumed, if it
	// exists. If given, the item must exist.
	//
	// +kubebuilder:validation:Optional
	privateKey?: string @go(PrivateKey)
}

// EnvoyConfig defines a reference to a CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig
#EnvoyConfig: {
	// Kind is the resource type being referred to. Defaults to CiliumEnvoyConfig or
	// CiliumClusterwideEnvoyConfig for CiliumNetworkPolicy and CiliumClusterwideNetworkPolicy,
	// respectively. The only case this is currently explicitly needed is when referring to a
	// CiliumClusterwideEnvoyConfig from CiliumNetworkPolicy, as using a namespaced listener
	// from a cluster scoped policy is not allowed.
	//
	// +kubebuilder:validation:Enum=CiliumEnvoyConfig;CiliumClusterwideEnvoyConfig
	// +kubebuilder:validation:Optional
	kind: string @go(Kind)

	// Name is the resource name of the CiliumEnvoyConfig or CiliumClusterwideEnvoyConfig where
	// the listener is defined in.
	//
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:Required
	name: string @go(Name)
}

// Listener defines a reference to an Envoy listener specified in a CEC or CCEC resource.
#Listener: {
	// EnvoyConfig is a reference to the CEC or CCEC resource in which
	// the listener is defined.
	//
	// +kubebuilder:validation:Required
	envoyConfig?: null | #EnvoyConfig @go(EnvoyConfig,*EnvoyConfig)

	// Name is the name of the listener.
	//
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:Required
	name: string @go(Name)

	// Priority for this Listener that is used when multiple rules would apply different
	// listeners to a policy map entry. Behavior of this is implementation dependent.
	//
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Optional
	priority: uint8 @go(Priority)
}

// ServerName allows using prefix only wildcards to match DNS names.
//
// - "*" matches 0 or more DNS valid characters, and may only occur at the
// beginning of the pattern. As a special case a "*" as the leftmost character,
// without a following "." matches all subdomains as well as the name to the right.
//
// Examples:
//   - `*.cilium.io` matches exactly one subdomain of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not.
//   - `**.cilium.io` matches more than one subdomain of cilium, e.g. sub1.sub2.cilium.io and sub.cilium.io match, cilium.io do not.
//
// +kubebuilder:validation:MaxLength=255
// +kubebuilder:validation:Pattern=`^(\*?\*\.)?([-a-zA-Z0-9_]+\.?)+$`
// +kubebuilder:validation:OneOf
#ServerName: string

// PortRule is a list of ports/protocol combinations with optional Layer 7
// rules which must be met.
#PortRule: {
	// Ports is a list of L4 port/protocol
	//
	// +kubebuilder:validation:Optional
	// +kubebuilder:validation:MaxItems=40
	ports?: [...#PortProtocol] @go(Ports,[]PortProtocol)

	// TerminatingTLS is the TLS context for the connection terminated by
	// the L7 proxy.  For egress policy this specifies the server-side TLS
	// parameters to be applied on the connections originated from the local
	// endpoint and terminated by the L7 proxy. For ingress policy this specifies
	// the server-side TLS parameters to be applied on the connections
	// originated from a remote source and terminated by the L7 proxy.
	//
	// +kubebuilder:validation:Optional
	terminatingTLS?: null | #TLSContext @go(TerminatingTLS,*TLSContext)

	// OriginatingTLS is the TLS context for the connections originated by
	// the L7 proxy.  For egress policy this specifies the client-side TLS
	// parameters for the upstream connection originating from the L7 proxy
	// to the remote destination. For ingress policy this specifies the
	// client-side TLS parameters for the connection from the L7 proxy to
	// the local endpoint.
	//
	// +kubebuilder:validation:Optional
	originatingTLS?: null | #TLSContext @go(OriginatingTLS,*TLSContext)

	// ServerNames is a list of allowed TLS SNI values. If not empty, then
	// TLS must be present and one of the provided SNIs must be indicated in the
	// TLS handshake.
	//
	// +kubebuilder:validation:Optional
	// +kubebuilder:validation:MinItems=1
	// +listType=set
	serverNames?: [...#ServerName] @go(ServerNames,[]ServerName)

	// listener specifies the name of a custom Envoy listener to which this traffic should be
	// redirected to.
	//
	// +kubebuilder:validation:Optional
	listener?: null | #Listener @go(Listener,*Listener)

	// Rules is a list of additional port level rules which must be met in
	// order for the PortRule to allow the traffic. If omitted or empty,
	// no layer 7 rules are enforced.
	//
	// +kubebuilder:validation:Optional
	rules?: null | #L7Rules @go(Rules,*L7Rules)
}

// PortDenyRule is a list of ports/protocol that should be used for deny
// policies. This structure lacks the L7Rules since it's not supported in deny
// policies.
#PortDenyRule: {
	// Ports is a list of L4 port/protocol
	//
	// +kubebuilder:validation:Optional
	ports?: [...#PortProtocol] @go(Ports,[]PortProtocol)
}

// L7Rules is a union of port level rule types. Mixing of different port
// level rule types is disallowed, so exactly one of the following must be set.
// If none are specified, then no additional port level rules are applied.
#L7Rules: {
	// HTTP specific rules.
	//
	// +kubebuilder:validation:Optional
	// +kubebuilder:validation:OneOf
	http?: [...#PortRuleHTTP] @go(HTTP,[]PortRuleHTTP)

	// Kafka-specific rules.
	//
	// +kubebuilder:validation:Optional
	// +kubebuilder:validation:OneOf
	"kafka"?: [...kafka.#PortRule] @go(Kafka,[]kafka.PortRule)

	// DNS-specific rules.
	//
	// +kubebuilder:validation:Optional
	// +kubebuilder:validation:OneOf
	dns?: [...#PortRuleDNS] @go(DNS,[]PortRuleDNS)

	// Name of the L7 protocol for which the Key-value pair rules apply.
	//
	// +kubebuilder:validation:Optional
	// +kubebuilder:validation:OneOf
	l7proto?: string @go(L7Proto)

	// Key-value pair rules.
	//
	// +kubebuilder:validation:Optional
	l7?: [...#PortRuleL7] @go(L7,[]PortRuleL7)
}

// PortRules is a slice of PortRule.
#PortRules: [...#PortRule]

// PortDenyRules is a slice of PortDenyRule.
#PortDenyRules: [...#PortDenyRule]

// Ports is an interface that should be used by all implementations of the
// PortProtocols.
#Ports: _

// PortsIterator is an interface that should be implemented by structures that
// can iterate over a list of Ports interfaces.
#PortsIterator: _
