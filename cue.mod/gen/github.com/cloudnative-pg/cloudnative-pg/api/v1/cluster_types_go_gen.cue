// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/cloudnative-pg/cloudnative-pg/api/v1

package v1

import (
	corev1 "k8s.io/api/core/v1"
	"github.com/cloudnative-pg/machinery/pkg/api"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	api_1 "github.com/cloudnative-pg/barman-cloud/pkg/api"
	monitoringv1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
)

// PrimaryPodDisruptionBudgetSuffix is the suffix appended to the cluster name
// to get the name of the PDB used for the cluster primary
#PrimaryPodDisruptionBudgetSuffix: "-primary"

// ReplicationSecretSuffix is the suffix appended to the cluster name to
// get the name of the generated replication secret for PostgreSQL
#ReplicationSecretSuffix: "-replication"

// SuperUserSecretSuffix is the suffix appended to the cluster name to
// get the name of the PostgreSQL superuser secret
#SuperUserSecretSuffix: "-superuser"

// ApplicationUserSecretSuffix is the suffix appended to the cluster name to
// get the name of the application user secret
#ApplicationUserSecretSuffix: "-app"

// DefaultServerCaSecretSuffix is the suffix appended to the secret containing
// the generated CA for the cluster
#DefaultServerCaSecretSuffix: "-ca"

// ClientCaSecretSuffix is the suffix appended to the secret containing
// the generated CA for the client certificates
#ClientCaSecretSuffix: "-ca"

// ServerSecretSuffix is the suffix appended to the secret containing
// the generated server secret for PostgreSQL
#ServerSecretSuffix: "-server"

// ServiceAnySuffix is the suffix appended to the cluster name to get the
// service name for every node (including non-ready ones)
#ServiceAnySuffix: "-any"

// ServiceReadSuffix is the suffix appended to the cluster name to get the
// service name for every ready node that you can use to read data (including the primary)
#ServiceReadSuffix: "-r"

// ServiceReadOnlySuffix is the suffix appended to the cluster name to get the
// service name for every ready node that you can use to read data (excluding the primary)
#ServiceReadOnlySuffix: "-ro"

// ServiceReadWriteSuffix is the suffix appended to the cluster name to get
// the se service name for every node that you can use to read and write
// data
#ServiceReadWriteSuffix: "-rw"

// ClusterSecretSuffix is the suffix appended to the cluster name to
// get the name of the pull secret
#ClusterSecretSuffix: "-pull-secret"

// WalArchiveVolumeSuffix is the suffix appended to the instance name to
// get the name of the PVC dedicated to WAL files.
#WalArchiveVolumeSuffix: "-wal"

// TablespaceVolumeInfix is the infix added between the instance name
// and tablespace name to get the name of PVC for a certain tablespace
#TablespaceVolumeInfix: "-tbs-"

// StreamingReplicationUser is the name of the user we'll use for
// streaming replication purposes
#StreamingReplicationUser: "streaming_replica"

// DefaultPostgresUID is the default UID which is used by PostgreSQL
#DefaultPostgresUID: 26

// DefaultPostgresGID is the default GID which is used by PostgreSQL
#DefaultPostgresGID: 26

// PodAntiAffinityTypeRequired is the label for required anti-affinity type
#PodAntiAffinityTypeRequired: "required"

// PodAntiAffinityTypePreferred is the label for preferred anti-affinity type
#PodAntiAffinityTypePreferred: "preferred"

// DefaultPgBouncerPoolerSecretSuffix is the suffix for the default pgbouncer Pooler secret
#DefaultPgBouncerPoolerSecretSuffix: "-pooler"

// PendingFailoverMarker is used as target primary to signal that a failover is required
#PendingFailoverMarker: "pending"

// PGBouncerPoolerUserName is the name of the role to be used for
#PGBouncerPoolerUserName: "cnpg_pooler_pgbouncer"

// MissingWALDiskSpaceExitCode is the exit code the instance manager
// will use to signal that there's no more WAL disk space
#MissingWALDiskSpaceExitCode: 4

// SnapshotOwnerReference defines the reference type for the owner of the snapshot.
// This specifies which owner the processed resources should relate to.
#SnapshotOwnerReference: string // #enumSnapshotOwnerReference

#enumSnapshotOwnerReference:
	#ShapshotOwnerReferenceNone |
	#SnapshotOwnerReferenceBackup |
	#SnapshotOwnerReferenceCluster

// ShapshotOwnerReferenceNone indicates that the snapshot does not have any owner reference.
#ShapshotOwnerReferenceNone: #SnapshotOwnerReference & "none"

// SnapshotOwnerReferenceBackup indicates that the snapshot is owned by the backup resource.
#SnapshotOwnerReferenceBackup: #SnapshotOwnerReference & "backup"

// SnapshotOwnerReferenceCluster indicates that the snapshot is owned by the cluster resource.
#SnapshotOwnerReferenceCluster: #SnapshotOwnerReference & "cluster"

// VolumeSnapshotConfiguration represents the configuration for the execution of snapshot backups.
#VolumeSnapshotConfiguration: {
	// Labels are key-value pairs that will be added to .metadata.labels snapshot resources.
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string)

	// Annotations key-value pairs that will be added to .metadata.annotations snapshot resources.
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string)

	// ClassName specifies the Snapshot Class to be used for PG_DATA PersistentVolumeClaim.
	// It is the default class for the other types if no specific class is present
	// +optional
	className?: string @go(ClassName)

	// WalClassName specifies the Snapshot Class to be used for the PG_WAL PersistentVolumeClaim.
	// +optional
	walClassName?: string @go(WalClassName)

	// TablespaceClassName specifies the Snapshot Class to be used for the tablespaces.
	// defaults to the PGDATA Snapshot Class, if set
	// +optional
	tablespaceClassName?: {[string]: string} @go(TablespaceClassName,map[string]string)

	// SnapshotOwnerReference indicates the type of owner reference the snapshot should have
	// +optional
	// +kubebuilder:validation:Enum:=none;cluster;backup
	// +kubebuilder:default:=none
	snapshotOwnerReference?: #SnapshotOwnerReference @go(SnapshotOwnerReference)

	// Whether the default type of backup with volume snapshots is
	// online/hot (`true`, default) or offline/cold (`false`)
	// +optional
	// +kubebuilder:default:=true
	online?: null | bool @go(Online,*bool)

	// Configuration parameters to control the online/hot backup with volume snapshots
	// +kubebuilder:default:={waitForArchive:true,immediateCheckpoint:false}
	// +optional
	onlineConfiguration?: #OnlineConfiguration @go(OnlineConfiguration)
}

// OnlineConfiguration contains the configuration parameters for the online volume snapshot
#OnlineConfiguration: {
	// If false, the function will return immediately after the backup is completed,
	// without waiting for WAL to be archived.
	// This behavior is only useful with backup software that independently monitors WAL archiving.
	// Otherwise, WAL required to make the backup consistent might be missing and make the backup useless.
	// By default, or when this parameter is true, pg_backup_stop will wait for WAL to be archived when archiving is
	// enabled.
	// On a standby, this means that it will wait only when archive_mode = always.
	// If write activity on the primary is low, it may be useful to run pg_switch_wal on the primary in order to trigger
	// an immediate segment switch.
	// +kubebuilder:default:=true
	// +optional
	waitForArchive?: null | bool @go(WaitForArchive,*bool)

	// Control whether the I/O workload for the backup initial checkpoint will
	// be limited, according to the `checkpoint_completion_target` setting on
	// the PostgreSQL server. If set to true, an immediate checkpoint will be
	// used, meaning PostgreSQL will complete the checkpoint as soon as
	// possible. `false` by default.
	// +optional
	immediateCheckpoint?: null | bool @go(ImmediateCheckpoint,*bool)
}

// ImageCatalogRef defines the reference to a major version in an ImageCatalog
#ImageCatalogRef: {
	corev1.#TypedLocalObjectReference

	// +kubebuilder:validation:XValidation:rule="self == oldSelf",message="Major is immutable"
	// The major version of PostgreSQL we want to use from the ImageCatalog
	major: int @go(Major)
}

// ClusterSpec defines the desired state of Cluster
#ClusterSpec: {
	// Description of this PostgreSQL cluster
	// +optional
	description?: string @go(Description)

	// Metadata that will be inherited by all objects related to the Cluster
	// +optional
	inheritedMetadata?: null | #EmbeddedObjectMetadata @go(InheritedMetadata,*EmbeddedObjectMetadata)

	// Name of the container image, supporting both tags (`<image>:<tag>`)
	// and digests for deterministic and repeatable deployments
	// (`<image>:<tag>@sha256:<digestValue>`)
	// +optional
	imageName?: string @go(ImageName)

	// Defines the major PostgreSQL version we want to use within an ImageCatalog
	// +optional
	imageCatalogRef?: null | #ImageCatalogRef @go(ImageCatalogRef,*ImageCatalogRef)

	// Image pull policy.
	// One of `Always`, `Never` or `IfNotPresent`.
	// If not defined, it defaults to `IfNotPresent`.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
	// +optional
	imagePullPolicy?: corev1.#PullPolicy @go(ImagePullPolicy)

	// If specified, the pod will be dispatched by specified Kubernetes
	// scheduler. If not specified, the pod will be dispatched by the default
	// scheduler. More info:
	// https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/
	// +optional
	schedulerName?: string @go(SchedulerName)

	// The UID of the `postgres` user inside the image, defaults to `26`
	// +kubebuilder:default:=26
	// +optional
	postgresUID?: int64 @go(PostgresUID)

	// The GID of the `postgres` user inside the image, defaults to `26`
	// +kubebuilder:default:=26
	// +optional
	postgresGID?: int64 @go(PostgresGID)

	// Number of instances required in the cluster
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:default:=1
	instances: int @go(Instances)

	// Minimum number of instances required in synchronous replication with the
	// primary. Undefined or 0 allow writes to complete when no standby is
	// available.
	// +kubebuilder:default:=0
	// +kubebuilder:validation:Minimum=0
	// +optional
	minSyncReplicas?: int @go(MinSyncReplicas)

	// The target value for the synchronous replication quorum, that can be
	// decreased if the number of ready standbys is lower than this.
	// Undefined or 0 disable synchronous replication.
	// +kubebuilder:default:=0
	// +kubebuilder:validation:Minimum=0
	// +optional
	maxSyncReplicas?: int @go(MaxSyncReplicas)

	// Configuration of the PostgreSQL server
	// +optional
	postgresql?: #PostgresConfiguration @go(PostgresConfiguration)

	// Replication slots management configuration
	// +kubebuilder:default:={"highAvailability":{"enabled":true}}
	// +optional
	replicationSlots?: null | #ReplicationSlotsConfiguration @go(ReplicationSlots,*ReplicationSlotsConfiguration)

	// Instructions to bootstrap this cluster
	// +optional
	bootstrap?: null | #BootstrapConfiguration @go(Bootstrap,*BootstrapConfiguration)

	// Replica cluster configuration
	// +optional
	replica?: null | #ReplicaClusterConfiguration @go(ReplicaCluster,*ReplicaClusterConfiguration)

	// The secret containing the superuser password. If not defined a new
	// secret will be created with a randomly generated password
	// +optional
	superuserSecret?: null | api.#LocalObjectReference @go(SuperuserSecret,*github.com/cloudnative-pg/machinery/pkg/api.LocalObjectReference)

	// When this option is enabled, the operator will use the `SuperuserSecret`
	// to update the `postgres` user password (if the secret is
	// not present, the operator will automatically create one). When this
	// option is disabled, the operator will ignore the `SuperuserSecret` content, delete
	// it when automatically created, and then blank the password of the `postgres`
	// user by setting it to `NULL`. Disabled by default.
	// +kubebuilder:default:=false
	// +optional
	enableSuperuserAccess?: null | bool @go(EnableSuperuserAccess,*bool)

	// The configuration for the CA and related certificates
	// +optional
	certificates?: null | #CertificatesConfiguration @go(Certificates,*CertificatesConfiguration)

	// The list of pull secrets to be used to pull the images
	// +optional
	imagePullSecrets?: [...api.#LocalObjectReference] @go(ImagePullSecrets,[]github.com/cloudnative-pg/machinery/pkg/api.LocalObjectReference)

	// Configuration of the storage of the instances
	// +optional
	storage?: #StorageConfiguration @go(StorageConfiguration)

	// Configure the generation of the service account
	// +optional
	serviceAccountTemplate?: null | #ServiceAccountTemplate @go(ServiceAccountTemplate,*ServiceAccountTemplate)

	// Configuration of the storage for PostgreSQL WAL (Write-Ahead Log)
	// +optional
	walStorage?: null | #StorageConfiguration @go(WalStorage,*StorageConfiguration)

	// EphemeralVolumeSource allows the user to configure the source of ephemeral volumes.
	// +optional
	ephemeralVolumeSource?: null | corev1.#EphemeralVolumeSource @go(EphemeralVolumeSource,*corev1.EphemeralVolumeSource)

	// The time in seconds that is allowed for a PostgreSQL instance to
	// successfully start up (default 3600).
	// The startup probe failure threshold is derived from this value using the formula:
	// ceiling(startDelay / 10).
	// +kubebuilder:default:=3600
	// +optional
	startDelay?: int32 @go(MaxStartDelay)

	// The time in seconds that is allowed for a PostgreSQL instance to
	// gracefully shutdown (default 1800)
	// +kubebuilder:default:=1800
	// +optional
	stopDelay?: int32 @go(MaxStopDelay)

	// The time in seconds that controls the window of time reserved for the smart shutdown of Postgres to complete.
	// Make sure you reserve enough time for the operator to request a fast shutdown of Postgres
	// (that is: `stopDelay` - `smartShutdownTimeout`).
	// +kubebuilder:default:=180
	// +optional
	smartShutdownTimeout?: null | int32 @go(SmartShutdownTimeout,*int32)

	// The time in seconds that is allowed for a primary PostgreSQL instance
	// to gracefully shutdown during a switchover.
	// Default value is 3600 seconds (1 hour).
	// +kubebuilder:default:=3600
	// +optional
	switchoverDelay?: int32 @go(MaxSwitchoverDelay)

	// The amount of time (in seconds) to wait before triggering a failover
	// after the primary PostgreSQL instance in the cluster was detected
	// to be unhealthy
	// +kubebuilder:default:=0
	// +optional
	failoverDelay?: int32 @go(FailoverDelay)

	// LivenessProbeTimeout is the time (in seconds) that is allowed for a PostgreSQL instance
	// to successfully respond to the liveness probe (default 30).
	// The Liveness probe failure threshold is derived from this value using the formula:
	// ceiling(livenessProbe / 10).
	// +optional
	livenessProbeTimeout?: null | int32 @go(LivenessProbeTimeout,*int32)

	// Affinity/Anti-affinity rules for Pods
	// +optional
	affinity?: #AffinityConfiguration @go(Affinity)

	// TopologySpreadConstraints specifies how to spread matching pods among the given topology.
	// More info:
	// https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/
	// +optional
	topologySpreadConstraints?: [...corev1.#TopologySpreadConstraint] @go(TopologySpreadConstraints,[]corev1.TopologySpreadConstraint)

	// Resources requirements of every generated Pod. Please refer to
	// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// for more information.
	// +optional
	resources?: corev1.#ResourceRequirements @go(Resources)

	// EphemeralVolumesSizeLimit allows the user to set the limits for the ephemeral
	// volumes
	// +optional
	ephemeralVolumesSizeLimit?: null | #EphemeralVolumesSizeLimitConfiguration @go(EphemeralVolumesSizeLimit,*EphemeralVolumesSizeLimitConfiguration)

	// Name of the priority class which will be used in every generated Pod, if the PriorityClass
	// specified does not exist, the pod will not be able to schedule.  Please refer to
	// https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass
	// for more information
	// +optional
	priorityClassName?: string @go(PriorityClassName)

	// Deployment strategy to follow to upgrade the primary server during a rolling
	// update procedure, after all replicas have been successfully updated:
	// it can be automated (`unsupervised` - default) or manual (`supervised`)
	// +kubebuilder:default:=unsupervised
	// +kubebuilder:validation:Enum:=unsupervised;supervised
	// +optional
	primaryUpdateStrategy?: #PrimaryUpdateStrategy @go(PrimaryUpdateStrategy)

	// Method to follow to upgrade the primary server during a rolling
	// update procedure, after all replicas have been successfully updated:
	// it can be with a switchover (`switchover`) or in-place (`restart` - default)
	// +kubebuilder:default:=restart
	// +kubebuilder:validation:Enum:=switchover;restart
	// +optional
	primaryUpdateMethod?: #PrimaryUpdateMethod @go(PrimaryUpdateMethod)

	// The configuration to be used for backups
	// +optional
	backup?: null | #BackupConfiguration @go(Backup,*BackupConfiguration)

	// Define a maintenance window for the Kubernetes nodes
	// +optional
	nodeMaintenanceWindow?: null | #NodeMaintenanceWindow @go(NodeMaintenanceWindow,*NodeMaintenanceWindow)

	// The configuration of the monitoring infrastructure of this cluster
	// +optional
	monitoring?: null | #MonitoringConfiguration @go(Monitoring,*MonitoringConfiguration)

	// The list of external clusters which are used in the configuration
	// +optional
	externalClusters?: [...#ExternalCluster] @go(ExternalClusters,[]ExternalCluster)

	// The instances' log level, one of the following values: error, warning, info (default), debug, trace
	// +kubebuilder:default:=info
	// +kubebuilder:validation:Enum:=error;warning;info;debug;trace
	// +optional
	logLevel?: string @go(LogLevel)

	// Template to be used to define projected volumes, projected volumes will be mounted
	// under `/projected` base folder
	// +optional
	projectedVolumeTemplate?: null | corev1.#ProjectedVolumeSource @go(ProjectedVolumeTemplate,*corev1.ProjectedVolumeSource)

	// Env follows the Env format to pass environment variables
	// to the pods created in the cluster
	// +optional
	// +patchMergeKey=name
	// +patchStrategy=merge
	env?: [...corev1.#EnvVar] @go(Env,[]corev1.EnvVar)

	// EnvFrom follows the EnvFrom format to pass environment variables
	// sources to the pods to be used by Env
	// +optional
	envFrom?: [...corev1.#EnvFromSource] @go(EnvFrom,[]corev1.EnvFromSource)

	// The configuration that is used by the portions of PostgreSQL that are managed by the instance manager
	// +optional
	managed?: null | #ManagedConfiguration @go(Managed,*ManagedConfiguration)

	// The SeccompProfile applied to every Pod and Container.
	// Defaults to: `RuntimeDefault`
	// +optional
	seccompProfile?: null | corev1.#SeccompProfile @go(SeccompProfile,*corev1.SeccompProfile)

	// The tablespaces configuration
	// +optional
	tablespaces?: [...#TablespaceConfiguration] @go(Tablespaces,[]TablespaceConfiguration)

	// Manage the `PodDisruptionBudget` resources within the cluster. When
	// configured as `true` (default setting), the pod disruption budgets
	// will safeguard the primary node from being terminated. Conversely,
	// setting it to `false` will result in the absence of any
	// `PodDisruptionBudget` resource, permitting the shutdown of all nodes
	// hosting the PostgreSQL cluster. This latter configuration is
	// advisable for any PostgreSQL cluster employed for
	// development/staging purposes.
	// +kubebuilder:default:=true
	// +optional
	enablePDB?: null | bool @go(EnablePDB,*bool)

	// The plugins configuration, containing
	// any plugin to be loaded with the corresponding configuration
	// +optional
	plugins?: [...#PluginConfiguration] @go(Plugins,[]PluginConfiguration)

	// The configuration of the probes to be injected
	// in the PostgreSQL Pods.
	// +optional
	probes?: null | #ProbesConfiguration @go(Probes,*ProbesConfiguration)
}

// ProbesConfiguration represent the configuration for the probes
// to be injected in the PostgreSQL Pods
#ProbesConfiguration: {
	// The startup probe configuration
	startup?: null | #Probe @go(Startup,*Probe)

	// The liveness probe configuration
	liveness?: null | #Probe @go(Liveness,*Probe)

	// The readiness probe configuration
	readiness?: null | #Probe @go(Readiness,*Probe)
}

// Probe describes a health check to be performed against a container to determine whether it is
// alive or ready to receive traffic.
#Probe: {
	// Number of seconds after the container has started before liveness probes are initiated.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
	// +optional
	initialDelaySeconds?: int32 @go(InitialDelaySeconds)

	// Number of seconds after which the probe times out.
	// Defaults to 1 second. Minimum value is 1.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
	// +optional
	timeoutSeconds?: int32 @go(TimeoutSeconds)

	// How often (in seconds) to perform the probe.
	// Default to 10 seconds. Minimum value is 1.
	// +optional
	periodSeconds?: int32 @go(PeriodSeconds)

	// Minimum consecutive successes for the probe to be considered successful after having failed.
	// Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
	// +optional
	successThreshold?: int32 @go(SuccessThreshold)

	// Minimum consecutive failures for the probe to be considered failed after having succeeded.
	// Defaults to 3. Minimum value is 1.
	// +optional
	failureThreshold?: int32 @go(FailureThreshold)

	// Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
	// The grace period is the duration in seconds after the processes running in the pod are sent
	// a termination signal and the time when the processes are forcibly halted with a kill signal.
	// Set this value longer than the expected cleanup time for your process.
	// If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
	// value overrides the value provided by the pod spec.
	// Value must be non-negative integer. The value zero indicates stop immediately via
	// the kill signal (no opportunity to shut down).
	// This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
	// Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
	// +optional
	terminationGracePeriodSeconds?: null | int64 @go(TerminationGracePeriodSeconds,*int64)
}

// PhaseSwitchover when a cluster is changing the primary node
#PhaseSwitchover: "Switchover in progress"

// PhaseFailOver in case a pod is missing and need to change primary
#PhaseFailOver: "Failing over"

// PhaseFirstPrimary for an starting cluster
#PhaseFirstPrimary: "Setting up primary"

// PhaseCreatingReplica everytime we add a new replica
#PhaseCreatingReplica: "Creating a new replica"

// PhaseUpgrade upgrade in process
#PhaseUpgrade: "Upgrading cluster"

// PhaseUpgradeDelayed is set when a cluster need to be upgraded
// but the operation is being delayed by the operator configuration
#PhaseUpgradeDelayed: "Cluster upgrade delayed"

// PhaseWaitingForUser set the status to wait for an action from the user
#PhaseWaitingForUser: "Waiting for user action"

// PhaseInplacePrimaryRestart for a cluster restarting the primary instance in-place
#PhaseInplacePrimaryRestart: "Primary instance is being restarted in-place"

// PhaseInplaceDeletePrimaryRestart for a cluster restarting the primary instance without a switchover
#PhaseInplaceDeletePrimaryRestart: "Primary instance is being restarted without a switchover"

// PhaseHealthy for a cluster doing nothing
#PhaseHealthy: "Cluster in healthy state"

// PhaseUnknownPlugin is triggered when the required CNPG-i plugin have not been
// loaded still
#PhaseUnknownPlugin: "Cluster cannot proceed to reconciliation due to an unknown plugin being required"

// PhaseImageCatalogError is triggered when the cluster cannot select the image to
// apply because of an invalid or incomplete catalog
#PhaseImageCatalogError: "Cluster has incomplete or invalid image catalog"

// PhaseUnrecoverable for an unrecoverable cluster
#PhaseUnrecoverable: "Cluster is unrecoverable and needs manual intervention"

// PhaseArchitectureBinaryMissing is the error phase describing a missing architecture
#PhaseArchitectureBinaryMissing: "Cluster cannot execute instance online upgrade due to missing architecture binary"

// PhaseWaitingForInstancesToBeActive is a waiting phase that is triggered when an instance pod is not active
#PhaseWaitingForInstancesToBeActive: "Waiting for the instances to become active"

// PhaseOnlineUpgrading for when the instance manager is being upgraded in place
#PhaseOnlineUpgrading: "Online upgrade in progress"

// PhaseApplyingConfiguration is set by the instance manager when a configuration
// change is being detected
#PhaseApplyingConfiguration: "Applying configuration"

// PhaseReplicaClusterPromotion is the phase
#PhaseReplicaClusterPromotion: "Promoting to primary cluster"

// PhaseCannotCreateClusterObjects is set by the operator when is unable to create cluster resources
#PhaseCannotCreateClusterObjects: "Unable to create required cluster objects"

// EphemeralVolumesSizeLimitConfiguration contains the configuration of the ephemeral
// storage
#EphemeralVolumesSizeLimitConfiguration: {
	// Shm is the size limit of the shared memory volume
	// +optional
	shm?: null | resource.#Quantity @go(Shm,*resource.Quantity)

	// TemporaryData is the size limit of the temporary data volume
	// +optional
	temporaryData?: null | resource.#Quantity @go(TemporaryData,*resource.Quantity)
}

// ServiceAccountTemplate contains the template needed to generate the service accounts
#ServiceAccountTemplate: {
	// Metadata are the metadata to be used for the generated
	// service account
	metadata: #Metadata @go(Metadata)
}

// PodTopologyLabels represent the topology of a Pod. map[labelName]labelValue
#PodTopologyLabels: {[string]: string}

// PodName is the name of a Pod
#PodName: string

// Topology contains the cluster topology
#Topology: {
	// Instances contains the pod topology of the instances
	// +optional
	instances?: {[string]: #PodTopologyLabels} @go(Instances,map[PodName]PodTopologyLabels)

	// NodesUsed represents the count of distinct nodes accommodating the instances.
	// A value of '1' suggests that all instances are hosted on a single node,
	// implying the absence of High Availability (HA). Ideally, this value should
	// be the same as the number of instances in the Postgres HA cluster, implying
	// shared nothing architecture on the compute side.
	// +optional
	nodesUsed?: int32 @go(NodesUsed)

	// SuccessfullyExtracted indicates if the topology data was extract. It is useful to enact fallback behaviors
	// in synchronous replica election in case of failures
	// +optional
	successfullyExtracted?: bool @go(SuccessfullyExtracted)
}

// RoleStatus represents the status of a managed role in the cluster
#RoleStatus: string // #enumRoleStatus

#enumRoleStatus:
	#RoleStatusReconciled |
	#RoleStatusNotManaged |
	#RoleStatusPendingReconciliation |
	#RoleStatusReserved

// RoleStatusReconciled indicates the role in DB matches the Spec
#RoleStatusReconciled: #RoleStatus & "reconciled"

// RoleStatusNotManaged indicates the role is not in the Spec, therefore not managed
#RoleStatusNotManaged: #RoleStatus & "not-managed"

// RoleStatusPendingReconciliation indicates the role in Spec requires updated/creation in DB
#RoleStatusPendingReconciliation: #RoleStatus & "pending-reconciliation"

// RoleStatusReserved indicates this is one of the roles reserved by the operator. E.g. `postgres`
#RoleStatusReserved: #RoleStatus & "reserved"

// PasswordState represents the state of the password of a managed RoleConfiguration
#PasswordState: {
	// the last transaction ID to affect the role definition in PostgreSQL
	// +optional
	transactionID?: int64 @go(TransactionID)

	// the resource version of the password secret
	// +optional
	resourceVersion?: string @go(SecretResourceVersion)
}

// ManagedRoles tracks the status of a cluster's managed roles
#ManagedRoles: {
	// ByStatus gives the list of roles in each state
	// +optional
	byStatus?: {[string]: [...string]} @go(ByStatus,map[RoleStatus][]string)

	// CannotReconcile lists roles that cannot be reconciled in PostgreSQL,
	// with an explanation of the cause
	// +optional
	cannotReconcile?: {[string]: [...string]} @go(CannotReconcile,map[string][]string)

	// PasswordStatus gives the last transaction id and password secret version for each managed role
	// +optional
	passwordStatus?: {[string]: #PasswordState} @go(PasswordStatus,map[string]PasswordState)
}

// TablespaceState represents the state of a tablespace in a cluster
#TablespaceState: {
	// Name is the name of the tablespace
	name: string @go(Name)

	// Owner is the PostgreSQL user owning the tablespace
	// +optional
	owner?: string @go(Owner)

	// State is the latest reconciliation state
	state: #TablespaceStatus @go(State)

	// Error is the reconciliation error, if any
	// +optional
	error?: string @go(Error)
}

// TablespaceStatus represents the status of a tablespace in the cluster
#TablespaceStatus: string // #enumTablespaceStatus

#enumTablespaceStatus:
	#TablespaceStatusReconciled |
	#TablespaceStatusPendingReconciliation

// TablespaceStatusReconciled indicates the tablespace in DB matches the Spec
#TablespaceStatusReconciled: #TablespaceStatus & "reconciled"

// TablespaceStatusPendingReconciliation indicates the tablespace in Spec requires creation in the DB
#TablespaceStatusPendingReconciliation: #TablespaceStatus & "pending"

// AvailableArchitecture represents the state of a cluster's architecture
#AvailableArchitecture: {
	// GoArch is the name of the executable architecture
	goArch: string @go(GoArch)

	// Hash is the hash of the executable
	hash: string @go(Hash)
}

// ClusterStatus defines the observed state of Cluster
#ClusterStatus: {
	// The total number of PVC Groups detected in the cluster. It may differ from the number of existing instance pods.
	// +optional
	instances?: int @go(Instances)

	// The total number of ready instances in the cluster. It is equal to the number of ready instance pods.
	// +optional
	readyInstances?: int @go(ReadyInstances)

	// InstancesStatus indicates in which status the instances are
	// +optional
	instancesStatus?: {[string]: [...string]} @go(InstancesStatus,map[PodStatus][]string)

	// The reported state of the instances during the last reconciliation loop
	// +optional
	instancesReportedState?: {[string]: #InstanceReportedState} @go(InstancesReportedState,map[PodName]InstanceReportedState)

	// ManagedRolesStatus reports the state of the managed roles in the cluster
	// +optional
	managedRolesStatus?: #ManagedRoles @go(ManagedRolesStatus)

	// TablespacesStatus reports the state of the declarative tablespaces in the cluster
	// +optional
	tablespacesStatus?: [...#TablespaceState] @go(TablespacesStatus,[]TablespaceState)

	// The timeline of the Postgres cluster
	// +optional
	timelineID?: int @go(TimelineID)

	// Instances topology.
	// +optional
	topology?: #Topology @go(Topology)

	// ID of the latest generated node (used to avoid node name clashing)
	// +optional
	latestGeneratedNode?: int @go(LatestGeneratedNode)

	// Current primary instance
	// +optional
	currentPrimary?: string @go(CurrentPrimary)

	// Target primary instance, this is different from the previous one
	// during a switchover or a failover
	// +optional
	targetPrimary?: string @go(TargetPrimary)

	// LastPromotionToken is the last verified promotion token that
	// was used to promote a replica cluster
	// +optional
	lastPromotionToken?: string @go(LastPromotionToken)

	// How many PVCs have been created by this cluster
	// +optional
	pvcCount?: int32 @go(PVCCount)

	// How many Jobs have been created by this cluster
	// +optional
	jobCount?: int32 @go(JobCount)

	// List of all the PVCs created by this cluster and still available
	// which are not attached to a Pod
	// +optional
	danglingPVC?: [...string] @go(DanglingPVC,[]string)

	// List of all the PVCs that have ResizingPVC condition.
	// +optional
	resizingPVC?: [...string] @go(ResizingPVC,[]string)

	// List of all the PVCs that are being initialized by this cluster
	// +optional
	initializingPVC?: [...string] @go(InitializingPVC,[]string)

	// List of all the PVCs not dangling nor initializing
	// +optional
	healthyPVC?: [...string] @go(HealthyPVC,[]string)

	// List of all the PVCs that are unusable because another PVC is missing
	// +optional
	unusablePVC?: [...string] @go(UnusablePVC,[]string)

	// Current write pod
	// +optional
	writeService?: string @go(WriteService)

	// Current list of read pods
	// +optional
	readService?: string @go(ReadService)

	// Current phase of the cluster
	// +optional
	phase?: string @go(Phase)

	// Reason for the current phase
	// +optional
	phaseReason?: string @go(PhaseReason)

	// The list of resource versions of the secrets
	// managed by the operator. Every change here is done in the
	// interest of the instance manager, which will refresh the
	// secret data
	// +optional
	secretsResourceVersion?: #SecretsResourceVersion @go(SecretsResourceVersion)

	// The list of resource versions of the configmaps,
	// managed by the operator. Every change here is done in the
	// interest of the instance manager, which will refresh the
	// configmap data
	// +optional
	configMapResourceVersion?: #ConfigMapResourceVersion @go(ConfigMapResourceVersion)

	// The configuration for the CA and related certificates, initialized with defaults.
	// +optional
	certificates?: #CertificatesStatus @go(Certificates)

	// The first recoverability point, stored as a date in RFC3339 format.
	// This field is calculated from the content of FirstRecoverabilityPointByMethod
	// +optional
	firstRecoverabilityPoint?: string @go(FirstRecoverabilityPoint)

	// The first recoverability point, stored as a date in RFC3339 format, per backup method type
	// +optional
	firstRecoverabilityPointByMethod?: {[string]: metav1.#Time} @go(FirstRecoverabilityPointByMethod,map[BackupMethod]metav1.Time)

	// Last successful backup, stored as a date in RFC3339 format
	// This field is calculated from the content of LastSuccessfulBackupByMethod
	// +optional
	lastSuccessfulBackup?: string @go(LastSuccessfulBackup)

	// Last successful backup, stored as a date in RFC3339 format, per backup method type
	// +optional
	lastSuccessfulBackupByMethod?: {[string]: metav1.#Time} @go(LastSuccessfulBackupByMethod,map[BackupMethod]metav1.Time)

	// Stored as a date in RFC3339 format
	// +optional
	lastFailedBackup?: string @go(LastFailedBackup)

	// The commit hash number of which this operator running
	// +optional
	cloudNativePGCommitHash?: string @go(CommitHash)

	// The timestamp when the last actual promotion to primary has occurred
	// +optional
	currentPrimaryTimestamp?: string @go(CurrentPrimaryTimestamp)

	// The timestamp when the primary was detected to be unhealthy
	// This field is reported when `.spec.failoverDelay` is populated or during online upgrades
	// +optional
	currentPrimaryFailingSinceTimestamp?: string @go(CurrentPrimaryFailingSinceTimestamp)

	// The timestamp when the last request for a new primary has occurred
	// +optional
	targetPrimaryTimestamp?: string @go(TargetPrimaryTimestamp)

	// The integration needed by poolers referencing the cluster
	// +optional
	poolerIntegrations?: null | #PoolerIntegrations @go(PoolerIntegrations,*PoolerIntegrations)

	// The hash of the binary of the operator
	// +optional
	cloudNativePGOperatorHash?: string @go(OperatorHash)

	// AvailableArchitectures reports the available architectures of a cluster
	// +optional
	availableArchitectures?: [...#AvailableArchitecture] @go(AvailableArchitectures,[]AvailableArchitecture)

	// Conditions for cluster object
	// +optional
	conditions?: [...metav1.#Condition] @go(Conditions,[]metav1.Condition)

	// List of instance names in the cluster
	// +optional
	instanceNames?: [...string] @go(InstanceNames,[]string)

	// OnlineUpdateEnabled shows if the online upgrade is enabled inside the cluster
	// +optional
	onlineUpdateEnabled?: bool @go(OnlineUpdateEnabled)

	// AzurePVCUpdateEnabled shows if the PVC online upgrade is enabled for this cluster
	// +optional
	azurePVCUpdateEnabled?: bool @go(AzurePVCUpdateEnabled)

	// Image contains the image name used by the pods
	// +optional
	image?: string @go(Image)

	// PluginStatus is the status of the loaded plugins
	// +optional
	pluginStatus?: [...#PluginStatus] @go(PluginStatus,[]PluginStatus)

	// SwitchReplicaClusterStatus is the status of the switch to replica cluster
	// +optional
	switchReplicaClusterStatus?: #SwitchReplicaClusterStatus @go(SwitchReplicaClusterStatus)

	// DemotionToken is a JSON token containing the information
	// from pg_controldata such as Database system identifier, Latest checkpoint's
	// TimeLineID, Latest checkpoint's REDO location, Latest checkpoint's REDO
	// WAL file, and Time of latest checkpoint
	// +optional
	demotionToken?: string @go(DemotionToken)
}

// SwitchReplicaClusterStatus contains all the statuses regarding the switch of a cluster to a replica cluster
#SwitchReplicaClusterStatus: {
	// InProgress indicates if there is an ongoing procedure of switching a cluster to a replica cluster.
	// +optional
	inProgress?: bool @go(InProgress)
}

// InstanceReportedState describes the last reported state of an instance during a reconciliation loop
#InstanceReportedState: {
	// indicates if an instance is the primary one
	isPrimary: bool @go(IsPrimary)

	// indicates on which TimelineId the instance is
	// +optional
	timeLineID?: int @go(TimeLineID)
}

// ClusterConditionType defines types of cluster conditions
#ClusterConditionType: string // #enumClusterConditionType

#enumClusterConditionType:
	#ConditionContinuousArchiving |
	#ConditionBackup |
	#ConditionClusterReady

// ConditionContinuousArchiving represents whether WAL archiving is working
#ConditionContinuousArchiving: #ClusterConditionType & "ContinuousArchiving"

// ConditionBackup represents the last backup's status
#ConditionBackup: #ClusterConditionType & "LastBackupSucceeded"

// ConditionClusterReady represents whether a cluster is Ready
#ConditionClusterReady: #ClusterConditionType & "Ready"

// ConditionStatus defines conditions of resources
#ConditionStatus: string // #enumConditionStatus

#enumConditionStatus:
	#ConditionTrue |
	#ConditionFalse |
	#ConditionUnknown

#ConditionTrue:    #ConditionStatus & "True"
#ConditionFalse:   #ConditionStatus & "False"
#ConditionUnknown: #ConditionStatus & "Unknown"

// ConditionReason defines the reason why a certain
// condition changed
#ConditionReason: string // #enumConditionReason

#enumConditionReason:
	#ConditionBackupStarted |
	#ConditionReasonLastBackupSucceeded |
	#ConditionReasonLastBackupFailed |
	#ConditionReasonContinuousArchivingSuccess |
	#ConditionReasonContinuousArchivingFailing |
	#ClusterReady |
	#ClusterIsNotReady |
	#DetachedVolume

// ConditionBackupStarted means that the condition changed because the debug
// started
#ConditionBackupStarted: #ConditionReason & "BackupStarted"

// ConditionReasonLastBackupSucceeded means that the condition changed because the last backup
// has been taken successfully
#ConditionReasonLastBackupSucceeded: #ConditionReason & "LastBackupSucceeded"

// ConditionReasonLastBackupFailed means that the condition changed because the last backup
// failed
#ConditionReasonLastBackupFailed: #ConditionReason & "LastBackupFailed"

// ConditionReasonContinuousArchivingSuccess means that the condition changed because the
// WAL archiving was working correctly
#ConditionReasonContinuousArchivingSuccess: #ConditionReason & "ContinuousArchivingSuccess"

// ConditionReasonContinuousArchivingFailing means that the condition has changed because
// the WAL archiving is not working correctly
#ConditionReasonContinuousArchivingFailing: #ConditionReason & "ContinuousArchivingFailing"

// ClusterReady means that the condition changed because the cluster is ready and working properly
#ClusterReady: #ConditionReason & "ClusterIsReady"

// ClusterIsNotReady means that the condition changed because the cluster is not ready
#ClusterIsNotReady: #ConditionReason & "ClusterIsNotReady"

// DetachedVolume is the reason that is set when we do a rolling upgrade to add a PVC volume to a cluster
#DetachedVolume: #ConditionReason & "DetachedVolume"

// EmbeddedObjectMetadata contains metadata to be inherited by all resources related to a Cluster
#EmbeddedObjectMetadata: {
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string)

	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string)
}

// PoolerIntegrations encapsulates the needed integration for the poolers referencing the cluster
#PoolerIntegrations: {
	// +optional
	pgBouncerIntegration?: #PgBouncerIntegrationStatus @go(PgBouncerIntegration)
}

// PgBouncerIntegrationStatus encapsulates the needed integration for the pgbouncer poolers referencing the cluster
#PgBouncerIntegrationStatus: {
	// +optional
	secrets?: [...string] @go(Secrets,[]string)
}

// ReplicaClusterConfiguration encapsulates the configuration of a replica
// cluster
#ReplicaClusterConfiguration: {
	// Self defines the name of this cluster. It is used to determine if this is a primary
	// or a replica cluster, comparing it with `primary`
	// +optional
	self?: string @go(Self)

	// Primary defines which Cluster is defined to be the primary in the distributed PostgreSQL cluster, based on the
	// topology specified in externalClusters
	// +optional
	primary?: string @go(Primary)

	// The name of the external cluster which is the replication origin
	// +kubebuilder:validation:MinLength=1
	source: string @go(Source)

	// If replica mode is enabled, this cluster will be a replica of an
	// existing cluster. Replica cluster can be created from a recovery
	// object store or via streaming through pg_basebackup.
	// Refer to the Replica clusters page of the documentation for more information.
	// +optional
	enabled?: null | bool @go(Enabled,*bool)

	// A demotion token generated by an external cluster used to
	// check if the promotion requirements are met.
	// +optional
	promotionToken?: string @go(PromotionToken)

	// When replica mode is enabled, this parameter allows you to replay
	// transactions only when the system time is at least the configured
	// time past the commit time. This provides an opportunity to correct
	// data loss errors. Note that when this parameter is set, a promotion
	// token cannot be used.
	// +optional
	minApplyDelay?: null | metav1.#Duration @go(MinApplyDelay,*metav1.Duration)
}

#DefaultReplicationSlotsUpdateInterval: 30

#DefaultReplicationSlotsHASlotPrefix: "_cnpg_"

// SynchronizeReplicasConfiguration contains the configuration for the synchronization of user defined
// physical replication slots
#SynchronizeReplicasConfiguration: {
	// When set to true, every replication slot that is on the primary is synchronized on each standby
	// +kubebuilder:default:=true
	enabled?: null | bool @go(Enabled,*bool)

	// List of regular expression patterns to match the names of replication slots to be excluded (by default empty)
	// +optional
	excludePatterns?: [...string] @go(ExcludePatterns,[]string)
}

// ReplicationSlotsConfiguration encapsulates the configuration
// of replication slots
#ReplicationSlotsConfiguration: {
	// Replication slots for high availability configuration
	// +kubebuilder:default:={"enabled": true}
	// +optional
	highAvailability?: null | #ReplicationSlotsHAConfiguration @go(HighAvailability,*ReplicationSlotsHAConfiguration)

	// Standby will update the status of the local replication slots
	// every `updateInterval` seconds (default 30).
	// +kubebuilder:default:=30
	// +kubebuilder:validation:Minimum=1
	// +optional
	updateInterval?: int @go(UpdateInterval)

	// Configures the synchronization of the user defined physical replication slots
	// +optional
	synchronizeReplicas?: null | #SynchronizeReplicasConfiguration @go(SynchronizeReplicas,*SynchronizeReplicasConfiguration)
}

// ReplicationSlotsHAConfiguration encapsulates the configuration
// of the replication slots that are automatically managed by
// the operator to control the streaming replication connections
// with the standby instances for high availability (HA) purposes.
// Replication slots are a PostgreSQL feature that makes sure
// that PostgreSQL automatically keeps WAL files in the primary
// when a streaming client (in this specific case a replica that
// is part of the HA cluster) gets disconnected.
#ReplicationSlotsHAConfiguration: {
	// If enabled (default), the operator will automatically manage replication slots
	// on the primary instance and use them in streaming replication
	// connections with all the standby instances that are part of the HA
	// cluster. If disabled, the operator will not take advantage
	// of replication slots in streaming connections with the replicas.
	// This feature also controls replication slots in replica cluster,
	// from the designated primary to its cascading replicas.
	// +optional
	// +kubebuilder:default:=true
	enabled?: null | bool @go(Enabled,*bool)

	// Prefix for replication slots managed by the operator for HA.
	// It may only contain lower case letters, numbers, and the underscore character.
	// This can only be set at creation time. By default set to `_cnpg_`.
	// +kubebuilder:default:=_cnpg_
	// +kubebuilder:validation:Pattern=^[0-9a-z_]*$
	// +optional
	slotPrefix?: string @go(SlotPrefix)
}

// KubernetesUpgradeStrategy tells the operator if the user want to
// allocate more space while upgrading a k8s node which is hosting
// the PostgreSQL Pods or just wait for the node to come up
#KubernetesUpgradeStrategy: string

// KubernetesUpgradeStrategyAllocateSpace means that the operator
// should allocate more disk space to host data belonging to the
// k8s node that is being updated
#KubernetesUpgradeStrategyAllocateSpace: "allocateSpace"

// KubernetesUpgradeStrategyWaitForNode means that the operator
// should just recreate stuff and wait for the upgraded node
// to be ready
#KubernetesUpgradeStrategyWaitForNode: "waitForNode"

// NodeMaintenanceWindow contains information that the operator
// will use while upgrading the underlying node.
//
// This option is only useful when the chosen storage prevents the Pods
// from being freely moved across nodes.
#NodeMaintenanceWindow: {
	// Reuse the existing PVC (wait for the node to come
	// up again) or not (recreate it elsewhere - when `instances` >1)
	// +optional
	// +kubebuilder:default:=true
	reusePVC?: null | bool @go(ReusePVC,*bool)

	// Is there a node maintenance activity in progress?
	// +optional
	// +kubebuilder:default:=false
	inProgress?: bool @go(InProgress)
}

// PrimaryUpdateStrategy contains the strategy to follow when upgrading
// the primary server of the cluster as part of rolling updates
#PrimaryUpdateStrategy: string // #enumPrimaryUpdateStrategy

#enumPrimaryUpdateStrategy:
	#PrimaryUpdateStrategySupervised |
	#PrimaryUpdateStrategyUnsupervised

// PrimaryUpdateMethod contains the method to use when upgrading
// the primary server of the cluster as part of rolling updates
#PrimaryUpdateMethod: string // #enumPrimaryUpdateMethod

#enumPrimaryUpdateMethod:
	#PrimaryUpdateMethodSwitchover |
	#PrimaryUpdateMethodRestart

// PrimaryUpdateStrategySupervised means that the operator need to wait for the
// user to manually issue a switchover request before updating the primary
// server (`supervised`)
#PrimaryUpdateStrategySupervised: #PrimaryUpdateStrategy & "supervised"

// PrimaryUpdateStrategyUnsupervised means that the operator will proceed with the
// selected PrimaryUpdateMethod to another updated replica and then automatically update
// the primary server (`unsupervised`, default)
#PrimaryUpdateStrategyUnsupervised: #PrimaryUpdateStrategy & "unsupervised"

// PrimaryUpdateMethodSwitchover means that the operator will switchover to another updated
// replica when it needs to upgrade the primary instance
#PrimaryUpdateMethodSwitchover: #PrimaryUpdateMethod & "switchover"

// PrimaryUpdateMethodRestart means that the operator will restart the primary instance in-place
// when it needs to upgrade it
#PrimaryUpdateMethodRestart: #PrimaryUpdateMethod & "restart"

// DefaultPgCtlTimeoutForPromotion is the default for the pg_ctl timeout when a promotion is performed.
// It is greater than one year in seconds, big enough to simulate an infinite timeout
#DefaultPgCtlTimeoutForPromotion: 40000000

// DefaultMaxSwitchoverDelay is the default for the pg_ctl timeout in seconds when a primary PostgreSQL instance
// is gracefully shutdown during a switchover.
#DefaultMaxSwitchoverDelay: 3600

// DefaultStartupDelay is the default value for startupDelay, startupDelay will be used to calculate the
// FailureThreshold of startupProbe, the formula is `FailureThreshold = ceiling(startDelay / periodSeconds)`,
// the minimum value is 1
#DefaultStartupDelay: 3600

// SynchronousReplicaConfigurationMethod configures whether to use
// quorum based replication or a priority list
#SynchronousReplicaConfigurationMethod: string // #enumSynchronousReplicaConfigurationMethod

#enumSynchronousReplicaConfigurationMethod:
	#SynchronousReplicaConfigurationMethodFirst |
	#SynchronousReplicaConfigurationMethodAny

// SynchronousReplicaConfigurationMethodFirst means a priority list should be used
#SynchronousReplicaConfigurationMethodFirst: #SynchronousReplicaConfigurationMethod & "first"

// SynchronousReplicaConfigurationMethodAny means that quorum based replication should be used
#SynchronousReplicaConfigurationMethodAny: #SynchronousReplicaConfigurationMethod & "any"

// DataDurabilityLevel specifies how strictly to enforce synchronous replication
// when cluster instances are unavailable. Options are `required` or `preferred`.
#DataDurabilityLevel: string // #enumDataDurabilityLevel

#enumDataDurabilityLevel:
	#DataDurabilityLevelRequired |
	#DataDurabilityLevelPreferred

// DataDurabilityLevelRequired means that data durability is strictly enforced
#DataDurabilityLevelRequired: #DataDurabilityLevel & "required"

// DataDurabilityLevelPreferred means that data durability is enforced
// only when healthy replicas are available
#DataDurabilityLevelPreferred: #DataDurabilityLevel & "preferred"

// SynchronousReplicaConfiguration contains the configuration of the
// PostgreSQL synchronous replication feature.
// Important: at this moment, also `.spec.minSyncReplicas` and `.spec.maxSyncReplicas`
// need to be considered.
// +kubebuilder:validation:XValidation:rule="self.dataDurability!='preferred' || ((!has(self.standbyNamesPre) || self.standbyNamesPre.size()==0) && (!has(self.standbyNamesPost) || self.standbyNamesPost.size()==0))",message="dataDurability set to 'preferred' requires empty 'standbyNamesPre' and empty 'standbyNamesPost'"
#SynchronousReplicaConfiguration: {
	// Method to select synchronous replication standbys from the listed
	// servers, accepting 'any' (quorum-based synchronous replication) or
	// 'first' (priority-based synchronous replication) as values.
	// +kubebuilder:validation:Enum=any;first
	method: #SynchronousReplicaConfigurationMethod @go(Method)

	// Specifies the number of synchronous standby servers that
	// transactions must wait for responses from.
	// +kubebuilder:validation:XValidation:rule="self > 0",message="The number of synchronous replicas should be greater than zero"
	number: int @go(Number)

	// Specifies the maximum number of local cluster pods that can be
	// automatically included in the `synchronous_standby_names` option in
	// PostgreSQL.
	// +optional
	maxStandbyNamesFromCluster?: null | int @go(MaxStandbyNamesFromCluster,*int)

	// A user-defined list of application names to be added to
	// `synchronous_standby_names` before local cluster pods (the order is
	// only useful for priority-based synchronous replication).
	// +optional
	standbyNamesPre?: [...string] @go(StandbyNamesPre,[]string)

	// A user-defined list of application names to be added to
	// `synchronous_standby_names` after local cluster pods (the order is
	// only useful for priority-based synchronous replication).
	// +optional
	standbyNamesPost?: [...string] @go(StandbyNamesPost,[]string)

	// If set to "required", data durability is strictly enforced. Write operations
	// with synchronous commit settings (`on`, `remote_write`, or `remote_apply`) will
	// block if there are insufficient healthy replicas, ensuring data persistence.
	// If set to "preferred", data durability is maintained when healthy replicas
	// are available, but the required number of instances will adjust dynamically
	// if replicas become unavailable. This setting relaxes strict durability enforcement
	// to allow for operational continuity. This setting is only applicable if both
	// `standbyNamesPre` and `standbyNamesPost` are unset (empty).
	// +kubebuilder:validation:Enum=required;preferred
	// +kubebuilder:default:=required
	// +optional
	dataDurability?: #DataDurabilityLevel @go(DataDurability)
}

// PostgresConfiguration defines the PostgreSQL configuration
#PostgresConfiguration: {
	// PostgreSQL configuration options (postgresql.conf)
	// +optional
	parameters?: {[string]: string} @go(Parameters,map[string]string)

	// Configuration of the PostgreSQL synchronous replication feature
	// +optional
	synchronous?: null | #SynchronousReplicaConfiguration @go(Synchronous,*SynchronousReplicaConfiguration)

	// PostgreSQL Host Based Authentication rules (lines to be appended
	// to the pg_hba.conf file)
	// +optional
	pg_hba?: [...string] @go(PgHBA,[]string)

	// PostgreSQL User Name Maps rules (lines to be appended
	// to the pg_ident.conf file)
	// +optional
	pg_ident?: [...string] @go(PgIdent,[]string)

	// Requirements to be met by sync replicas. This will affect how the "synchronous_standby_names" parameter will be
	// set up.
	// +optional
	syncReplicaElectionConstraint?: #SyncReplicaElectionConstraints @go(SyncReplicaElectionConstraint)

	// Lists of shared preload libraries to add to the default ones
	// +optional
	shared_preload_libraries?: [...string] @go(AdditionalLibraries,[]string)

	// Options to specify LDAP configuration
	// +optional
	ldap?: null | #LDAPConfig @go(LDAP,*LDAPConfig)

	// Specifies the maximum number of seconds to wait when promoting an instance to primary.
	// Default value is 40000000, greater than one year in seconds,
	// big enough to simulate an infinite timeout
	// +optional
	promotionTimeout?: int32 @go(PgCtlTimeoutForPromotion)

	// If this parameter is true, the user will be able to invoke `ALTER SYSTEM`
	// on this CloudNativePG Cluster.
	// This should only be used for debugging and troubleshooting.
	// Defaults to false.
	// +optional
	enableAlterSystem?: bool @go(EnableAlterSystem)
}

// BootstrapConfiguration contains information about how to create the PostgreSQL
// cluster. Only a single bootstrap method can be defined among the supported
// ones. `initdb` will be used as the bootstrap method if left
// unspecified. Refer to the Bootstrap page of the documentation for more
// information.
#BootstrapConfiguration: {
	// Bootstrap the cluster via initdb
	// +optional
	initdb?: null | #BootstrapInitDB @go(InitDB,*BootstrapInitDB)

	// Bootstrap the cluster from a backup
	// +optional
	recovery?: null | #BootstrapRecovery @go(Recovery,*BootstrapRecovery)

	// Bootstrap the cluster taking a physical backup of another compatible
	// PostgreSQL instance
	// +optional
	pg_basebackup?: null | #BootstrapPgBaseBackup @go(PgBaseBackup,*BootstrapPgBaseBackup)
}

// LDAPScheme defines the possible schemes for LDAP
#LDAPScheme: string // #enumLDAPScheme

#enumLDAPScheme:
	#LDAPSchemeLDAP |
	#LDAPSchemeLDAPS

#LDAPSchemeLDAP:  #LDAPScheme & "ldap"
#LDAPSchemeLDAPS: #LDAPScheme & "ldaps"

// LDAPConfig contains the parameters needed for LDAP authentication
#LDAPConfig: {
	// LDAP hostname or IP address
	// +optional
	server?: string @go(Server)

	// LDAP server port
	// +optional
	port?: int @go(Port)

	// LDAP schema to be used, possible options are `ldap` and `ldaps`
	// +kubebuilder:validation:Enum=ldap;ldaps
	// +optional
	scheme?: #LDAPScheme @go(Scheme)

	// Bind as authentication configuration
	// +optional
	bindAsAuth?: null | #LDAPBindAsAuth @go(BindAsAuth,*LDAPBindAsAuth)

	// Bind+Search authentication configuration
	// +optional
	bindSearchAuth?: null | #LDAPBindSearchAuth @go(BindSearchAuth,*LDAPBindSearchAuth)

	// Set to 'true' to enable LDAP over TLS. 'false' is default
	// +optional
	tls?: bool @go(TLS)
}

// LDAPBindAsAuth provides the required fields to use the
// bind authentication for LDAP
#LDAPBindAsAuth: {
	// Prefix for the bind authentication option
	// +optional
	prefix?: string @go(Prefix)

	// Suffix for the bind authentication option
	// +optional
	suffix?: string @go(Suffix)
}

// LDAPBindSearchAuth provides the required fields to use
// the bind+search LDAP authentication process
#LDAPBindSearchAuth: {
	// Root DN to begin the user search
	// +optional
	baseDN?: string @go(BaseDN)

	// DN of the user to bind to the directory
	// +optional
	bindDN?: string @go(BindDN)

	// Secret with the password for the user to bind to the directory
	// +optional
	bindPassword?: null | corev1.#SecretKeySelector @go(BindPassword,*corev1.SecretKeySelector)

	// Attribute to match against the username
	// +optional
	searchAttribute?: string @go(SearchAttribute)

	// Search filter to use when doing the search+bind authentication
	// +optional
	searchFilter?: string @go(SearchFilter)
}

// CertificatesConfiguration contains the needed configurations to handle server certificates.
#CertificatesConfiguration: {
	// The secret containing the Server CA certificate. If not defined, a new secret will be created
	// with a self-signed CA and will be used to generate the TLS certificate ServerTLSSecret.<br />
	// <br />
	// Contains:<br />
	// <br />
	// - `ca.crt`: CA that should be used to validate the server certificate,
	// used as `sslrootcert` in client connection strings.<br />
	// - `ca.key`: key used to generate Server SSL certs, if ServerTLSSecret is provided,
	// this can be omitted.<br />
	// +optional
	serverCASecret?: string @go(ServerCASecret)

	// The secret of type kubernetes.io/tls containing the server TLS certificate and key that will be set as
	// `ssl_cert_file` and `ssl_key_file` so that clients can connect to postgres securely.
	// If not defined, ServerCASecret must provide also `ca.key` and a new secret will be
	// created using the provided CA.
	// +optional
	serverTLSSecret?: string @go(ServerTLSSecret)

	// The secret of type kubernetes.io/tls containing the client certificate to authenticate as
	// the `streaming_replica` user.
	// If not defined, ClientCASecret must provide also `ca.key`, and a new secret will be
	// created using the provided CA.
	// +optional
	replicationTLSSecret?: string @go(ReplicationTLSSecret)

	// The secret containing the Client CA certificate. If not defined, a new secret will be created
	// with a self-signed CA and will be used to generate all the client certificates.<br />
	// <br />
	// Contains:<br />
	// <br />
	// - `ca.crt`: CA that should be used to validate the client certificates,
	// used as `ssl_ca_file` of all the instances.<br />
	// - `ca.key`: key used to generate client certificates, if ReplicationTLSSecret is provided,
	// this can be omitted.<br />
	// +optional
	clientCASecret?: string @go(ClientCASecret)

	// The list of the server alternative DNS names to be added to the generated server TLS certificates, when required.
	// +optional
	serverAltDNSNames?: [...string] @go(ServerAltDNSNames,[]string)
}

// CertificatesStatus contains configuration certificates and related expiration dates.
#CertificatesStatus: {
	#CertificatesConfiguration

	// Expiration dates for all certificates.
	// +optional
	expirations?: {[string]: string} @go(Expirations,map[string]string)
}

// BootstrapInitDB is the configuration of the bootstrap process when
// initdb is used
// Refer to the Bootstrap page of the documentation for more information.
// +kubebuilder:validation:XValidation:rule="!has(self.builtinLocale) || self.localeProvider == 'builtin'",message="builtinLocale is only available when localeProvider is set to `builtin`"
// +kubebuilder:validation:XValidation:rule="!has(self.icuLocale) || self.localeProvider == 'icu'",message="icuLocale is only available when localeProvider is set to `icu`"
// +kubebuilder:validation:XValidation:rule="!has(self.icuRules) || self.localeProvider == 'icu'",message="icuRules is only available when localeProvider is set to `icu`"
#BootstrapInitDB: {
	// Name of the database used by the application. Default: `app`.
	// +optional
	database?: string @go(Database)

	// Name of the owner of the database in the instance to be used
	// by applications. Defaults to the value of the `database` key.
	// +optional
	owner?: string @go(Owner)

	// Name of the secret containing the initial credentials for the
	// owner of the user database. If empty a new secret will be
	// created from scratch
	// +optional
	secret?: null | api.#LocalObjectReference @go(Secret,*github.com/cloudnative-pg/machinery/pkg/api.LocalObjectReference)

	// The list of options that must be passed to initdb when creating the cluster.
	// Deprecated: This could lead to inconsistent configurations,
	// please use the explicit provided parameters instead.
	// If defined, explicit values will be ignored.
	// +optional
	options?: [...string] @go(Options,[]string)

	// Whether the `-k` option should be passed to initdb,
	// enabling checksums on data pages (default: `false`)
	// +optional
	dataChecksums?: null | bool @go(DataChecksums,*bool)

	// The value to be passed as option `--encoding` for initdb (default:`UTF8`)
	// +optional
	encoding?: string @go(Encoding)

	// The value to be passed as option `--lc-collate` for initdb (default:`C`)
	// +optional
	localeCollate?: string @go(LocaleCollate)

	// The value to be passed as option `--lc-ctype` for initdb (default:`C`)
	// +optional
	localeCType?: string @go(LocaleCType)

	// Sets the default collation order and character classification in the new database.
	// +optional
	locale?: string @go(Locale)

	// This option sets the locale provider for databases created in the new cluster.
	// Available from PostgreSQL 16.
	// +optional
	localeProvider?: string @go(LocaleProvider)

	// Specifies the ICU locale when the ICU provider is used.
	// This option requires `localeProvider` to be set to `icu`.
	// Available from PostgreSQL 15.
	// +optional
	icuLocale?: string @go(IcuLocale)

	// Specifies additional collation rules to customize the behavior of the default collation.
	// This option requires `localeProvider` to be set to `icu`.
	// Available from PostgreSQL 16.
	// +optional
	icuRules?: string @go(IcuRules)

	// Specifies the locale name when the builtin provider is used.
	// This option requires `localeProvider` to be set to `builtin`.
	// Available from PostgreSQL 17.
	// +optional
	builtinLocale?: string @go(BuiltinLocale)

	// The value in megabytes (1 to 1024) to be passed to the `--wal-segsize`
	// option for initdb (default: empty, resulting in PostgreSQL default: 16MB)
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:validation:Maximum=1024
	// +optional
	walSegmentSize?: int @go(WalSegmentSize)

	// List of SQL queries to be executed as a superuser in the `postgres`
	// database right after the cluster has been created - to be used with extreme care
	// (by default empty)
	// +optional
	postInitSQL?: [...string] @go(PostInitSQL,[]string)

	// List of SQL queries to be executed as a superuser in the application
	// database right after the cluster has been created - to be used with extreme care
	// (by default empty)
	// +optional
	postInitApplicationSQL?: [...string] @go(PostInitApplicationSQL,[]string)

	// List of SQL queries to be executed as a superuser in the `template1`
	// database right after the cluster has been created - to be used with extreme care
	// (by default empty)
	// +optional
	postInitTemplateSQL?: [...string] @go(PostInitTemplateSQL,[]string)

	// Bootstraps the new cluster by importing data from an existing PostgreSQL
	// instance using logical backup (`pg_dump` and `pg_restore`)
	// +optional
	import?: null | #Import @go(Import,*Import)

	// List of references to ConfigMaps or Secrets containing SQL files
	// to be executed as a superuser in the application database right after
	// the cluster has been created. The references are processed in a specific order:
	// first, all Secrets are processed, followed by all ConfigMaps.
	// Within each group, the processing order follows the sequence specified
	// in their respective arrays.
	// (by default empty)
	// +optional
	postInitApplicationSQLRefs?: null | #SQLRefs @go(PostInitApplicationSQLRefs,*SQLRefs)

	// List of references to ConfigMaps or Secrets containing SQL files
	// to be executed as a superuser in the `template1` database right after
	// the cluster has been created. The references are processed in a specific order:
	// first, all Secrets are processed, followed by all ConfigMaps.
	// Within each group, the processing order follows the sequence specified
	// in their respective arrays.
	// (by default empty)
	// +optional
	postInitTemplateSQLRefs?: null | #SQLRefs @go(PostInitTemplateSQLRefs,*SQLRefs)

	// List of references to ConfigMaps or Secrets containing SQL files
	// to be executed as a superuser in the `postgres` database right after
	// the cluster has been created. The references are processed in a specific order:
	// first, all Secrets are processed, followed by all ConfigMaps.
	// Within each group, the processing order follows the sequence specified
	// in their respective arrays.
	// (by default empty)
	// +optional
	postInitSQLRefs?: null | #SQLRefs @go(PostInitSQLRefs,*SQLRefs)
}

// SnapshotType is a type of allowed import
#SnapshotType: string // #enumSnapshotType

#enumSnapshotType:
	#MonolithSnapshotType |
	#MicroserviceSnapshotType

// MonolithSnapshotType indicates to execute the monolith clone typology
#MonolithSnapshotType: #SnapshotType & "monolith"

// MicroserviceSnapshotType indicates to execute the microservice clone typology
#MicroserviceSnapshotType: #SnapshotType & "microservice"

// Import contains the configuration to init a database from a logic snapshot of an externalCluster
#Import: {
	// The source of the import
	source: #ImportSource @go(Source)

	// The import type. Can be `microservice` or `monolith`.
	// +kubebuilder:validation:Enum=microservice;monolith
	type: #SnapshotType @go(Type)

	// The databases to import
	databases: [...string] @go(Databases,[]string)

	// The roles to import
	// +optional
	roles?: [...string] @go(Roles,[]string)

	// List of SQL queries to be executed as a superuser in the application
	// database right after is imported - to be used with extreme care
	// (by default empty). Only available in microservice type.
	// +optional
	postImportApplicationSQL?: [...string] @go(PostImportApplicationSQL,[]string)

	// When set to true, only the `pre-data` and `post-data` sections of
	// `pg_restore` are invoked, avoiding data import. Default: `false`.
	// +optional
	schemaOnly?: bool @go(SchemaOnly)

	// List of custom options to pass to the `pg_dump` command. IMPORTANT:
	// Use these options with caution and at your own risk, as the operator
	// does not validate their content. Be aware that certain options may
	// conflict with the operator's intended functionality or design.
	// +optional
	pgDumpExtraOptions?: [...string] @go(PgDumpExtraOptions,[]string)

	// List of custom options to pass to the `pg_restore` command. IMPORTANT:
	// Use these options with caution and at your own risk, as the operator
	// does not validate their content. Be aware that certain options may
	// conflict with the operator's intended functionality or design.
	// +optional
	pgRestoreExtraOptions?: [...string] @go(PgRestoreExtraOptions,[]string)
}

// ImportSource describes the source for the logical snapshot
#ImportSource: {
	// The name of the externalCluster used for import
	externalCluster: string @go(ExternalCluster)
}

// SQLRefs holds references to ConfigMaps or Secrets
// containing SQL files. The references are processed in a specific order:
// first, all Secrets are processed, followed by all ConfigMaps.
// Within each group, the processing order follows the sequence specified
// in their respective arrays.
#SQLRefs: {
	// SecretRefs holds a list of references to Secrets
	// +optional
	secretRefs?: [...api.#SecretKeySelector] @go(SecretRefs,[]github.com/cloudnative-pg/machinery/pkg/api.SecretKeySelector)

	// ConfigMapRefs holds a list of references to ConfigMaps
	// +optional
	configMapRefs?: [...api.#ConfigMapKeySelector] @go(ConfigMapRefs,[]github.com/cloudnative-pg/machinery/pkg/api.ConfigMapKeySelector)
}

// BootstrapRecovery contains the configuration required to restore
// from an existing cluster using 3 methodologies: external cluster,
// volume snapshots or backup objects. Full recovery and Point-In-Time
// Recovery are supported.
// The method can be also be used to create clusters in continuous recovery
// (replica clusters), also supporting cascading replication when `instances` >
// 1. Once the cluster exits recovery, the password for the superuser
// will be changed through the provided secret.
// Refer to the Bootstrap page of the documentation for more information.
#BootstrapRecovery: {
	// The backup object containing the physical base backup from which to
	// initiate the recovery procedure.
	// Mutually exclusive with `source` and `volumeSnapshots`.
	// +optional
	backup?: null | #BackupSource @go(Backup,*BackupSource)

	// The external cluster whose backup we will restore. This is also
	// used as the name of the folder under which the backup is stored,
	// so it must be set to the name of the source cluster
	// Mutually exclusive with `backup`.
	// +optional
	source?: string @go(Source)

	// The static PVC data source(s) from which to initiate the
	// recovery procedure. Currently supporting `VolumeSnapshot`
	// and `PersistentVolumeClaim` resources that map an existing
	// PVC group, compatible with CloudNativePG, and taken with
	// a cold backup copy on a fenced Postgres instance (limitation
	// which will be removed in the future when online backup
	// will be implemented).
	// Mutually exclusive with `backup`.
	// +optional
	volumeSnapshots?: null | #DataSource @go(VolumeSnapshots,*DataSource)

	// By default, the recovery process applies all the available
	// WAL files in the archive (full recovery). However, you can also
	// end the recovery as soon as a consistent state is reached or
	// recover to a point-in-time (PITR) by specifying a `RecoveryTarget` object,
	// as expected by PostgreSQL (i.e., timestamp, transaction Id, LSN, ...).
	// More info: https://www.postgresql.org/docs/current/runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET
	// +optional
	recoveryTarget?: null | #RecoveryTarget @go(RecoveryTarget,*RecoveryTarget)

	// Name of the database used by the application. Default: `app`.
	// +optional
	database?: string @go(Database)

	// Name of the owner of the database in the instance to be used
	// by applications. Defaults to the value of the `database` key.
	// +optional
	owner?: string @go(Owner)

	// Name of the secret containing the initial credentials for the
	// owner of the user database. If empty a new secret will be
	// created from scratch
	// +optional
	secret?: null | api.#LocalObjectReference @go(Secret,*github.com/cloudnative-pg/machinery/pkg/api.LocalObjectReference)
}

// DataSource contains the configuration required to bootstrap a
// PostgreSQL cluster from an existing storage
#DataSource: {
	// Configuration of the storage of the instances
	storage: corev1.#TypedLocalObjectReference @go(Storage)

	// Configuration of the storage for PostgreSQL WAL (Write-Ahead Log)
	// +optional
	walStorage?: null | corev1.#TypedLocalObjectReference @go(WalStorage,*corev1.TypedLocalObjectReference)

	// Configuration of the storage for PostgreSQL tablespaces
	// +optional
	tablespaceStorage?: {[string]: corev1.#TypedLocalObjectReference} @go(TablespaceStorage,map[string]corev1.TypedLocalObjectReference)
}

// BackupSource contains the backup we need to restore from, plus some
// information that could be needed to correctly restore it.
#BackupSource: {
	api.#LocalObjectReference

	// EndpointCA store the CA bundle of the barman endpoint.
	// Useful when using self-signed certificates to avoid
	// errors with certificate issuer and barman-cloud-wal-archive.
	// +optional
	endpointCA?: null | api.#SecretKeySelector @go(EndpointCA,*github.com/cloudnative-pg/machinery/pkg/api.SecretKeySelector)
}

// BootstrapPgBaseBackup contains the configuration required to take
// a physical backup of an existing PostgreSQL cluster
#BootstrapPgBaseBackup: {
	// The name of the server of which we need to take a physical backup
	// +kubebuilder:validation:MinLength=1
	source: string @go(Source)

	// Name of the database used by the application. Default: `app`.
	// +optional
	database?: string @go(Database)

	// Name of the owner of the database in the instance to be used
	// by applications. Defaults to the value of the `database` key.
	// +optional
	owner?: string @go(Owner)

	// Name of the secret containing the initial credentials for the
	// owner of the user database. If empty a new secret will be
	// created from scratch
	// +optional
	secret?: null | api.#LocalObjectReference @go(Secret,*github.com/cloudnative-pg/machinery/pkg/api.LocalObjectReference)
}

// RecoveryTarget allows to configure the moment where the recovery process
// will stop. All the target options except TargetTLI are mutually exclusive.
#RecoveryTarget: {
	// The ID of the backup from which to start the recovery process.
	// If empty (default) the operator will automatically detect the backup
	// based on targetTime or targetLSN if specified. Otherwise use the
	// latest available backup in chronological order.
	// +optional
	backupID?: string @go(BackupID)

	// The target timeline ("latest" or a positive integer)
	// +optional
	targetTLI?: string @go(TargetTLI)

	// The target transaction ID
	// +optional
	targetXID?: string @go(TargetXID)

	// The target name (to be previously created
	// with `pg_create_restore_point`)
	// +optional
	targetName?: string @go(TargetName)

	// The target LSN (Log Sequence Number)
	// +optional
	targetLSN?: string @go(TargetLSN)

	// The target time as a timestamp in the RFC3339 standard
	// +optional
	targetTime?: string @go(TargetTime)

	// End recovery as soon as a consistent state is reached
	// +optional
	targetImmediate?: null | bool @go(TargetImmediate,*bool)

	// Set the target to be exclusive. If omitted, defaults to false, so that
	// in Postgres, `recovery_target_inclusive` will be true
	// +optional
	exclusive?: null | bool @go(Exclusive,*bool)
}

// StorageConfiguration is the configuration used to create and reconcile PVCs,
// usable for WAL volumes, PGDATA volumes, or tablespaces
#StorageConfiguration: {
	// StorageClass to use for PVCs. Applied after
	// evaluating the PVC template, if available.
	// If not specified, the generated PVCs will use the
	// default storage class
	// +optional
	storageClass?: null | string @go(StorageClass,*string)

	// Size of the storage. Required if not already specified in the PVC template.
	// Changes to this field are automatically reapplied to the created PVCs.
	// Size cannot be decreased.
	// +optional
	size?: string @go(Size)

	// Resize existent PVCs, defaults to true
	// +optional
	// +kubebuilder:default:=true
	resizeInUseVolumes?: null | bool @go(ResizeInUseVolumes,*bool)

	// Template to be used to generate the Persistent Volume Claim
	// +optional
	pvcTemplate?: null | corev1.#PersistentVolumeClaimSpec @go(PersistentVolumeClaimTemplate,*corev1.PersistentVolumeClaimSpec)
}

// TablespaceConfiguration is the configuration of a tablespace, and includes
// the storage specification for the tablespace
#TablespaceConfiguration: {
	// The name of the tablespace
	name: string @go(Name)

	// The storage configuration for the tablespace
	storage: #StorageConfiguration @go(Storage)

	// Owner is the PostgreSQL user owning the tablespace
	// +optional
	owner?: #DatabaseRoleRef @go(Owner)

	// When set to true, the tablespace will be added as a `temp_tablespaces`
	// entry in PostgreSQL, and will be available to automatically house temp
	// database objects, or other temporary files. Please refer to PostgreSQL
	// documentation for more information on the `temp_tablespaces` GUC.
	// +optional
	// +kubebuilder:default:=false
	temporary?: bool @go(Temporary)
}

// DatabaseRoleRef is a reference an a role available inside PostgreSQL
#DatabaseRoleRef: {
	// +optional
	name?: string @go(Name)
}

// SyncReplicaElectionConstraints contains the constraints for sync replicas election.
//
// For anti-affinity parameters two instances are considered in the same location
// if all the labels values match.
//
// In future synchronous replica election restriction by name will be supported.
#SyncReplicaElectionConstraints: {
	// A list of node labels values to extract and compare to evaluate if the pods reside in the same topology or not
	// +optional
	nodeLabelsAntiAffinity?: [...string] @go(NodeLabelsAntiAffinity,[]string)

	// This flag enables the constraints for sync replicas
	enabled: bool @go(Enabled)
}

// AffinityConfiguration contains the info we need to create the
// affinity rules for Pods
#AffinityConfiguration: {
	// Activates anti-affinity for the pods. The operator will define pods
	// anti-affinity unless this field is explicitly set to false
	// +optional
	enablePodAntiAffinity?: null | bool @go(EnablePodAntiAffinity,*bool)

	// TopologyKey to use for anti-affinity configuration. See k8s documentation
	// for more info on that
	// +optional
	topologyKey?: string @go(TopologyKey)

	// NodeSelector is map of key-value pairs used to define the nodes on which
	// the pods can run.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	// +optional
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string)

	// NodeAffinity describes node affinity scheduling rules for the pod.
	// More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
	// +optional
	nodeAffinity?: null | corev1.#NodeAffinity @go(NodeAffinity,*corev1.NodeAffinity)

	// Tolerations is a list of Tolerations that should be set for all the pods, in order to allow them to run
	// on tainted nodes.
	// More info: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
	// +optional
	tolerations?: [...corev1.#Toleration] @go(Tolerations,[]corev1.Toleration)

	// PodAntiAffinityType allows the user to decide whether pod anti-affinity between cluster instance has to be
	// considered a strong requirement during scheduling or not. Allowed values are: "preferred" (default if empty) or
	// "required". Setting it to "required", could lead to instances remaining pending until new kubernetes nodes are
	// added if all the existing nodes don't match the required pod anti-affinity rule.
	// More info:
	// https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
	// +optional
	podAntiAffinityType?: string @go(PodAntiAffinityType)

	// AdditionalPodAntiAffinity allows to specify pod anti-affinity terms to be added to the ones generated
	// by the operator if EnablePodAntiAffinity is set to true (default) or to be used exclusively if set to false.
	// +optional
	additionalPodAntiAffinity?: null | corev1.#PodAntiAffinity @go(AdditionalPodAntiAffinity,*corev1.PodAntiAffinity)

	// AdditionalPodAffinity allows to specify pod affinity terms to be passed to all the cluster's pods.
	// +optional
	additionalPodAffinity?: null | corev1.#PodAffinity @go(AdditionalPodAffinity,*corev1.PodAffinity)
}

// BackupTarget describes the preferred targets for a backup
#BackupTarget: string // #enumBackupTarget

#enumBackupTarget:
	#BackupTargetPrimary |
	#BackupTargetStandby |
	#DefaultBackupTarget

// BackupTargetPrimary means backups will be performed on the primary instance
#BackupTargetPrimary: #BackupTarget & "primary"

// BackupTargetStandby means backups will be performed on a standby instance if available
#BackupTargetStandby: #BackupTarget & "prefer-standby"

// DefaultBackupTarget is the default BackupTarget
#DefaultBackupTarget: #BackupTarget & "prefer-standby"

// BackupConfiguration defines how the backup of the cluster are taken.
// The supported backup methods are BarmanObjectStore and VolumeSnapshot.
// For details and examples refer to the Backup and Recovery section of the
// documentation
#BackupConfiguration: {
	// VolumeSnapshot provides the configuration for the execution of volume snapshot backups.
	// +optional
	volumeSnapshot?: null | #VolumeSnapshotConfiguration @go(VolumeSnapshot,*VolumeSnapshotConfiguration)

	// The configuration for the barman-cloud tool suite
	// +optional
	barmanObjectStore?: null | api_1.#BarmanObjectStoreConfiguration @go(BarmanObjectStore,*github.com/cloudnative-pg/barman-cloud/pkg/api.BarmanObjectStoreConfiguration)

	// RetentionPolicy is the retention policy to be used for backups
	// and WALs (i.e. '60d'). The retention policy is expressed in the form
	// of `XXu` where `XX` is a positive integer and `u` is in `[dwm]` -
	// days, weeks, months.
	// It's currently only applicable when using the BarmanObjectStore method.
	// +kubebuilder:validation:Pattern=^[1-9][0-9]*[dwm]$
	// +optional
	retentionPolicy?: string @go(RetentionPolicy)

	// The policy to decide which instance should perform backups. Available
	// options are empty string, which will default to `prefer-standby` policy,
	// `primary` to have backups run always on primary instances, `prefer-standby`
	// to have backups run preferably on the most updated standby, if available.
	// +kubebuilder:validation:Enum=primary;prefer-standby
	// +kubebuilder:default:=prefer-standby
	// +optional
	target?: #BackupTarget @go(Target)
}

// MonitoringConfiguration is the type containing all the monitoring
// configuration for a certain cluster
#MonitoringConfiguration: {
	// Whether the default queries should be injected.
	// Set it to `true` if you don't want to inject default queries into the cluster.
	// Default: false.
	// +kubebuilder:default:=false
	// +optional
	disableDefaultQueries?: null | bool @go(DisableDefaultQueries,*bool)

	// The list of config maps containing the custom queries
	// +optional
	customQueriesConfigMap?: [...api.#ConfigMapKeySelector] @go(CustomQueriesConfigMap,[]github.com/cloudnative-pg/machinery/pkg/api.ConfigMapKeySelector)

	// The list of secrets containing the custom queries
	// +optional
	customQueriesSecret?: [...api.#SecretKeySelector] @go(CustomQueriesSecret,[]github.com/cloudnative-pg/machinery/pkg/api.SecretKeySelector)

	// Enable or disable the `PodMonitor`
	// +kubebuilder:default:=false
	// +optional
	enablePodMonitor?: bool @go(EnablePodMonitor)

	// Configure TLS communication for the metrics endpoint.
	// Changing tls.enabled option will force a rollout of all instances.
	// +optional
	tls?: null | #ClusterMonitoringTLSConfiguration @go(TLSConfig,*ClusterMonitoringTLSConfiguration)

	// The list of metric relabelings for the `PodMonitor`. Applied to samples before ingestion.
	// +optional
	podMonitorMetricRelabelings?: [...monitoringv1.#RelabelConfig] @go(PodMonitorMetricRelabelConfigs,[]monitoringv1.RelabelConfig)

	// The list of relabelings for the `PodMonitor`. Applied to samples before scraping.
	// +optional
	podMonitorRelabelings?: [...monitoringv1.#RelabelConfig] @go(PodMonitorRelabelConfigs,[]monitoringv1.RelabelConfig)
}

// ClusterMonitoringTLSConfiguration is the type containing the TLS configuration
// for the cluster's monitoring
#ClusterMonitoringTLSConfiguration: {
	// Enable TLS for the monitoring endpoint.
	// Changing this option will force a rollout of all instances.
	// +kubebuilder:default:=false
	// +optional
	enabled?: bool @go(Enabled)
}

// ExternalCluster represents the connection parameters to an
// external cluster which is used in the other sections of the configuration
#ExternalCluster: {
	// The server name, required
	name: string @go(Name)

	// The list of connection parameters, such as dbname, host, username, etc
	// +optional
	connectionParameters?: {[string]: string} @go(ConnectionParameters,map[string]string)

	// The reference to an SSL certificate to be used to connect to this
	// instance
	// +optional
	sslCert?: null | corev1.#SecretKeySelector @go(SSLCert,*corev1.SecretKeySelector)

	// The reference to an SSL private key to be used to connect to this
	// instance
	// +optional
	sslKey?: null | corev1.#SecretKeySelector @go(SSLKey,*corev1.SecretKeySelector)

	// The reference to an SSL CA public key to be used to connect to this
	// instance
	// +optional
	sslRootCert?: null | corev1.#SecretKeySelector @go(SSLRootCert,*corev1.SecretKeySelector)

	// The reference to the password to be used to connect to the server.
	// If a password is provided, CloudNativePG creates a PostgreSQL
	// passfile at `/controller/external/NAME/pass` (where "NAME" is the
	// cluster's name). This passfile is automatically referenced in the
	// connection string when establishing a connection to the remote
	// PostgreSQL server from the current PostgreSQL `Cluster`. This ensures
	// secure and efficient password management for external clusters.
	// +optional
	password?: null | corev1.#SecretKeySelector @go(Password,*corev1.SecretKeySelector)

	// The configuration for the barman-cloud tool suite
	// +optional
	barmanObjectStore?: null | api_1.#BarmanObjectStoreConfiguration @go(BarmanObjectStore,*github.com/cloudnative-pg/barman-cloud/pkg/api.BarmanObjectStoreConfiguration)

	// The configuration of the plugin that is taking care
	// of WAL archiving and backups for this external cluster
	plugin?: null | #PluginConfiguration @go(PluginConfiguration,*PluginConfiguration)
}

// EnsureOption represents whether we should enforce the presence or absence of
// a Role in a PostgreSQL instance
#EnsureOption: string // #enumEnsureOption

#enumEnsureOption:
	#EnsurePresent |
	#EnsureAbsent

#EnsurePresent: #EnsureOption & "present"
#EnsureAbsent:  #EnsureOption & "absent"

// ServiceSelectorType describes a valid value for generating the service selectors.
// It indicates which type of service the selector applies to, such as read-write, read, or read-only
// +kubebuilder:validation:Enum=rw;r;ro
#ServiceSelectorType: string // #enumServiceSelectorType

#enumServiceSelectorType:
	#ServiceSelectorTypeRW |
	#ServiceSelectorTypeR |
	#ServiceSelectorTypeRO

// ServiceSelectorTypeRW selects the read-write service.
#ServiceSelectorTypeRW: #ServiceSelectorType & "rw"

// ServiceSelectorTypeR selects the read service.
#ServiceSelectorTypeR: #ServiceSelectorType & "r"

// ServiceSelectorTypeRO selects the read-only service.
#ServiceSelectorTypeRO: #ServiceSelectorType & "ro"

// ServiceUpdateStrategy describes how the changes to the managed service should be handled
// +kubebuilder:validation:Enum=patch;replace
#ServiceUpdateStrategy: string

// ServiceUpdateStrategyPatch applies a patch deriving from the differences of the actual service and the expect one
#ServiceUpdateStrategyPatch: "patch"

// ServiceUpdateStrategyReplace deletes the existing service and recreates it when a difference is detected
#ServiceUpdateStrategyReplace: "replace"

// ManagedServices represents the services managed by the cluster.
#ManagedServices: {
	// DisabledDefaultServices is a list of service types that are disabled by default.
	// Valid values are "r", and "ro", representing read, and read-only services.
	// +optional
	disabledDefaultServices?: [...#ServiceSelectorType] @go(DisabledDefaultServices,[]ServiceSelectorType)

	// Additional is a list of additional managed services specified by the user.
	// +optional
	additional?: [...#ManagedService] @go(Additional,[]ManagedService)
}

// ManagedService represents a specific service managed by the cluster.
// It includes the type of service and its associated template specification.
#ManagedService: {
	// SelectorType specifies the type of selectors that the service will have.
	// Valid values are "rw", "r", and "ro", representing read-write, read, and read-only services.
	selectorType: #ServiceSelectorType @go(SelectorType)

	// UpdateStrategy describes how the service differences should be reconciled
	// +kubebuilder:default:="patch"
	// +optional
	updateStrategy?: #ServiceUpdateStrategy @go(UpdateStrategy)

	// ServiceTemplate is the template specification for the service.
	serviceTemplate: #ServiceTemplateSpec @go(ServiceTemplate)
}

// ManagedConfiguration represents the portions of PostgreSQL that are managed
// by the instance manager
#ManagedConfiguration: {
	// Database roles managed by the `Cluster`
	// +optional
	roles?: [...#RoleConfiguration] @go(Roles,[]RoleConfiguration)

	// Services roles managed by the `Cluster`
	// +optional
	services?: null | #ManagedServices @go(Services,*ManagedServices)
}

// PluginConfiguration specifies a plugin that need to be loaded for this
// cluster to be reconciled
#PluginConfiguration: {
	// Name is the plugin name
	name: string @go(Name)

	// Enabled is true if this plugin will be used
	// +kubebuilder:default:=true
	// +optional
	enabled?: null | bool @go(Enabled,*bool)

	// Only one plugin can be declared as WALArchiver.
	// Cannot be active if ".spec.backup.barmanObjectStore" configuration is present.
	// +kubebuilder:default:=false
	// +optional
	isWALArchiver?: null | bool @go(IsWALArchiver,*bool)

	// Parameters is the configuration of the plugin
	// +optional
	parameters?: {[string]: string} @go(Parameters,map[string]string)
}

// PluginStatus is the status of a loaded plugin
#PluginStatus: {
	// Name is the name of the plugin
	name: string @go(Name)

	// Version is the version of the plugin loaded by the
	// latest reconciliation loop
	version: string @go(Version)

	// Capabilities are the list of capabilities of the
	// plugin
	// +optional
	capabilities?: [...string] @go(Capabilities,[]string)

	// OperatorCapabilities are the list of capabilities of the
	// plugin regarding the reconciler
	// +optional
	operatorCapabilities?: [...string] @go(OperatorCapabilities,[]string)

	// WALCapabilities are the list of capabilities of the
	// plugin regarding the WAL management
	// +optional
	walCapabilities?: [...string] @go(WALCapabilities,[]string)

	// BackupCapabilities are the list of capabilities of the
	// plugin regarding the Backup management
	// +optional
	backupCapabilities?: [...string] @go(BackupCapabilities,[]string)

	// RestoreJobHookCapabilities are the list of capabilities of the
	// plugin regarding the RestoreJobHook management
	// +optional
	restoreJobHookCapabilities?: [...string] @go(RestoreJobHookCapabilities,[]string)

	// Status contain the status reported by the plugin through the SetStatusInCluster interface
	// +optional
	status?: string @go(Status)
}

// RoleConfiguration is the representation, in Kubernetes, of a PostgreSQL role
// with the additional field Ensure specifying whether to ensure the presence or
// absence of the role in the database
//
// The defaults of the CREATE ROLE command are applied
// Reference: https://www.postgresql.org/docs/current/sql-createrole.html
#RoleConfiguration: {
	// Name of the role
	name: string @go(Name)

	// Description of the role
	// +optional
	comment?: string @go(Comment)

	// Ensure the role is `present` or `absent` - defaults to "present"
	// +kubebuilder:default:="present"
	// +kubebuilder:validation:Enum=present;absent
	// +optional
	ensure?: #EnsureOption @go(Ensure)

	// Secret containing the password of the role (if present)
	// If null, the password will be ignored unless DisablePassword is set
	// +optional
	passwordSecret?: null | api.#LocalObjectReference @go(PasswordSecret,*github.com/cloudnative-pg/machinery/pkg/api.LocalObjectReference)

	// If the role can log in, this specifies how many concurrent
	// connections the role can make. `-1` (the default) means no limit.
	// +kubebuilder:default:=-1
	// +optional
	connectionLimit?: int64 @go(ConnectionLimit)

	// Date and time after which the role's password is no longer valid.
	// When omitted, the password will never expire (default).
	// +optional
	validUntil?: null | metav1.#Time @go(ValidUntil,*metav1.Time)

	// List of one or more existing roles to which this role will be
	// immediately added as a new member. Default empty.
	// +optional
	inRoles?: [...string] @go(InRoles,[]string)

	// Whether a role "inherits" the privileges of roles it is a member of.
	// Defaults is `true`.
	// +kubebuilder:default:=true
	// +optional
	inherit?: null | bool @go(Inherit,*bool)

	// DisablePassword indicates that a role's password should be set to NULL in Postgres
	// +optional
	disablePassword?: bool @go(DisablePassword)

	// Whether the role is a `superuser` who can override all access
	// restrictions within the database - superuser status is dangerous and
	// should be used only when really needed. You must yourself be a
	// superuser to create a new superuser. Defaults is `false`.
	// +optional
	superuser?: bool @go(Superuser)

	// When set to `true`, the role being defined will be allowed to create
	// new databases. Specifying `false` (default) will deny a role the
	// ability to create databases.
	// +optional
	createdb?: bool @go(CreateDB)

	// Whether the role will be permitted to create, alter, drop, comment
	// on, change the security label for, and grant or revoke membership in
	// other roles. Default is `false`.
	// +optional
	createrole?: bool @go(CreateRole)

	// Whether the role is allowed to log in. A role having the `login`
	// attribute can be thought of as a user. Roles without this attribute
	// are useful for managing database privileges, but are not users in
	// the usual sense of the word. Default is `false`.
	// +optional
	login?: bool @go(Login)

	// Whether a role is a replication role. A role must have this
	// attribute (or be a superuser) in order to be able to connect to the
	// server in replication mode (physical or logical replication) and in
	// order to be able to create or drop replication slots. A role having
	// the `replication` attribute is a very highly privileged role, and
	// should only be used on roles actually used for replication. Default
	// is `false`.
	// +optional
	replication?: bool @go(Replication)

	// Whether a role bypasses every row-level security (RLS) policy.
	// Default is `false`.
	// +optional
	bypassrls?: bool @go(BypassRLS)
}

// Cluster is the Schema for the PostgreSQL API
#Cluster: {
	metav1.#TypeMeta
	metadata: metav1.#ObjectMeta @go(ObjectMeta)

	// Specification of the desired behavior of the cluster.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	spec: #ClusterSpec @go(Spec)

	// Most recently observed status of the cluster. This data may not be up
	// to date. Populated by the system. Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	status?: #ClusterStatus @go(Status)
}

// ClusterList contains a list of Cluster
#ClusterList: {
	metav1.#TypeMeta

	// Standard list metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta)

	// List of clusters
	items: [...#Cluster] @go(Items,[]Cluster)
}

// SecretsResourceVersion is the resource versions of the secrets
// managed by the operator
#SecretsResourceVersion: {
	// The resource version of the "postgres" user secret
	// +optional
	superuserSecretVersion?: string @go(SuperuserSecretVersion)

	// The resource version of the "streaming_replica" user secret
	// +optional
	replicationSecretVersion?: string @go(ReplicationSecretVersion)

	// The resource version of the "app" user secret
	// +optional
	applicationSecretVersion?: string @go(ApplicationSecretVersion)

	// The resource versions of the managed roles secrets
	// +optional
	managedRoleSecretVersion?: {[string]: string} @go(ManagedRoleSecretVersions,map[string]string)

	// Unused. Retained for compatibility with old versions.
	// +optional
	caSecretVersion?: string @go(CASecretVersion)

	// The resource version of the PostgreSQL client-side CA secret version
	// +optional
	clientCaSecretVersion?: string @go(ClientCASecretVersion)

	// The resource version of the PostgreSQL server-side CA secret version
	// +optional
	serverCaSecretVersion?: string @go(ServerCASecretVersion)

	// The resource version of the PostgreSQL server-side secret version
	// +optional
	serverSecretVersion?: string @go(ServerSecretVersion)

	// The resource version of the Barman Endpoint CA if provided
	// +optional
	barmanEndpointCA?: string @go(BarmanEndpointCA)

	// The resource versions of the external cluster secrets
	// +optional
	externalClusterSecretVersion?: {[string]: string} @go(ExternalClusterSecretVersions,map[string]string)

	// A map with the versions of all the secrets used to pass metrics.
	// Map keys are the secret names, map values are the versions
	// +optional
	metrics?: {[string]: string} @go(Metrics,map[string]string)
}

// ConfigMapResourceVersion is the resource versions of the secrets
// managed by the operator
#ConfigMapResourceVersion: {
	// A map with the versions of all the config maps used to pass metrics.
	// Map keys are the config map names, map values are the versions
	// +optional
	metrics?: {[string]: string} @go(Metrics,map[string]string)
}
