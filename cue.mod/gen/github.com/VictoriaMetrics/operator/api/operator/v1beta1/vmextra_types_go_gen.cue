// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/VictoriaMetrics/operator/api/operator/v1beta1

package v1beta1

import (
	"k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	autoscalingv2 "k8s.io/api/autoscaling/v2"
)

// UpdateStatus defines status for application
#UpdateStatus: string // #enumUpdateStatus

#enumUpdateStatus:
	#UpdateStatusExpanding |
	#UpdateStatusOperational |
	#UpdateStatusFailed |
	#UpdateStatusPaused

#UpdateStatusExpanding:   #UpdateStatus & "expanding"
#UpdateStatusOperational: #UpdateStatus & "operational"
#UpdateStatusFailed:      #UpdateStatus & "failed"
#UpdateStatusPaused:      #UpdateStatus & "paused"

_#vmPathPrefixFlagName: "http.pathPrefix"
_#healthPath:           "/health"
_#metricPath:           "/metrics"
_#reloadPath:           "/-/reload"
_#reloadAuthKey:        "reloadAuthKey"
_#snapshotCreate:       "/snapshot/create"
_#snapshotDelete:       "/snapshot/delete"

// FinalizerName name of vm-operator finalizer.
#FinalizerName:            "apps.victoriametrics.com/finalizer"
#SkipValidationAnnotation: "operator.victoriametrics.com/skip-validation"
#APIGroup:                 "operator.victoriametrics.com"
#SkipValidationValue:      "true"
#AdditionalServiceLabel:   "operator.victoriametrics.com/additional-service"

// PVCExpandableLabel controls checks for storageClass
#PVCExpandableLabel:             "operator.victoriametrics.com/pvc-allow-volume-expansion"
_#lastAppliedSpecAnnotationName: "operator.victoriametrics/last-applied-spec"

#SecretsDir:          "/etc/vm/secrets"
#ConfigMapsDir:       "/etc/vm/configs"
#TemplatesDir:        "/etc/vm/templates"
#StreamAggrConfigDir: "/etc/vm/stream-aggr"
#RelabelingConfigDir: "/etc/vm/relabeling"

// ConditionParsingReason defines reason for child objects
#ConditionParsingReason: "ConfigParsedAndApplied"

// ConditionDomainTypeAppliedSuffix defines type suffix for ConditionParsingReason reason
#ConditionDomainTypeAppliedSuffix: ".victoriametrics.com/Applied"

// EmbeddedObjectMetadata contains a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta
// Only fields which are relevant to embedded resources are included.
#EmbeddedObjectMetadata: {
	// Name must be unique within a namespace. Is required when creating resources, although
	// some resources may allow a client to request the generation of an appropriate name
	// automatically. Name is primarily intended for creation idempotence and configuration
	// definition.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
	// +optional
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// Labels Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
	// +operator-sdk:gen-csv:customresourcedefinitions.specDescriptors=true
	// +operator-sdk:gen-csv:customresourcedefinitions.specDescriptors.displayName="PodLabels"
	// +operator-sdk:gen-csv:customresourcedefinitions.specDescriptors.x-descriptors="urn:alm:descriptor:com.tectonic.ui:label"
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string) @protobuf(11,bytes,rep)

	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string) @protobuf(12,bytes,rep)
}

// StorageSpec defines the configured storage for a group Prometheus servers.
// If neither `emptyDir` nor `volumeClaimTemplate` is specified, then by default an [EmptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) will be used.
// +k8s:openapi-gen=true
#StorageSpec: {
	// Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
	// DisableMountSubPath allows to remove any subPath usage in volume mounts.
	// +optional
	disableMountSubPath?: bool @go(DisableMountSubPath)

	// EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
	// info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
	// +optional
	emptyDir?: null | v1.#EmptyDirVolumeSource @go(EmptyDir,*v1.EmptyDirVolumeSource)

	// A PVC spec to be used by the VMAlertManager StatefulSets.
	// +optional
	volumeClaimTemplate?: #EmbeddedPersistentVolumeClaim @go(VolumeClaimTemplate)
}

// EmbeddedPersistentVolumeClaim is an embedded version of k8s.io/api/core/v1.PersistentVolumeClaim.
// It contains TypeMeta and a reduced ObjectMeta.
#EmbeddedPersistentVolumeClaim: {
	metav1.#TypeMeta

	// EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
	// +optional
	metadata?: #EmbeddedObjectMetadata @go(EmbeddedObjectMetadata) @protobuf(1,bytes,opt)

	// Spec defines the desired characteristics of a volume requested by a pod author.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	// +optional
	spec?: v1.#PersistentVolumeClaimSpec @go(Spec) @protobuf(2,bytes,opt)

	// Status represents the current information/status of a persistent volume claim.
	// Read-only.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	// +optional
	status?: v1.#PersistentVolumeClaimStatus @go(Status) @protobuf(3,bytes,opt)
}

// HTTPAuth generic auth used with http protocols
#HTTPAuth: {
	// +optional
	basicAuth?: null | #BasicAuth @go(BasicAuth,*BasicAuth)

	// +optional
	oauth2?: null | #OAuth2 @go(OAuth2,*OAuth2)

	// +optional
	tlsConfig?: null | #TLSConfig @go(TLSConfig,*TLSConfig)

	#BearerAuth

	// Headers allow configuring custom http headers
	// Must be in form of semicolon separated header with value
	// e.g.
	// headerName:headerValue
	// vmalert supports it since 1.79.0 version
	// +optional
	headers?: [...string] @go(Headers,[]string)
}

// BearerAuth defines auth with bearer token
#BearerAuth: {
	// Path to bearer token file
	// +optional
	bearerTokenFile?: string @go(TokenFilePath)

	// Optional bearer auth token to use for -remoteWrite.url
	// +optional
	bearerTokenSecret?: null | v1.#SecretKeySelector @go(TokenSecret,*v1.SecretKeySelector)
}

// BasicAuth allow an endpoint to authenticate over basic authentication
// +k8s:openapi-gen=true
#BasicAuth: {
	// Username defines reference for secret with username value
	// The secret needs to be in the same namespace as scrape object
	// +optional
	username?: v1.#SecretKeySelector @go(Username)

	// Password defines reference for secret with password value
	// The secret needs to be in the same namespace as scrape object
	// +optional
	password?: v1.#SecretKeySelector @go(Password)

	// PasswordFile defines path to password file at disk
	// must be pre-mounted
	// +optional
	password_file?: string @go(PasswordFile)
}

// ServiceSpec defines additional service for CRD with user-defined params.
// by default, some of fields can be inherited from default service definition for the CRD:
// labels,selector, ports.
// if metadata.name is not defined, service will have format {{CRD_TYPE}}-{{CRD_NAME}}-additional-service.
// if UseAsDefault is set to true, changes applied to the main service without additional service creation
// +k8s:openapi-gen=true
#AdditionalServiceSpec: {
	// UseAsDefault applies changes from given service definition to the main object Service
	// Changing from headless service to clusterIP or loadbalancer may break cross-component communication
	// +optional
	useAsDefault?: bool @go(UseAsDefault)

	// EmbeddedObjectMetadata defines objectMeta for additional service.
	// +optional
	metadata?: #EmbeddedObjectMetadata @go(EmbeddedObjectMetadata)

	// ServiceSpec describes the attributes that a user creates on a service.
	// More info: https://kubernetes.io/docs/concepts/services-networking/service/
	spec: v1.#ServiceSpec @go(Spec)
}

#EmbeddedPodDisruptionBudgetSpec: {
	// An eviction is allowed if at least "minAvailable" pods selected by
	// "selector" will still be available after the eviction, i.e. even in the
	// absence of the evicted pod.  So for example you can prevent all voluntary
	// evictions by specifying "100%".
	// +optional
	minAvailable?: null | intstr.#IntOrString @go(MinAvailable,*intstr.IntOrString)

	// An eviction is allowed if at most "maxUnavailable" pods selected by
	// "selector" are unavailable after the eviction, i.e. even in absence of
	// the evicted pod. For example, one can prevent all voluntary evictions
	// by specifying 0. This is a mutually exclusive setting with "minAvailable".
	// +optional
	maxUnavailable?: null | intstr.#IntOrString @go(MaxUnavailable,*intstr.IntOrString)

	// replaces default labels selector generated by operator
	// it's useful when you need to create custom budget
	// +optional
	selectorLabels?: {[string]: string} @go(SelectorLabels,map[string]string)
}

// EmbeddedProbes - it allows to override some probe params.
// its not necessary to specify all options,
// operator will replace missing spec with default values.
#EmbeddedProbes: {
	// LivenessProbe that will be added CRD pod
	// +optional
	livenessProbe?: null | v1.#Probe @go(LivenessProbe,*v1.Probe)

	// ReadinessProbe that will be added CRD pod
	// +optional
	readinessProbe?: null | v1.#Probe @go(ReadinessProbe,*v1.Probe)

	// StartupProbe that will be added to CRD pod
	// +optional
	startupProbe?: null | v1.#Probe @go(StartupProbe,*v1.Probe)
}

// EmbeddedHPA embeds HorizontalPodAutoScaler spec v2.
// https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/horizontal-pod-autoscaler-v2/
#EmbeddedHPA: {
	minReplicas?: null | int32 @go(MinReplicas,*int32)
	maxReplicas?: int32        @go(MaxReplicas)
	metrics?: [...autoscalingv2.#MetricSpec] @go(Metrics,[]autoscalingv2.MetricSpec)
	behaviour?: null | autoscalingv2.#HorizontalPodAutoscalerBehavior @go(Behaviour,*autoscalingv2.HorizontalPodAutoscalerBehavior)
}

// DiscoverySelector can be used at CRD components discovery
#DiscoverySelector: {
	namespaceSelector?: null | #NamespaceSelector    @go(Namespace,*NamespaceSelector)
	labelSelector?:     null | metav1.#LabelSelector @go(Labels,*metav1.LabelSelector)
}

// ConfigMapKeyReference refers to a key in a ConfigMap.
#ConfigMapKeyReference: {
	v1.#LocalObjectReference

	// The ConfigMap key to refer to.
	key: string @go(Key)
}

// StreamAggrConfig defines the stream aggregation config
// +k8s:openapi-gen=true
#StreamAggrConfig: {
	// Stream aggregation rules
	// +optional
	rules?: [...#StreamAggrRule] @go(Rules,[]StreamAggrRule)

	// ConfigMap with stream aggregation rules
	// +optional
	configmap?: null | v1.#ConfigMapKeySelector @go(RuleConfigMap,*v1.ConfigMapKeySelector)

	// Allows writing both raw and aggregate data
	// +optional
	keepInput?: bool @go(KeepInput)

	// Allow drop all the input samples after the aggregation
	// +optional
	dropInput?: bool @go(DropInput)

	// Allows setting different de-duplication intervals per each configured remote storage
	// +optional
	dedupInterval?: string @go(DedupInterval)

	// labels to drop from samples for aggregator before stream de-duplication and aggregation
	// +optional
	dropInputLabels?: [...string] @go(DropInputLabels,[]string)

	// IgnoreFirstIntervals instructs to ignore first interval
	// +optional
	ignoreFirstIntervals?: int @go(IgnoreFirstIntervals)

	// IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.
	// +optional
	ignoreOldSamples?: bool @go(IgnoreOldSamples)
}

// StreamAggrRule defines the rule in stream aggregation config
// +k8s:openapi-gen=true
#StreamAggrRule: {
	// Match is a label selector (or list of label selectors) for filtering time series for the given selector.
	//
	// If the match isn't set, then all the input time series are processed.
	// +optional
	// +kubebuilder:validation:Schemaless
	// +kubebuilder:pruning:PreserveUnknownFields
	match?: #StringOrArray @go(Match)

	// Interval is the interval between aggregations.
	interval: string @go(Interval)

	// NoAlignFlushToInterval disables aligning of flushes to multiples of Interval.
	// By default flushes are aligned to Interval.
	// +optional
	no_align_flush_to_interval?: null | bool @go(NoAlignFlushToInterval,*bool)

	// FlushOnShutdown defines whether to flush the aggregation state on process termination
	// or config reload. Is `false` by default.
	// It is not recommended changing this setting, unless unfinished aggregations states
	// are preferred to missing data points.
	// +optional
	flush_on_shutdown?: bool @go(FlushOnShutdown)

	// DedupInterval is an optional interval for deduplication.
	// +optional
	dedup_interval?: string @go(DedupInterval)

	// Staleness interval is interval after which the series state will be reset if no samples have been sent during it.
	// The parameter is only relevant for outputs: total, total_prometheus, increase, increase_prometheus and histogram_bucket.
	// +optional
	staleness_interval?: string @go(StalenessInterval)

	// Outputs is a list of output aggregate functions to produce.
	//
	// The following names are allowed:
	//
	// - total - aggregates input counters
	// - increase - counts the increase over input counters
	// - count_series - counts the input series
	// - count_samples - counts the input samples
	// - sum_samples - sums the input samples
	// - last - the last biggest sample value
	// - min - the minimum sample value
	// - max - the maximum sample value
	// - avg - the average value across all the samples
	// - stddev - standard deviation across all the samples
	// - stdvar - standard variance across all the samples
	// - histogram_bucket - creates VictoriaMetrics histogram for input samples
	// - quantiles(phi1, ..., phiN) - quantiles' estimation for phi in the range [0..1]
	//
	// The output time series will have the following names:
	//
	//   input_name:aggr_<interval>_<output>
	//
	outputs: [...string] @go(Outputs,[]string)

	// KeepMetricNames instructs to leave metric names as is for the output time series without adding any suffix.
	// +optional
	keep_metric_names?: null | bool @go(KeepMetricNames,*bool)

	// IgnoreOldSamples instructs to ignore samples with old timestamps outside the current aggregation interval.
	// +optional
	ignore_old_samples?: null | bool @go(IgnoreOldSamples,*bool)

	// By is an optional list of labels for grouping input series.
	//
	// See also Without.
	//
	// If neither By nor Without are set, then the Outputs are calculated
	// individually per each input time series.
	// +optional
	by?: [...string] @go(By,[]string)

	// Without is an optional list of labels, which must be excluded when grouping input series.
	//
	// See also By.
	//
	// If neither By nor Without are set, then the Outputs are calculated
	// individually per each input time series.
	// +optional
	without?: [...string] @go(Without,[]string)
	ignore_first_intervals?: null | int @go(IgnoreFirstIntervals,*int)

	// DropInputLabels is an optional list with labels, which must be dropped before further processing of input samples.
	//
	// Labels are dropped before de-duplication and aggregation.
	// +optional
	drop_input_labels?: null | [...string] @go(DropInputLabels,*[]string)

	// InputRelabelConfigs is an optional relabeling rules, which are applied on the input
	// before aggregation.
	// +optional
	input_relabel_configs?: [...#RelabelConfig] @go(InputRelabelConfigs,[]RelabelConfig)

	// OutputRelabelConfigs is an optional relabeling rules, which are applied
	// on the aggregated output before being sent to remote storage.
	// +optional
	output_relabel_configs?: [...#RelabelConfig] @go(OutputRelabelConfigs,[]RelabelConfig)
}

// KeyValue defines a (key, value) tuple.
// +kubebuilder:object:generate=false
// +k8s:openapi-gen=false
#KeyValue: {
	// Key of the tuple.
	// +kubebuilder:validation:MinLength=1
	key: string @go(Key)

	// Value of the tuple.
	value: string @go(Value)
}

// StringOrArray is a helper type for storing string or array of string.
#StringOrArray: _

// License holds license key for enterprise features.
// Using license key is supported starting from VictoriaMetrics v1.94.0.
// See [here](https://docs.victoriametrics.com/enterprise)
#License: {
	// Enterprise license key. This flag is available only in [VictoriaMetrics enterprise](https://docs.victoriametrics.com/enterprise).
	// To request a trial license, [go to](https://victoriametrics.com/products/enterprise/trial)
	key?: null | string @go(Key,*string)

	// KeyRef is reference to secret with license key for enterprise features.
	keyRef?: null | v1.#SecretKeySelector @go(KeyRef,*v1.SecretKeySelector)

	// Enforce offline verification of the license key.
	forceOffline?: null | bool @go(ForceOffline,*bool)

	// Interval to be used for checking for license key changes. Note that this is only applicable when using KeyRef.
	reloadInterval?: null | string @go(ReloadInterval,*string)
}

// SecretOrConfigMap allows to specify data as a Secret or ConfigMap. Fields are mutually exclusive.
#SecretOrConfigMap: {
	// Secret containing data to use for the targets.
	// +optional
	secret?: null | v1.#SecretKeySelector @go(Secret,*v1.SecretKeySelector)

	// ConfigMap containing data to use for the targets.
	// +optional
	configMap?: null | v1.#ConfigMapKeySelector @go(ConfigMap,*v1.ConfigMapKeySelector)
}

// TLSConfig specifies TLSConfig configuration parameters.
// +k8s:openapi-gen=true
#TLSConfig: {
	// Path to the CA cert in the container to use for the targets.
	// +optional
	caFile?: string @go(CAFile)

	// Stuct containing the CA cert to use for the targets.
	// +optional
	ca?: #SecretOrConfigMap @go(CA)

	// Path to the client cert file in the container for the targets.
	// +optional
	certFile?: string @go(CertFile)

	// Struct containing the client cert file for the targets.
	// +optional
	cert?: #SecretOrConfigMap @go(Cert)

	// Path to the client key file in the container for the targets.
	// +optional
	keyFile?: string @go(KeyFile)

	// Secret containing the client key file for the targets.
	// +optional
	keySecret?: null | v1.#SecretKeySelector @go(KeySecret,*v1.SecretKeySelector)

	// Used to verify the hostname for the targets.
	// +optional
	serverName?: string @go(ServerName)

	// Disable target certificate validation.
	// +optional
	insecureSkipVerify?: bool @go(InsecureSkipVerify)
}

// Certs defines TLS certs configuration
#Certs: {
	// CertSecretRef defines reference for secret with certificate content under given key
	// mutually exclusive with CertFile
	// +optional
	cert_secret_ref?: null | v1.#SecretKeySelector @go(CertSecretRef,*v1.SecretKeySelector)

	// CertFile defines path to the pre-mounted file with certificate
	// mutually exclusive with CertSecretRef
	// +optional
	cert_file?: string @go(CertFile)

	// Key defines reference for secret with certificate key content under given key
	// mutually exclusive with KeyFile
	// +optional
	key_secret_ref?: null | v1.#SecretKeySelector @go(KeySecretRef,*v1.SecretKeySelector)

	// KeyFile defines path to the pre-mounted file with certificate key
	// mutually exclusive with KeySecretRef
	// +optional
	key_file?: string @go(KeyFile)
}

// TLSServerConfig defines TLS configuration for the application's server
#TLSServerConfig: {
	// ClientCASecretRef defines reference for secret with CA content under given key
	// mutually exclusive with ClientCAFile
	// +optional
	client_ca_secret_ref?: null | v1.#SecretKeySelector @go(ClientCASecretRef,*v1.SecretKeySelector)

	// ClientCAFile defines path to the pre-mounted file with CA
	// mutually exclusive with ClientCASecretRef
	// +optional
	client_ca_file?: string @go(ClientCAFile)

	// Cert defines reference for secret with CA content under given key
	// mutually exclusive with CertFile
	// ClientAuthType defines server policy for client authentication
	// If you want to enable client authentication (aka mTLS), you need to use RequireAndVerifyClientCert
	// Note, mTLS is supported only at enterprise version of VictoriaMetrics components
	// +optional
	// +kubebuilder:validation:Enum=NoClientCert;RequireAndVerifyClientCert
	client_auth_type?: string @go(ClientAuthType)

	// MinVersion minimum TLS version that is acceptable.
	// +optional
	// +kubebuilder:validation:Enum=TLS10;TLS11;TLS12;TLS13
	min_version?: string @go(MinVersion)

	// MaxVersion maximum TLS version that is acceptable.
	// +optional
	// +kubebuilder:validation:Enum=TLS10;TLS11;TLS12;TLS13
	max_version?: string @go(MaxVersion)

	// CipherSuites defines list of supported cipher suites for TLS versions up to TLS 1.2
	// https://golang.org/pkg/crypto/tls/#pkg-constants
	// +optional
	cipher_suites?: [...string] @go(CipherSuites,[]string)

	// CurvePreferences defines elliptic curves that will be used in an ECDHE handshake, in preference order.
	// https://golang.org/pkg/crypto/tls/#CurveID
	// +optional
	curve_preferences?: [...string] @go(CurvePreferences,[]string)

	// PreferServerCipherSuites controls whether the server selects the
	// client's most preferred ciphersuite
	// +optional
	prefer_server_cipher_suites?: bool @go(PreferServerCipherSuites)

	#Certs
}

// TLSClientConfig defines TLS configuration for the application's client
#TLSClientConfig: {
	// CA defines reference for secret with CA content under given key
	// mutually exclusive with CAFile
	// +optional
	ca_secret_ref?: null | v1.#SecretKeySelector @go(CASecretRef,*v1.SecretKeySelector)

	// CAFile defines path to the pre-mounted file with CA
	// mutually exclusive with CASecretRef
	// +optional
	ca_file?: string @go(CAFile)

	// Cert defines reference for secret with CA content under given key
	// mutually exclusive with CertFile
	// +optional
	insecure_skip_verify?: bool @go(InsecureSkipVerify)

	// ServerName indicates a name of a server
	// +optional
	server_name?: string @go(ServerName)

	#Certs
}

// ScrapeObjectStatus defines the observed state of ScrapeObjects
#ScrapeObjectStatus: {
	#StatusMetadata
}

_#objectWithLastAppliedState: _

// CommonDefaultableParams contains Application settings
// with known values populated from operator configuration
#CommonDefaultableParams: {
	// Image - docker image settings
	// if no specified operator uses default version from operator config
	// +optional
	image?: #Image @go(Image)

	// Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// if not defined default resources from operator config will be used
	// +operator-sdk:csv:customresourcedefinitions:type=spec,displayName="Resources",xDescriptors="urn:alm:descriptor:com.tectonic.ui:resourceRequirements"
	// +optional
	resources?: v1.#ResourceRequirements @go(Resources)

	// UseDefaultResources controls resource settings
	// By default, operator sets built-in resource requirements
	// +optional
	useDefaultResources?: null | bool @go(UseDefaultResources,*bool)

	// Port listen address
	// +optional
	port?: string @go(Port)

	// UseStrictSecurity enables strict security mode for component
	// it restricts disk writes access
	// uses non-root user out of the box
	// drops not needed security permissions
	// +optional
	useStrictSecurity?: null | bool @go(UseStrictSecurity,*bool)

	// DisableSelfServiceScrape controls creation of VMServiceScrape by operator
	// for the application.
	// Has priority over `VM_DISABLESELFSERVICESCRAPECREATION` operator env variable
	// +optional
	disableSelfServiceScrape?: null | bool @go(DisableSelfServiceScrape,*bool)
}

#CommonConfigReloaderParams: {
	// UseVMConfigReloader replaces prometheus-like config-reloader
	// with vm one. It uses secrets watch instead of file watch
	// which greatly increases speed of config updates
	// +optional
	useVMConfigReloader?: null | bool @go(UseVMConfigReloader,*bool)

	// ConfigReloaderImageTag defines image:tag for config-reloader container
	// +optional
	configReloaderImageTag?: string @go(ConfigReloaderImageTag)

	// ConfigReloaderResources config-reloader container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	// if not defined default resources from operator config will be used
	// +optional
	// +operator-sdk:csv:customresourcedefinitions:type=spec,displayName="Resources",xDescriptors="urn:alm:descriptor:com.tectonic.ui:resourceRequirements"
	configReloaderResources?: v1.#ResourceRequirements @go(ConfigReloaderResources)

	// ConfigReloaderExtraArgs that will be passed to  VMAuths config-reloader container
	// for example resyncInterval: "30s"
	// +optional
	configReloaderExtraArgs?: {[string]: string} @go(ConfigReloaderExtraArgs,map[string]string)
}

// CommonApplicationDeploymentParams defines common params
// for deployment and statefulset specifications
#CommonApplicationDeploymentParams: {
	// Affinity If specified, the pod's scheduling constraints.
	// +optional
	affinity?: null | v1.#Affinity @go(Affinity,*v1.Affinity)

	// Tolerations If specified, the pod's tolerations.
	// +optional
	tolerations?: [...v1.#Toleration] @go(Tolerations,[]v1.Toleration)

	// SchedulerName - defines kubernetes scheduler name
	// +optional
	schedulerName?: string @go(SchedulerName)

	// RuntimeClassName - defines runtime class for kubernetes pod.
	// https://kubernetes.io/docs/concepts/containers/runtime-class/
	// +optional
	runtimeClassName?: null | string @go(RuntimeClassName,*string)

	// HostAliases provides mapping for ip and hostname,
	// that would be propagated to pod,
	// cannot be used with HostNetwork.
	// +optional
	hostAliases?: [...v1.#HostAlias] @go(HostAliases,[]v1.HostAlias)

	// HostAliasesUnderScore provides mapping for ip and hostname,
	// that would be propagated to pod,
	// cannot be used with HostNetwork.
	// Has Priority over hostAliases field
	// +optional
	host_aliases?: [...v1.#HostAlias] @go(HostAliasesUnderScore,[]v1.HostAlias)

	// PriorityClassName class assigned to the Pods
	// +optional
	priorityClassName?: string @go(PriorityClassName)

	// HostNetwork controls whether the pod may use the node network namespace
	// +optional
	hostNetwork?: bool @go(HostNetwork)

	// DNSPolicy sets DNS policy for the pod
	// +optional
	dnsPolicy?: v1.#DNSPolicy @go(DNSPolicy)

	// Specifies the DNS parameters of a pod.
	// Parameters specified here will be merged to the generated DNS
	// configuration based on DNSPolicy.
	// +optional
	dnsConfig?: null | v1.#PodDNSConfig @go(DNSConfig,*v1.PodDNSConfig)

	// NodeSelector Define which Nodes the Pods are scheduled on.
	// +optional
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string)

	// SecurityContext holds pod-level security attributes and common container settings.
	// This defaults to the default PodSecurityContext.
	// +optional
	securityContext?: null | #SecurityContext @go(SecurityContext,*SecurityContext)

	// TopologySpreadConstraints embedded kubernetes pod configuration option,
	// controls how pods are spread across your cluster among failure-domains
	// such as regions, zones, nodes, and other user-defined topology domains
	// https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
	// +optional
	topologySpreadConstraints?: [...v1.#TopologySpreadConstraint] @go(TopologySpreadConstraints,[]v1.TopologySpreadConstraint)

	// ImagePullSecrets An optional list of references to secrets in the same namespace
	// to use for pulling images from registries
	// see https://kubernetes.io/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod
	// +optional
	imagePullSecrets?: [...v1.#LocalObjectReference] @go(ImagePullSecrets,[]v1.LocalObjectReference)

	// TerminationGracePeriodSeconds period for container graceful termination
	// +optional
	terminationGracePeriodSeconds?: null | int64 @go(TerminationGracePeriodSeconds,*int64)

	// ReadinessGates defines pod readiness gates
	readinessGates?: [...v1.#PodReadinessGate] @go(ReadinessGates,[]v1.PodReadinessGate)

	// MinReadySeconds defines a minimum number of seconds to wait before starting update next pod
	// if previous in healthy state
	// Has no effect for VLogs and VMSingle
	// +optional
	minReadySeconds?: int32 @go(MinReadySeconds)

	// ReplicaCount is the expected size of the Application.
	// +operator-sdk:csv:customresourcedefinitions:type=spec,displayName="Number of pods",xDescriptors="urn:alm:descriptor:com.tectonic.ui:podCount,urn:alm:descriptor:io.kubernetes:custom"
	// +optional
	replicaCount?: null | int32 @go(ReplicaCount,*int32)

	// The number of old ReplicaSets to retain to allow rollback in deployment or
	// maximum number of revisions that will be maintained in the Deployment revision history.
	// Has no effect at StatefulSets
	// Defaults to 10.
	// +optional
	revisionHistoryLimitCount?: null | int32 @go(RevisionHistoryLimitCount,*int32)

	// Containers property allows to inject additions sidecars or to patch existing containers.
	// It can be useful for proxies, backup, etc.
	// +optional
	containers?: [...v1.#Container] @go(Containers,[]v1.Container)

	// InitContainers allows adding initContainers to the pod definition.
	// Any errors during the execution of an initContainer will lead to a restart of the Pod.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
	// +optional
	initContainers?: [...v1.#Container] @go(InitContainers,[]v1.Container)

	// Secrets is a list of Secrets in the same namespace as the Application
	// object, which shall be mounted into the Application container
	// at /etc/vm/secrets/SECRET_NAME folder
	// +optional
	secrets?: [...string] @go(Secrets,[]string)

	// ConfigMaps is a list of ConfigMaps in the same namespace as the Application
	// object, which shall be mounted into the Application container
	// at /etc/vm/configs/CONFIGMAP_NAME folder
	// +optional
	configMaps?: [...string] @go(ConfigMaps,[]string)

	// Volumes allows configuration of additional volumes on the output Deployment/StatefulSet definition.
	// Volumes specified will be appended to other volumes that are generated.
	/// +optional
	volumes?: [...v1.#Volume] @go(Volumes,[]v1.Volume)

	// VolumeMounts allows configuration of additional VolumeMounts on the output Deployment/StatefulSet definition.
	// VolumeMounts specified will be appended to other VolumeMounts in the Application container
	// +optional
	volumeMounts?: [...v1.#VolumeMount] @go(VolumeMounts,[]v1.VolumeMount)

	// ExtraArgs that will be passed to the application container
	// for example remoteWrite.tmpDataPath: /tmp
	// +optional
	extraArgs?: {[string]: string} @go(ExtraArgs,map[string]string)

	// ExtraEnvs that will be passed to the application container
	// +optional
	extraEnvs?: [...v1.#EnvVar] @go(ExtraEnvs,[]v1.EnvVar)

	// Paused If set to true all actions on the underlying managed objects are not
	// going to be performed, except for delete actions.
	// +optional
	paused?: bool @go(Paused)
}

// SecurityContext extends PodSecurityContext with ContainerSecurityContext
// It allows to globally configure security params for pod and all containers
#SecurityContext: {
	v1.#PodSecurityContext

	#ContainerSecurityContext
}

// ContainerSecurityContext defines security context for each application container
#ContainerSecurityContext: {
	// Run containers in privileged mode.
	// Processes in privileged containers are essentially equivalent to root on the host.
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	privileged?: null | bool @go(Privileged,*bool)

	// The capabilities to add/drop when running containers.
	// Defaults to the default set of capabilities granted by the container runtime.
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	capabilities?: null | v1.#Capabilities @go(Capabilities,*v1.Capabilities)

	// Whether this containers has a read-only root filesystem.
	// Default is false.
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	readOnlyRootFilesystem?: null | bool @go(ReadOnlyRootFilesystem,*bool)

	// AllowPrivilegeEscalation controls whether a process can gain more
	// privileges than its parent process. This bool directly controls if
	// the no_new_privs flag will be set on the container process.
	// AllowPrivilegeEscalation is true always when the container is:
	// 1) run as Privileged
	// 2) has CAP_SYS_ADMIN
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	allowPrivilegeEscalation?: null | bool @go(AllowPrivilegeEscalation,*bool)

	// procMount denotes the type of proc mount to use for the containers.
	// The default is DefaultProcMount which uses the container runtime defaults for
	// readonly paths and masked paths.
	// This requires the ProcMountType feature flag to be enabled.
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	procMount?: null | v1.#ProcMountType @go(ProcMount,*v1.ProcMountType)
}

_#objectWithDeepCopy: _

_#objectStatusWithDeepCopy: _

// ExternalConfig defines external source of configuration
#ExternalConfig: {
	// SecretRef defines selector for externally managed secret which contains configuration
	// +optional
	secretRef?: null | v1.#SecretKeySelector @go(SecretRef,*v1.SecretKeySelector)

	// LocalPath contains static path to a config, which is managed externally for cases
	// when using secrets is not applicable, e.g.: Vault sidecar.
	// +optional
	localPath?: string @go(LocalPath)
}

// StatusMetadata holds metadata of application update status
// +k8s:openapi-gen=true
#StatusMetadata: {
	// UpdateStatus defines a status for update rollout
	//
	updateStatus?: #UpdateStatus @go(UpdateStatus)

	// Reason defines human readable error reason
	//
	reason?: string @go(Reason)

	// ObservedGeneration defines current generation picked by operator for the
	// reconcile
	observedGeneration?: int64 @go(ObservedGeneration)

	// Known .status.conditions.type are: "Available", "Progressing", and "Degraded"
	// +patchMergeKey=type
	// +patchStrategy=merge
	// +listType=map
	// +listMapKey=type
	conditions?: [...#Condition] @go(Conditions,[]Condition)
}

// ManagedObjectsMetadata contains Labels and Annotations
#ManagedObjectsMetadata: {
	// Labels Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
	labels?: {[string]: string} @go(Labels,map[string]string)

	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
	annotations?: {[string]: string} @go(Annotations,map[string]string)
}

// Image defines docker image settings
#Image: {
	// Repository contains name of docker image + it's repository if needed
	repository?: string @go(Repository)

	// Tag contains desired docker image version
	tag?: string @go(Tag)

	// PullPolicy describes how to pull docker image
	pullPolicy?: v1.#PullPolicy @go(PullPolicy)
}

// Condition defines status condition of the resource
#Condition: {
	// Type of condition in CamelCase or in name.namespace.resource.victoriametrics.com/CamelCase.
	// +required
	// +kubebuilder:validation:MaxLength=316
	type: string @go(Type)

	// status of the condition, one of True, False, Unknown.
	// +required
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Enum=True;False;Unknown
	status: metav1.#ConditionStatus @go(Status)

	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	// +optional
	// +kubebuilder:validation:Minimum=0
	observedGeneration?: int64 @go(ObservedGeneration) @protobuf(3,varint,opt)

	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// +required
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Type=string
	// +kubebuilder:validation:Format=date-time
	lastTransitionTime: metav1.#Time @go(LastTransitionTime)

	// LastUpdateTime is the last time of given type update.
	// This value is used for status TTL update and removal
	// +required
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Type=string
	// +kubebuilder:validation:Format=date-time
	lastUpdateTime?: metav1.#Time @go(LastUpdateTime)

	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	// +required
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=1024
	// +kubebuilder:validation:MinLength=1
	reason: string @go(Reason)

	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	// +optional
	// +kubebuilder:validation:MaxLength=32768
	message?: string @go(Message)
}
