// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/VictoriaMetrics/operator/api/operator/v1beta1

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
)

// VMPodScrapeSpec defines the desired state of VMPodScrape
#VMPodScrapeSpec: {
	// The label to use to retrieve the job name from.
	// +optional
	jobLabel?: string @go(JobLabel)

	// PodTargetLabels transfers labels on the Kubernetes Pod onto the target.
	// +optional
	podTargetLabels?: [...string] @go(PodTargetLabels,[]string)

	// A list of endpoints allowed as part of this PodMonitor.
	podMetricsEndpoints: [...#PodMetricsEndpoint] @go(PodMetricsEndpoints,[]PodMetricsEndpoint)

	// Selector to select Pod objects.
	// +operator-sdk:gen-csv:customresourcedefinitions.specDescriptors=true
	// +operator-sdk:gen-csv:customresourcedefinitions.specDescriptors.displayName="Pod selector"
	// +operator-sdk:gen-csv:customresourcedefinitions.specDescriptors.x-descriptors="urn:alm:descriptor:com.tectonic.ui:selector:"
	// +optional
	selector?: metav1.#LabelSelector @go(Selector)

	// Selector to select which namespaces the Endpoints objects are discovered from.
	// +optional
	namespaceSelector?: #NamespaceSelector @go(NamespaceSelector)

	// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
	// +optional
	sampleLimit?: uint64 @go(SampleLimit)

	// SeriesLimit defines per-scrape limit on number of unique time series
	// a single target can expose during all the scrapes on the time window of 24h.
	// +optional
	seriesLimit?: uint64 @go(SeriesLimit)

	// AttachMetadata configures metadata attaching from service discovery
	// +optional
	attach_metadata?: #AttachMetadata @go(AttachMetadata)
}

// VMPodScrape is scrape configuration for pods,
// it generates vmagent's config for scraping pod targets
// based on selectors.
// +operator-sdk:gen-csv:customresourcedefinitions.displayName="VMPodScrape"
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:path=vmpodscrapes,scope=Namespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:printcolumn:name="Status",type="string",JSONPath=".status.updateStatus"
// +kubebuilder:printcolumn:name="Sync Error",type="string",JSONPath=".status.reason"
// +genclient
#VMPodScrape: {
	metav1.#TypeMeta

	// +optional
	metadata?: metav1.#ObjectMeta  @go(ObjectMeta)
	spec?:     #VMPodScrapeSpec    @go(Spec)
	status?:   #ScrapeObjectStatus @go(Status)
}

// VMPodScrapeList contains a list of VMPodScrape
#VMPodScrapeList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VMPodScrape] @go(Items,[]VMPodScrape)
}

// PodMetricsEndpoint defines a scrapeable endpoint of a Kubernetes Pod serving metrics.
// +k8s:openapi-gen=true
#PodMetricsEndpoint: {
	// Name of the port exposed at Pod.
	// +optional
	port?: string @go(Port)

	// TargetPort
	// Name or number of the pod port this endpoint refers to. Mutually exclusive with port.
	// +optional
	targetPort?: null | intstr.#IntOrString @go(TargetPort,*intstr.IntOrString)

	#EndpointRelabelings

	#EndpointAuth

	#EndpointScrapeParams

	// AttachMetadata configures metadata attaching from service discovery
	// +optional
	attach_metadata?: #AttachMetadata @go(AttachMetadata)

	// FilterRunning applies filter with pod status == running
	// it prevents from scrapping metrics at failed or succeed state pods.
	// enabled by default
	// +optional
	filterRunning?: null | bool @go(FilterRunning,*bool)
}

// ArbitraryFSAccessThroughSMsConfig enables users to configure, whether
// a service scrape selected by the vmagent instance is allowed to use
// arbitrary files on the file system of the vmagent container. This is the case
// when e.g. a service scrape specifies a BearerTokenFile in an endpoint. A
// malicious user could create a service scrape selecting arbitrary secret files
// in the vmagent container. Those secrets would then be sent with a scrape
// request by vmagent to a malicious target. Denying the above would prevent the
// attack, users can instead use the BearerTokenSecret field.
#ArbitraryFSAccessThroughSMsConfig: {
	deny?: bool @go(Deny)
}
