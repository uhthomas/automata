// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/VictoriaMetrics/operator/api/victoriametrics/v1beta1

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/api/core/v1"
)

// VMPodScrapeSpec defines the desired state of VMPodScrape
#VMPodScrapeSpec: {
	// The label to use to retrieve the job name from.
	// +optional
	jobLabel?: string @go(JobLabel)

	// PodTargetLabels transfers labels on the Kubernetes Pod onto the target.
	// +optional
	podTargetLabels?: [...string] @go(PodTargetLabels,[]string)

	// A list of endpoints allowed as part of this PodMonitor.
	podMetricsEndpoints: [...#PodMetricsEndpoint] @go(PodMetricsEndpoints,[]PodMetricsEndpoint)

	// Selector to select Pod objects.
	// +operator-sdk:gen-csv:customresourcedefinitions.specDescriptors=true
	// +operator-sdk:gen-csv:customresourcedefinitions.specDescriptors.displayName="Pod selector"
	// +operator-sdk:gen-csv:customresourcedefinitions.specDescriptors.x-descriptors="urn:alm:descriptor:com.tectonic.ui:selector:"
	// +optional
	selector?: metav1.#LabelSelector @go(Selector)

	// Selector to select which namespaces the Endpoints objects are discovered from.
	// +optional
	namespaceSelector?: #NamespaceSelector @go(NamespaceSelector)

	// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
	// +optional
	sampleLimit?: uint64 @go(SampleLimit)
}

// VMPodScrapeStatus defines the observed state of VMPodScrape
#VMPodScrapeStatus: {
}

// VMPodScrape is scrape configuration for pods,
// it generates vmagent's config for scraping pod targets
// based on selectors.
// +operator-sdk:gen-csv:customresourcedefinitions.displayName="VMPodScrape"
// +kubebuilder:subresource:status
// +kubebuilder:resource:path=vmpodscrapes,scope=Namespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient
#VMPodScrape: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec?:     #VMPodScrapeSpec   @go(Spec)

	// +optional
	status: #VMPodScrapeStatus @go(Status)
}

// VMPodScrapeList contains a list of VMPodScrape
#VMPodScrapeList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VMPodScrape] @go(Items,[]VMPodScrape)
}

// PodMetricsEndpoint defines a scrapeable endpoint of a Kubernetes Pod serving Prometheus metrics.
// +k8s:openapi-gen=true
#PodMetricsEndpoint: {
	// Name of the pod port this endpoint refers to. Mutually exclusive with targetPort.
	// +optional
	port?: string @go(Port)

	// Deprecated: Use 'port' instead.
	// +optional
	targetPort?: null | intstr.#IntOrString @go(TargetPort,*intstr.IntOrString)

	// HTTP path to scrape for metrics.
	// +optional
	path?: string @go(Path)

	// HTTP scheme to use for scraping.
	// +optional
	// +kubebuilder:validation:Enum=http;https
	scheme?: string @go(Scheme)

	// Optional HTTP URL parameters
	// +optional
	params?: {[string]: [...string]} @go(Params,map[string][]string)

	// FollowRedirects controls redirects for scraping.
	// +optional
	follow_redirects?: null | bool @go(FollowRedirects,*bool)

	// Interval at which metrics should be scraped
	// +optional
	interval?: string @go(Interval)

	// ScrapeInterval is the same as Interval and has priority over it.
	// one of scrape_interval or interval can be used
	// +optional
	scrape_interval?: string @go(ScrapeInterval)

	// Timeout after which the scrape is ended
	// +optional
	scrapeTimeout?: string @go(ScrapeTimeout)

	// SampleLimit defines per-podEndpoint limit on number of scraped samples that will be accepted.
	// +optional
	sampleLimit?: uint64 @go(SampleLimit)

	// HonorLabels chooses the metric's labels on collisions with target labels.
	// +optional
	honorLabels?: bool @go(HonorLabels)

	// HonorTimestamps controls whether vmagent respects the timestamps present in scraped data.
	// +optional
	honorTimestamps?: null | bool @go(HonorTimestamps,*bool)

	// MetricRelabelConfigs to apply to samples before ingestion.
	// +optional
	metricRelabelConfigs?: [...null | #RelabelConfig] @go(MetricRelabelConfigs,[]*RelabelConfig)

	// RelabelConfigs to apply to samples before ingestion.
	// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
	// +optional
	relabelConfigs?: [...null | #RelabelConfig] @go(RelabelConfigs,[]*RelabelConfig)

	// ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
	// +optional
	proxyURL?: null | string @go(ProxyURL,*string)

	// BasicAuth allow an endpoint to authenticate over basic authentication
	// More info: https://prometheus.io/docs/operating/configuration/#endpoints
	// +optional
	basicAuth?: null | #BasicAuth @go(BasicAuth,*BasicAuth)

	// File to read bearer token for scraping targets.
	// +optional
	bearerTokenFile?: string @go(BearerTokenFile)

	// Secret to mount to read bearer token for scraping targets. The secret
	// needs to be in the same namespace as the service scrape and accessible by
	// the victoria-metrics operator.
	// +optional
	// +nullable
	bearerTokenSecret?: null | v1.#SecretKeySelector @go(BearerTokenSecret,*v1.SecretKeySelector)

	// TLSConfig configuration to use when scraping the endpoint
	// +optional
	tlsConfig?: null | #TLSConfig @go(TLSConfig,*TLSConfig)

	// OAuth2 defines auth configuration
	// +optional
	oauth2?: null | #OAuth2 @go(OAuth2,*OAuth2)

	// Authorization with http header Authorization
	// +optional
	authorization?: null | #Authorization @go(Authorization,*Authorization)

	// VMScrapeParams defines VictoriaMetrics specific scrape parametrs
	// +optional
	vm_scrape_params?: null | #VMScrapeParams @go(VMScrapeParams,*VMScrapeParams)

	// AttachMetadata configures metadata attaching from service discovery
	// +optional
	attach_metadata?: #AttachMetadata @go(AttachMetadata)

	// FilterRunning applies filter with pod status == running
	// it prevents from scrapping metrics at failed or succeed state pods.
	// enabled by default
	// +optional
	filterRunning?: null | bool @go(FilterRunning,*bool)
}

// ArbitraryFSAccessThroughSMsConfig enables users to configure, whether
// a service scrape selected by the vmagent instance is allowed to use
// arbitrary files on the file system of the vmagent container. This is the case
// when e.g. a service scrape specifies a BearerTokenFile in an endpoint. A
// malicious user could create a service scrape selecting arbitrary secret files
// in the vmagent container. Those secrets would then be sent with a scrape
// request by vmagent to a malicious target. Denying the above would prevent the
// attack, users can instead use the BearerTokenSecret field.
#ArbitraryFSAccessThroughSMsConfig: {
	deny?: bool @go(Deny)
}
