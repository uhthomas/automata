// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/prometheus/client_model/go

package io_prometheus_client

import "google.golang.org/protobuf/types/known/timestamppb"

#MetricType: _ // #enumMetricType

#enumMetricType:
	#MetricType_COUNTER |
	#MetricType_GAUGE |
	#MetricType_SUMMARY |
	#MetricType_UNTYPED |
	#MetricType_HISTOGRAM |
	#MetricType_GAUGE_HISTOGRAM

#values_MetricType: {
	MetricType_COUNTER:         #MetricType_COUNTER
	MetricType_GAUGE:           #MetricType_GAUGE
	MetricType_SUMMARY:         #MetricType_SUMMARY
	MetricType_UNTYPED:         #MetricType_UNTYPED
	MetricType_HISTOGRAM:       #MetricType_HISTOGRAM
	MetricType_GAUGE_HISTOGRAM: #MetricType_GAUGE_HISTOGRAM
}

// COUNTER must use the Metric field "counter".
#MetricType_COUNTER: #MetricType & 0

// GAUGE must use the Metric field "gauge".
#MetricType_GAUGE: #MetricType & 1

// SUMMARY must use the Metric field "summary".
#MetricType_SUMMARY: #MetricType & 2

// UNTYPED must use the Metric field "untyped".
#MetricType_UNTYPED: #MetricType & 3

// HISTOGRAM must use the Metric field "histogram".
#MetricType_HISTOGRAM: #MetricType & 4

// GAUGE_HISTOGRAM must use the Metric field "histogram".
#MetricType_GAUGE_HISTOGRAM: #MetricType & 5

#LabelPair: {
	name?:  null | string @go(Name,*string) @protobuf(1,bytes,opt)
	value?: null | string @go(Value,*string) @protobuf(2,bytes,opt)
}

#Gauge: {
	value?: null | float64 @go(Value,*float64) @protobuf(1,fixed64,opt)
}

#Counter: {
	value?:             null | float64                @go(Value,*float64) @protobuf(1,fixed64,opt)
	exemplar?:          null | #Exemplar              @go(Exemplar,*Exemplar) @protobuf(2,bytes,opt)
	created_timestamp?: null | timestamppb.#Timestamp @go(CreatedTimestamp,*timestamppb.Timestamp) @protobuf(3,bytes,opt,json=createdTimestamp)
}

#Quantile: {
	quantile?: null | float64 @go(Quantile,*float64) @protobuf(1,fixed64,opt)
	value?:    null | float64 @go(Value,*float64) @protobuf(2,fixed64,opt)
}

#Summary: {
	sample_count?: null | uint64  @go(SampleCount,*uint64) @protobuf(1,varint,opt,json=sampleCount)
	sample_sum?:   null | float64 @go(SampleSum,*float64) @protobuf(2,fixed64,opt,json=sampleSum)
	quantile?: [...null | #Quantile] @go(Quantile,[]*Quantile) @protobuf(3,bytes,rep)
	created_timestamp?: null | timestamppb.#Timestamp @go(CreatedTimestamp,*timestamppb.Timestamp) @protobuf(4,bytes,opt,json=createdTimestamp)
}

#Untyped: {
	value?: null | float64 @go(Value,*float64) @protobuf(1,fixed64,opt)
}

#Histogram: {
	sample_count?:       null | uint64  @go(SampleCount,*uint64) @protobuf(1,varint,opt,json=sampleCount)
	sample_count_float?: null | float64 @go(SampleCountFloat,*float64) @protobuf(4,fixed64,opt,json=sampleCountFloat)
	sample_sum?:         null | float64 @go(SampleSum,*float64) @protobuf(2,fixed64,opt,json=sampleSum)

	// Buckets for the conventional histogram.
	bucket?: [...null | #Bucket] @go(Bucket,[]*Bucket) @protobuf(3,bytes,rep)
	created_timestamp?: null | timestamppb.#Timestamp @go(CreatedTimestamp,*timestamppb.Timestamp) @protobuf(15,bytes,opt,json=createdTimestamp)

	// schema defines the bucket schema. Currently, valid numbers are -4 <= n <= 8.
	// They are all for base-2 bucket schemas, where 1 is a bucket boundary in each case, and
	// then each power of two is divided into 2^n logarithmic buckets.
	// Or in other words, each bucket boundary is the previous boundary times 2^(2^-n).
	// In the future, more bucket schemas may be added using numbers < -4 or > 8.
	schema?:           null | int32   @go(Schema,*int32) @protobuf(5,zigzag32,opt)
	zero_threshold?:   null | float64 @go(ZeroThreshold,*float64) @protobuf(6,fixed64,opt,json=zeroThreshold)
	zero_count?:       null | uint64  @go(ZeroCount,*uint64) @protobuf(7,varint,opt,json=zeroCount)
	zero_count_float?: null | float64 @go(ZeroCountFloat,*float64) @protobuf(8,fixed64,opt,json=zeroCountFloat)

	// Negative buckets for the native histogram.
	negative_span?: [...null | #BucketSpan] @go(NegativeSpan,[]*BucketSpan) @protobuf(9,bytes,rep,json=negativeSpan)

	// Use either "negative_delta" or "negative_count", the former for
	// regular histograms with integer counts, the latter for float
	// histograms.
	negative_delta?: [...int64] @go(NegativeDelta,[]int64) @protobuf(10,zigzag64,rep,json=negativeDelta)
	negative_count?: [...float64] @go(NegativeCount,[]float64) @protobuf(11,fixed64,rep,json=negativeCount)

	// Positive buckets for the native histogram.
	// Use a no-op span (offset 0, length 0) for a native histogram without any
	// observations yet and with a zero_threshold of 0. Otherwise, it would be
	// indistinguishable from a classic histogram.
	positive_span?: [...null | #BucketSpan] @go(PositiveSpan,[]*BucketSpan) @protobuf(12,bytes,rep,json=positiveSpan)

	// Use either "positive_delta" or "positive_count", the former for
	// regular histograms with integer counts, the latter for float
	// histograms.
	positive_delta?: [...int64] @go(PositiveDelta,[]int64) @protobuf(13,zigzag64,rep,json=positiveDelta)
	positive_count?: [...float64] @go(PositiveCount,[]float64) @protobuf(14,fixed64,rep,json=positiveCount)

	// Only used for native histograms. These exemplars MUST have a timestamp.
	exemplars?: [...null | #Exemplar] @go(Exemplars,[]*Exemplar) @protobuf(16,bytes,rep)
}

// A Bucket of a conventional histogram, each of which is treated as
// an individual counter-like time series by Prometheus.
#Bucket: {
	cumulative_count?:       null | uint64    @go(CumulativeCount,*uint64) @protobuf(1,varint,opt,json=cumulativeCount)
	cumulative_count_float?: null | float64   @go(CumulativeCountFloat,*float64) @protobuf(4,fixed64,opt,json=cumulativeCountFloat)
	upper_bound?:            null | float64   @go(UpperBound,*float64) @protobuf(2,fixed64,opt,json=upperBound)
	exemplar?:               null | #Exemplar @go(Exemplar,*Exemplar) @protobuf(3,bytes,opt)
}

// A BucketSpan defines a number of consecutive buckets in a native
// histogram with their offset. Logically, it would be more
// straightforward to include the bucket counts in the Span. However,
// the protobuf representation is more compact in the way the data is
// structured here (with all the buckets in a single array separate
// from the Spans).
#BucketSpan: {
	offset?: null | int32  @go(Offset,*int32) @protobuf(1,zigzag32,opt)
	length?: null | uint32 @go(Length,*uint32) @protobuf(2,varint,opt)
}

#Exemplar: {
	label?: [...null | #LabelPair] @go(Label,[]*LabelPair) @protobuf(1,bytes,rep)
	value?:     null | float64                @go(Value,*float64) @protobuf(2,fixed64,opt)
	timestamp?: null | timestamppb.#Timestamp @go(Timestamp,*timestamppb.Timestamp) @protobuf(3,bytes,opt)
}

#Metric: {
	label?: [...null | #LabelPair] @go(Label,[]*LabelPair) @protobuf(1,bytes,rep)
	gauge?:        null | #Gauge     @go(Gauge,*Gauge) @protobuf(2,bytes,opt)
	counter?:      null | #Counter   @go(Counter,*Counter) @protobuf(3,bytes,opt)
	summary?:      null | #Summary   @go(Summary,*Summary) @protobuf(4,bytes,opt)
	untyped?:      null | #Untyped   @go(Untyped,*Untyped) @protobuf(5,bytes,opt)
	histogram?:    null | #Histogram @go(Histogram,*Histogram) @protobuf(7,bytes,opt)
	timestamp_ms?: null | int64      @go(TimestampMs,*int64) @protobuf(6,varint,opt,json=timestampMs)
}

#MetricFamily: {
	name?: null | string      @go(Name,*string) @protobuf(1,bytes,opt)
	help?: null | string      @go(Help,*string) @protobuf(2,bytes,opt)
	type?: null | #MetricType @go(Type,*MetricType) @protobuf(3,varint,opt,enum=io.prometheus.client.MetricType)
	metric?: [...null | #Metric] @go(Metric,[]*Metric) @protobuf(4,bytes,rep)
	unit?: null | string @go(Unit,*string) @protobuf(5,bytes,opt)
}
