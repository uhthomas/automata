// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/envoyproxy/gateway/api/v1alpha1

package v1alpha1

#MetricSinkType: string // #enumMetricSinkType

#enumMetricSinkType:
	#MetricSinkTypeOpenTelemetry

#MetricSinkTypeOpenTelemetry: #MetricSinkType & "OpenTelemetry"

#ProxyMetrics: {
	// Prometheus defines the configuration for Admin endpoint `/stats/prometheus`.
	prometheus?: null | #ProxyPrometheusProvider @go(Prometheus,*ProxyPrometheusProvider)

	// Sinks defines the metric sinks where metrics are sent to.
	// +kubebuilder:validation:MaxItems=16
	sinks?: [...#ProxyMetricSink] @go(Sinks,[]ProxyMetricSink)

	// Matches defines configuration for selecting specific metrics instead of generating all metrics stats
	// that are enabled by default. This helps reduce CPU and memory overhead in Envoy, but eliminating some stats
	// may after critical functionality. Here are the stats that we strongly recommend not disabling:
	// `cluster_manager.warming_clusters`, `cluster.<cluster_name>.membership_total`,`cluster.<cluster_name>.membership_healthy`,
	// `cluster.<cluster_name>.membership_degraded`ï¼Œreference  https://github.com/envoyproxy/envoy/issues/9856,
	// https://github.com/envoyproxy/envoy/issues/14610
	//
	matches?: [...#StringMatch] @go(Matches,[]StringMatch)

	// EnableVirtualHostStats enables envoy stat metrics for virtual hosts.
	//
	// +optional
	enableVirtualHostStats?: null | bool @go(EnableVirtualHostStats,*bool)

	// EnablePerEndpointStats enables per endpoint envoy stats metrics.
	// Please use with caution.
	//
	// +optional
	enablePerEndpointStats?: null | bool @go(EnablePerEndpointStats,*bool)

	// EnableRequestResponseSizesStats enables publishing of histograms tracking header and body sizes of requests and responses.
	//
	// +optional
	enableRequestResponseSizesStats?: null | bool @go(EnableRequestResponseSizesStats,*bool)
}

// ProxyMetricSink defines the sink of metrics.
// Default metrics sink is OpenTelemetry.
// +union
//
// +kubebuilder:validation:XValidation:rule="self.type == 'OpenTelemetry' ? has(self.openTelemetry) : !has(self.openTelemetry)",message="If MetricSink type is OpenTelemetry, openTelemetry field needs to be set."
#ProxyMetricSink: {
	// Type defines the metric sink type.
	// EG currently only supports OpenTelemetry.
	// +kubebuilder:validation:Enum=OpenTelemetry
	// +kubebuilder:default=OpenTelemetry
	// +unionDiscriminator
	type: #MetricSinkType @go(Type)

	// OpenTelemetry defines the configuration for OpenTelemetry sink.
	// It's required if the sink type is OpenTelemetry.
	// +optional
	openTelemetry?: null | #ProxyOpenTelemetrySink @go(OpenTelemetry,*ProxyOpenTelemetrySink)
}

// ProxyOpenTelemetrySink defines the configuration for OpenTelemetry sink.
//
// +kubebuilder:validation:XValidation:message="host or backendRefs needs to be set",rule="has(self.host) || self.backendRefs.size() > 0"
// +kubebuilder:validation:XValidation:message="BackendRefs must be used, backendRef is not supported.",rule="!has(self.backendRef)"
// +kubebuilder:validation:XValidation:message="BackendRefs only support Service and Backend kind.",rule="has(self.backendRefs) ? self.backendRefs.all(f, f.kind == 'Service' || f.kind == 'Backend') : true"
// +kubebuilder:validation:XValidation:message="BackendRefs only support Core and gateway.envoyproxy.io group.",rule="has(self.backendRefs) ? (self.backendRefs.all(f, f.group == \"\" || f.group == 'gateway.envoyproxy.io')) : true"
#ProxyOpenTelemetrySink: {
	#BackendCluster

	// Host define the service hostname.
	// Deprecated: Use BackendRefs instead.
	//
	// +optional
	host?: null | string @go(Host,*string)

	// Port defines the port the service is exposed on.
	// Deprecated: Use BackendRefs instead.
	//
	// +optional
	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=65535
	// +kubebuilder:default=4317
	port?: int32 @go(Port)
}

#ProxyPrometheusProvider: {
	// Disable the Prometheus endpoint.
	disable?: bool @go(Disable)

	// Configure the compression on Prometheus endpoint. Compression is useful in situations when bandwidth is scarce and large payloads can be effectively compressed at the expense of higher CPU load.
	// +optional
	compression?: null | #Compression @go(Compression,*Compression)
}
