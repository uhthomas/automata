// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/envoyproxy/gateway/api/v1alpha1

package v1alpha1

import metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

// HealthCheck configuration to decide which endpoints
// are healthy and can be used for routing.
#HealthCheck: {
	// Active health check configuration
	// +optional
	active?: null | #ActiveHealthCheck @go(Active,*ActiveHealthCheck)

	// Passive passive check configuration
	// +optional
	passive?: null | #PassiveHealthCheck @go(Passive,*PassiveHealthCheck)

	// When number of unhealthy endpoints for a backend reaches this threshold
	// Envoy will disregard health status and balance across all endpoints.
	// It's designed to prevent a situation in which host failures cascade throughout the cluster
	// as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
	// +kubebuilder:validation:Minimum=0
	// +kubebuilder:validation:Maximum=100
	// +optional
	panicThreshold?: null | uint32 @go(PanicThreshold,*uint32)
}

// PassiveHealthCheck defines the configuration for passive health checks in the context of Envoy's Outlier Detection,
// see https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/outlier
#PassiveHealthCheck: {
	// SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
	//
	// +kubebuilder:default=false
	// +optional
	splitExternalLocalOriginErrors?: null | bool @go(SplitExternalLocalOriginErrors,*bool)

	// Interval defines the time between passive health checks.
	//
	// +kubebuilder:validation:Format=duration
	// +kubebuilder:default="3s"
	// +optional
	interval?: null | metav1.#Duration @go(Interval,*metav1.Duration)

	// ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
	// Parameter takes effect only when split_external_local_origin_errors is set to true.
	//
	// +kubebuilder:default=5
	// +optional
	consecutiveLocalOriginFailures?: null | uint32 @go(ConsecutiveLocalOriginFailures,*uint32)

	// ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
	//
	// +kubebuilder:default=0
	// +optional
	consecutiveGatewayErrors?: null | uint32 @go(ConsecutiveGatewayErrors,*uint32)

	// Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
	//
	// +kubebuilder:default=5
	// +optional
	consecutive5XxErrors?: null | uint32 @go(Consecutive5xxErrors,*uint32)

	// BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
	//
	// +kubebuilder:validation:Format=duration
	// +kubebuilder:default="30s"
	// +optional
	baseEjectionTime?: null | metav1.#Duration @go(BaseEjectionTime,*metav1.Duration)

	// MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
	//
	// +kubebuilder:default=10
	// +optional
	maxEjectionPercent?: null | int32 @go(MaxEjectionPercent,*int32)
}

// ActiveHealthCheck defines the active health check configuration.
// EG supports various types of active health checking including HTTP, TCP.
// +union
//
// +kubebuilder:validation:XValidation:rule="self.type == 'HTTP' ? has(self.http) : !has(self.http)",message="If Health Checker type is HTTP, http field needs to be set."
// +kubebuilder:validation:XValidation:rule="self.type == 'TCP' ? has(self.tcp) : !has(self.tcp)",message="If Health Checker type is TCP, tcp field needs to be set."
// +kubebuilder:validation:XValidation:rule="has(self.grpc) ? self.type == 'GRPC' : true", message="The grpc field can only be set if the Health Checker type is GRPC."
#ActiveHealthCheck: {
	// Timeout defines the time to wait for a health check response.
	//
	// +kubebuilder:validation:Format=duration
	// +kubebuilder:default="1s"
	// +optional
	timeout?: null | metav1.#Duration @go(Timeout,*metav1.Duration)

	// Interval defines the time between active health checks.
	//
	// +kubebuilder:validation:Format=duration
	// +kubebuilder:default="3s"
	// +optional
	interval?: null | metav1.#Duration @go(Interval,*metav1.Duration)

	// UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
	//
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:default=3
	// +optional
	unhealthyThreshold?: null | uint32 @go(UnhealthyThreshold,*uint32)

	// HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
	//
	// +kubebuilder:validation:Minimum=1
	// +kubebuilder:default=1
	// +optional
	healthyThreshold?: null | uint32 @go(HealthyThreshold,*uint32)

	// Type defines the type of health checker.
	// +kubebuilder:validation:Enum=HTTP;TCP;GRPC
	// +unionDiscriminator
	type: #ActiveHealthCheckerType @go(Type)

	// HTTP defines the configuration of http health checker.
	// It's required while the health checker type is HTTP.
	// +optional
	http?: null | #HTTPActiveHealthChecker @go(HTTP,*HTTPActiveHealthChecker)

	// TCP defines the configuration of tcp health checker.
	// It's required while the health checker type is TCP.
	// +optional
	tcp?: null | #TCPActiveHealthChecker @go(TCP,*TCPActiveHealthChecker)

	// GRPC defines the configuration of the GRPC health checker.
	// It's optional, and can only be used if the specified type is GRPC.
	// +optional
	grpc?: null | #GRPCActiveHealthChecker @go(GRPC,*GRPCActiveHealthChecker)
}

// ActiveHealthCheckerType is the type of health checker.
// +kubebuilder:validation:Enum=HTTP;TCP;GRPC
#ActiveHealthCheckerType: string // #enumActiveHealthCheckerType

#enumActiveHealthCheckerType:
	#ActiveHealthCheckerTypeHTTP |
	#ActiveHealthCheckerTypeTCP |
	#ActiveHealthCheckerTypeGRPC

// ActiveHealthCheckerTypeHTTP defines the HTTP type of health checking.
#ActiveHealthCheckerTypeHTTP: #ActiveHealthCheckerType & "HTTP"

// ActiveHealthCheckerTypeTCP defines the TCP type of health checking.
#ActiveHealthCheckerTypeTCP: #ActiveHealthCheckerType & "TCP"

// ActiveHealthCheckerTypeGRPC defines the GRPC type of health checking.
#ActiveHealthCheckerTypeGRPC: #ActiveHealthCheckerType & "GRPC"

// HTTPActiveHealthChecker defines the settings of http health check.
#HTTPActiveHealthChecker: {
	// Path defines the HTTP path that will be requested during health checking.
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:MaxLength=1024
	path: string @go(Path)

	// Method defines the HTTP method used for health checking.
	// Defaults to GET
	// +optional
	method?: null | string @go(Method,*string)

	// ExpectedStatuses defines a list of HTTP response statuses considered healthy.
	// Defaults to 200 only
	// +optional
	expectedStatuses?: [...#HTTPStatus] @go(ExpectedStatuses,[]HTTPStatus)

	// ExpectedResponse defines a list of HTTP expected responses to match.
	// +optional
	expectedResponse?: null | #ActiveHealthCheckPayload @go(ExpectedResponse,*ActiveHealthCheckPayload)
}

// TCPActiveHealthChecker defines the settings of tcp health check.
#TCPActiveHealthChecker: {
	// Send defines the request payload.
	// +optional
	send?: null | #ActiveHealthCheckPayload @go(Send,*ActiveHealthCheckPayload)

	// Receive defines the expected response payload.
	// +optional
	receive?: null | #ActiveHealthCheckPayload @go(Receive,*ActiveHealthCheckPayload)
}

// GRPCActiveHealthChecker defines the settings of the GRPC health check.
#GRPCActiveHealthChecker: {
	// Service to send in the health check request.
	// If this is not specified, then the health check request applies to the entire
	// server and not to a specific service.
	// +optional
	service?: null | string @go(Service,*string)
}

// ActiveHealthCheckPayloadType is the type of the payload.
// +kubebuilder:validation:Enum=Text;Binary
#ActiveHealthCheckPayloadType: string // #enumActiveHealthCheckPayloadType

#enumActiveHealthCheckPayloadType:
	#ActiveHealthCheckPayloadTypeText |
	#ActiveHealthCheckPayloadTypeBinary

// ActiveHealthCheckPayloadTypeText defines the Text type payload.
#ActiveHealthCheckPayloadTypeText: #ActiveHealthCheckPayloadType & "Text"

// ActiveHealthCheckPayloadTypeBinary defines the Binary type payload.
#ActiveHealthCheckPayloadTypeBinary: #ActiveHealthCheckPayloadType & "Binary"

// ActiveHealthCheckPayload defines the encoding of the payload bytes in the payload.
// +union
// +kubebuilder:validation:XValidation:rule="self.type == 'Text' ? has(self.text) : !has(self.text)",message="If payload type is Text, text field needs to be set."
// +kubebuilder:validation:XValidation:rule="self.type == 'Binary' ? has(self.binary) : !has(self.binary)",message="If payload type is Binary, binary field needs to be set."
#ActiveHealthCheckPayload: {
	// Type defines the type of the payload.
	// +kubebuilder:validation:Enum=Text;Binary
	// +unionDiscriminator
	type: #ActiveHealthCheckPayloadType @go(Type)

	// Text payload in plain text.
	// +optional
	text?: null | string @go(Text,*string)

	// Binary payload base64 encoded.
	// +optional
	binary?: bytes @go(Binary,[]byte)
}
