// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/envoyproxy/gateway/api/v1alpha1

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	gwapiv1a2 "sigs.k8s.io/gateway-api/apis/v1alpha2"
	"k8s.io/apimachinery/pkg/api/resource"
)

// KindBackendTrafficPolicy is the name of the BackendTrafficPolicy kind.
#KindBackendTrafficPolicy: "BackendTrafficPolicy"

// BackendTrafficPolicy allows the user to configure the behavior of the connection
// between the Envoy Proxy listener and the backend service.
//
// +kubebuilder:object:root=true
// +kubebuilder:resource:categories=envoy-gateway,shortName=btp
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`
#BackendTrafficPolicy: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// spec defines the desired state of BackendTrafficPolicy.
	spec: #BackendTrafficPolicySpec @go(Spec)

	// status defines the current status of BackendTrafficPolicy.
	status?: gwapiv1a2.#PolicyStatus @go(Status)
}

// BackendTrafficPolicySpec defines the desired state of BackendTrafficPolicy.
//
// +kubebuilder:validation:XValidation:rule="(has(self.targetRef) && !has(self.targetRefs)) || (!has(self.targetRef) && has(self.targetRefs)) || (has(self.targetSelectors) && self.targetSelectors.size() > 0) ", message="either targetRef or targetRefs must be used"
// +kubebuilder:validation:XValidation:rule="has(self.targetRef) ? self.targetRef.group == 'gateway.networking.k8s.io' : true ", message="this policy can only have a targetRef.group of gateway.networking.k8s.io"
// +kubebuilder:validation:XValidation:rule="has(self.targetRef) ? self.targetRef.kind in ['Gateway', 'HTTPRoute', 'GRPCRoute', 'UDPRoute', 'TCPRoute', 'TLSRoute'] : true", message="this policy can only have a targetRef.kind of Gateway/HTTPRoute/GRPCRoute/TCPRoute/UDPRoute/TLSRoute"
// +kubebuilder:validation:XValidation:rule="has(self.targetRef) ? !has(self.targetRef.sectionName) : true",message="this policy does not yet support the sectionName field"
// +kubebuilder:validation:XValidation:rule="has(self.targetRefs) ? self.targetRefs.all(ref, ref.group == 'gateway.networking.k8s.io') : true ", message="this policy can only have a targetRefs[*].group of gateway.networking.k8s.io"
// +kubebuilder:validation:XValidation:rule="has(self.targetRefs) ? self.targetRefs.all(ref, ref.kind in ['Gateway', 'HTTPRoute', 'GRPCRoute', 'UDPRoute', 'TCPRoute', 'TLSRoute']) : true ", message="this policy can only have a targetRefs[*].kind of Gateway/HTTPRoute/GRPCRoute/TCPRoute/UDPRoute/TLSRoute"
// +kubebuilder:validation:XValidation:rule="has(self.targetRefs) ? self.targetRefs.all(ref, !has(ref.sectionName)) : true",message="this policy does not yet support the sectionName field"
#BackendTrafficPolicySpec: {
	#PolicyTargetReferences

	#ClusterSettings

	// MergeType determines how this configuration is merged with existing BackendTrafficPolicy
	// configurations targeting a parent resource. When set, this configuration will be merged
	// into a parent BackendTrafficPolicy (i.e. the one targeting a Gateway or Listener).
	// This field cannot be set when targeting a parent resource (Gateway).
	// If unset, no merging occurs, and only the most specific configuration takes effect.
	// +optional
	mergeType?: null | #MergeType @go(MergeType,*MergeType)

	// RateLimit allows the user to limit the number of incoming requests
	// to a predefined value based on attributes within the traffic flow.
	// +optional
	rateLimit?: null | #RateLimitSpec @go(RateLimit,*RateLimitSpec)

	// FaultInjection defines the fault injection policy to be applied. This configuration can be used to
	// inject delays and abort requests to mimic failure scenarios such as service failures and overloads
	// +optional
	faultInjection?: null | #FaultInjection @go(FaultInjection,*FaultInjection)

	// UseClientProtocol configures Envoy to prefer sending requests to backends using
	// the same HTTP protocol that the incoming request used. Defaults to false, which means
	// that Envoy will use the protocol indicated by the attached BackendRef.
	//
	// +optional
	useClientProtocol?: null | bool @go(UseClientProtocol,*bool)

	// The compression config for the http streams.
	//
	// +optional
	compression?: [...null | #Compression] @go(Compression,[]*Compression)

	// ResponseOverride defines the configuration to override specific responses with a custom one.
	// If multiple configurations are specified, the first one to match wins.
	//
	// +optional
	responseOverride?: [...null | #ResponseOverride] @go(ResponseOverride,[]*ResponseOverride)

	// HTTPUpgrade defines the configuration for HTTP protocol upgrades.
	// If not specified, the default upgrade configuration(websocket) will be used.
	//
	// +patchMergeKey=type
	// +patchStrategy=merge
	//
	// +optional
	httpUpgrade?: [...null | #ProtocolUpgradeConfig] @go(HTTPUpgrade,[]*ProtocolUpgradeConfig)

	// RequestBuffer allows the gateway to buffer and fully receive each request from a client before continuing to send the request
	// upstream to the backends. This can be helpful to shield your backend servers from slow clients, and also to enforce a maximum size per request
	// as any requests larger than the buffer size will be rejected.
	//
	// This can have a negative performance impact so should only be enabled when necessary.
	//
	// When enabling this option, you should also configure your connection buffer size to account for these request buffers. There will also be an
	// increase in memory usage for Envoy that should be accounted for in your deployment settings.
	//
	// +notImplementedHide
	// +optional
	requestBuffer?: null | #RequestBuffer @go(RequestBuffer,*RequestBuffer)

	// Telemetry configures the telemetry settings for the policy target (Gateway or xRoute).
	// This will override the telemetry settings in the EnvoyProxy resource.
	//
	// +optional
	telemetry?: null | #BackendTelemetry @go(Telemetry,*BackendTelemetry)
}

#BackendTelemetry: {
	// Tracing configures the tracing settings for the backend or HTTPRoute.
	//
	// +optional
	tracing?: null | #Tracing @go(Tracing,*Tracing)
}

#ProtocolUpgradeConfig: {
	// Type is the case-insensitive type of protocol upgrade.
	// e.g. `websocket`, `CONNECT`, `spdy/3.1` etc.
	//
	// +kubebuilder:validation:Required
	type: string @go(Type)
}

#RequestBuffer: {
	// Limit specifies the maximum allowed size in bytes for each incoming request buffer.
	// If exceeded, the request will be rejected with HTTP 413 Content Too Large.
	//
	// Accepts values in resource.Quantity format (e.g., "10Mi", "500Ki").
	//
	// +kubebuilder:validation:XIntOrString
	// +kubebuilder:validation:Pattern="^[1-9]+[0-9]*([EPTGMK]i|[EPTGMk])?$"
	// +notImplementedHide
	limit?: resource.#Quantity @go(Limit)
}

// BackendTrafficPolicyList contains a list of BackendTrafficPolicy resources.
//
// +kubebuilder:object:root=true
#BackendTrafficPolicyList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#BackendTrafficPolicy] @go(Items,[]BackendTrafficPolicy)
}
