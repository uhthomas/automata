// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1

package v1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	cmacme "github.com/cert-manager/cert-manager/pkg/apis/acme/v1"
	cmmeta "github.com/cert-manager/cert-manager/pkg/apis/meta/v1"
)

// A ClusterIssuer represents a certificate issuing authority which can be
// referenced as part of `issuerRef` fields.
// It is similar to an Issuer, however it is cluster-scoped and therefore can
// be referenced by resources that exist in *any* namespace, not just the same
// namespace as the referent.
#ClusterIssuer: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Desired state of the ClusterIssuer resource.
	spec: #IssuerSpec @go(Spec)

	// Status of the ClusterIssuer. This is set and managed automatically.
	// +optional
	status?: #IssuerStatus @go(Status)
}

// ClusterIssuerList is a list of Issuers
#ClusterIssuerList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta)
	items: [...#ClusterIssuer] @go(Items,[]ClusterIssuer)
}

// An Issuer represents a certificate issuing authority which can be
// referenced as part of `issuerRef` fields.
// It is scoped to a single namespace and can therefore only be referenced by
// resources within the same namespace.
#Issuer: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Desired state of the Issuer resource.
	spec: #IssuerSpec @go(Spec)

	// Status of the Issuer. This is set and managed automatically.
	// +optional
	status?: #IssuerStatus @go(Status)
}

// IssuerList is a list of Issuers
#IssuerList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta)
	items: [...#Issuer] @go(Items,[]Issuer)
}

// IssuerSpec is the specification of an Issuer. This includes any
// configuration required for the issuer.
#IssuerSpec: {
	#IssuerConfig
}

// The configuration for the issuer.
// Only one of these can be set.
#IssuerConfig: {
	// ACME configures this issuer to communicate with a RFC8555 (ACME) server
	// to obtain signed x509 certificates.
	// +optional
	acme?: null | cmacme.#ACMEIssuer @go(ACME,*cmacme.ACMEIssuer)

	// CA configures this issuer to sign certificates using a signing CA keypair
	// stored in a Secret resource.
	// This is used to build internal PKIs that are managed by cert-manager.
	// +optional
	ca?: null | #CAIssuer @go(CA,*CAIssuer)

	// Vault configures this issuer to sign certificates using a HashiCorp Vault
	// PKI backend.
	// +optional
	vault?: null | #VaultIssuer @go(Vault,*VaultIssuer)

	// SelfSigned configures this issuer to 'self sign' certificates using the
	// private key used to create the CertificateRequest object.
	// +optional
	selfSigned?: null | #SelfSignedIssuer @go(SelfSigned,*SelfSignedIssuer)

	// Venafi configures this issuer to sign certificates using a Venafi TPP
	// or Venafi Cloud policy zone.
	// +optional
	venafi?: null | #VenafiIssuer @go(Venafi,*VenafiIssuer)
}

// Configures an issuer to sign certificates using a Venafi TPP
// or Cloud policy zone.
#VenafiIssuer: {
	// Zone is the Venafi Policy Zone to use for this issuer.
	// All requests made to the Venafi platform will be restricted by the named
	// zone policy.
	// This field is required.
	zone: string @go(Zone)

	// TPP specifies Trust Protection Platform configuration settings.
	// Only one of TPP or Cloud may be specified.
	// +optional
	tpp?: null | #VenafiTPP @go(TPP,*VenafiTPP)

	// Cloud specifies the Venafi cloud configuration settings.
	// Only one of TPP or Cloud may be specified.
	// +optional
	cloud?: null | #VenafiCloud @go(Cloud,*VenafiCloud)
}

// VenafiTPP defines connection configuration details for a Venafi TPP instance
#VenafiTPP: {
	// URL is the base URL for the vedsdk endpoint of the Venafi TPP instance,
	// for example: "https://tpp.example.com/vedsdk".
	url: string @go(URL)

	// CredentialsRef is a reference to a Secret containing the username and
	// password for the TPP server.
	// The secret must contain two keys, 'username' and 'password'.
	credentialsRef: cmmeta.#LocalObjectReference @go(CredentialsRef)

	// Base64-encoded bundle of PEM CAs which will be used to validate the certificate
	// chain presented by the TPP server. Only used if using HTTPS; ignored for HTTP.
	// If undefined, the certificate bundle in the cert-manager controller container
	// is used to validate the chain.
	// +optional
	caBundle?: bytes @go(CABundle,[]byte)
}

// VenafiCloud defines connection configuration details for Venafi Cloud
#VenafiCloud: {
	// URL is the base URL for Venafi Cloud.
	// Defaults to "https://api.venafi.cloud/v1".
	// +optional
	url?: string @go(URL)

	// APITokenSecretRef is a secret key selector for the Venafi Cloud API token.
	apiTokenSecretRef: cmmeta.#SecretKeySelector @go(APITokenSecretRef)
}

// Configures an issuer to 'self sign' certificates using the
// private key used to create the CertificateRequest object.
#SelfSignedIssuer: {
	// The CRL distribution points is an X.509 v3 certificate extension which identifies
	// the location of the CRL from which the revocation of this certificate can be checked.
	// If not set certificate will be issued without CDP. Values are strings.
	// +optional
	crlDistributionPoints?: [...string] @go(CRLDistributionPoints,[]string)
}

// Configures an issuer to sign certificates using a HashiCorp Vault
// PKI backend.
#VaultIssuer: {
	// Auth configures how cert-manager authenticates with the Vault server.
	auth: #VaultAuth @go(Auth)

	// Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
	server: string @go(Server)

	// Path is the mount path of the Vault PKI backend's `sign` endpoint, e.g:
	// "my_pki_mount/sign/my-role-name".
	path: string @go(Path)

	// Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1"
	// More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
	// +optional
	namespace?: string @go(Namespace)

	// Base64-encoded bundle of PEM CAs which will be used to validate the certificate
	// chain presented by Vault. Only used if using HTTPS to connect to Vault and
	// ignored for HTTP connections.
	// Mutually exclusive with CABundleSecretRef.
	// If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in
	// the cert-manager controller container is used to validate the TLS connection.
	// +optional
	caBundle?: bytes @go(CABundle,[]byte)

	// Reference to a Secret containing a bundle of PEM-encoded CAs to use when
	// verifying the certificate chain presented by Vault when using HTTPS.
	// Mutually exclusive with CABundle.
	// If neither CABundle nor CABundleSecretRef are defined, the certificate bundle in
	// the cert-manager controller container is used to validate the TLS connection.
	// If no key for the Secret is specified, cert-manager will default to 'ca.crt'.
	// +optional
	caBundleSecretRef?: null | cmmeta.#SecretKeySelector @go(CABundleSecretRef,*cmmeta.SecretKeySelector)

	// Reference to a Secret containing a PEM-encoded Client Certificate to use when the
	// Vault server requires mTLS.
	// +optional
	clientCertSecretRef?: null | cmmeta.#SecretKeySelector @go(ClientCertSecretRef,*cmmeta.SecretKeySelector)

	// Reference to a Secret containing a PEM-encoded Client Private Key to use when the
	// Vault server requires mTLS.
	// +optional
	clientKeySecretRef?: null | cmmeta.#SecretKeySelector @go(ClientKeySecretRef,*cmmeta.SecretKeySelector)
}

// VaultAuth is configuration used to authenticate with a Vault server. The
// order of precedence is [`tokenSecretRef`, `appRole` or `kubernetes`].
#VaultAuth: {
	// TokenSecretRef authenticates with Vault by presenting a token.
	// +optional
	tokenSecretRef?: null | cmmeta.#SecretKeySelector @go(TokenSecretRef,*cmmeta.SecretKeySelector)

	// AppRole authenticates with Vault using the App Role auth mechanism,
	// with the role and secret stored in a Kubernetes Secret resource.
	// +optional
	appRole?: null | #VaultAppRole @go(AppRole,*VaultAppRole)

	// Kubernetes authenticates with Vault by passing the ServiceAccount
	// token stored in the named Secret resource to the Vault server.
	// +optional
	kubernetes?: null | #VaultKubernetesAuth @go(Kubernetes,*VaultKubernetesAuth)
}

// VaultAppRole authenticates with Vault using the App Role auth mechanism,
// with the role and secret stored in a Kubernetes Secret resource.
#VaultAppRole: {
	// Path where the App Role authentication backend is mounted in Vault, e.g:
	// "approle"
	path: string @go(Path)

	// RoleID configured in the App Role authentication backend when setting
	// up the authentication backend in Vault.
	roleId: string @go(RoleId)

	// Reference to a key in a Secret that contains the App Role secret used
	// to authenticate with Vault.
	// The `key` field must be specified and denotes which entry within the Secret
	// resource is used as the app role secret.
	secretRef: cmmeta.#SecretKeySelector @go(SecretRef)
}

// Authenticate against Vault using a Kubernetes ServiceAccount token stored in
// a Secret.
#VaultKubernetesAuth: {
	// The Vault mountPath here is the mount path to use when authenticating with
	// Vault. For example, setting a value to `/v1/auth/foo`, will use the path
	// `/v1/auth/foo/login` to authenticate with Vault. If unspecified, the
	// default value "/v1/auth/kubernetes" will be used.
	// +optional
	mountPath?: string @go(Path)

	// The required Secret field containing a Kubernetes ServiceAccount JWT used
	// for authenticating with Vault. Use of 'ambient credentials' is not
	// supported.
	// +optional
	secretRef?: cmmeta.#SecretKeySelector @go(SecretRef)

	// A reference to a service account that will be used to request a bound
	// token (also known as "projected token"). Compared to using "secretRef",
	// using this field means that you don't rely on statically bound tokens. To
	// use this field, you must configure an RBAC rule to let cert-manager
	// request a token.
	// +optional
	serviceAccountRef?: null | #ServiceAccountRef @go(ServiceAccountRef,*ServiceAccountRef)

	// A required field containing the Vault Role to assume. A Role binds a
	// Kubernetes ServiceAccount with a set of Vault policies.
	role: string @go(Role)
}

// ServiceAccountRef is a service account used by cert-manager to request a
// token. Default audience is generated by
// cert-manager and takes the form `vault://namespace-name/issuer-name` for an
// Issuer and `vault://issuer-name` for a ClusterIssuer. The expiration of the
// token is also set by cert-manager to 10 minutes.
#ServiceAccountRef: {
	// Name of the ServiceAccount used to request a token.
	name: string @go(Name)

	// TokenAudiences is an optional list of extra audiences to include in the token passed to Vault. The default token
	// consisting of the issuer's namespace and name is always included.
	// +optional
	audiences?: [...string] @go(TokenAudiences,[]string)
}

#CAIssuer: {
	// SecretName is the name of the secret used to sign Certificates issued
	// by this Issuer.
	secretName: string @go(SecretName)

	// The CRL distribution points is an X.509 v3 certificate extension which identifies
	// the location of the CRL from which the revocation of this certificate can be checked.
	// If not set, certificates will be issued without distribution points set.
	// +optional
	crlDistributionPoints?: [...string] @go(CRLDistributionPoints,[]string)

	// The OCSP server list is an X.509 v3 extension that defines a list of
	// URLs of OCSP responders. The OCSP responders can be queried for the
	// revocation status of an issued certificate. If not set, the
	// certificate will be issued with no OCSP servers set. For example, an
	// OCSP server URL could be "http://ocsp.int-x3.letsencrypt.org".
	// +optional
	ocspServers?: [...string] @go(OCSPServers,[]string)

	// IssuingCertificateURLs is a list of URLs which this issuer should embed into certificates
	// it creates. See https://www.rfc-editor.org/rfc/rfc5280#section-4.2.2.1 for more details.
	// As an example, such a URL might be "http://ca.domain.com/ca.crt".
	// +optional
	issuingCertificateURLs?: [...string] @go(IssuingCertificateURLs,[]string)
}

// IssuerStatus contains status information about an Issuer
#IssuerStatus: {
	// List of status conditions to indicate the status of a CertificateRequest.
	// Known condition types are `Ready`.
	// +listType=map
	// +listMapKey=type
	// +optional
	conditions?: [...#IssuerCondition] @go(Conditions,[]IssuerCondition)

	// ACME specific status options.
	// This field should only be set if the Issuer is configured to use an ACME
	// server to issue certificates.
	// +optional
	acme?: null | cmacme.#ACMEIssuerStatus @go(ACME,*cmacme.ACMEIssuerStatus)
}

// IssuerCondition contains condition information for an Issuer.
#IssuerCondition: {
	// Type of the condition, known values are (`Ready`).
	type: #IssuerConditionType @go(Type)

	// Status of the condition, one of (`True`, `False`, `Unknown`).
	status: cmmeta.#ConditionStatus @go(Status)

	// LastTransitionTime is the timestamp corresponding to the last status
	// change of this condition.
	// +optional
	lastTransitionTime?: null | metav1.#Time @go(LastTransitionTime,*metav1.Time)

	// Reason is a brief machine readable explanation for the condition's last
	// transition.
	// +optional
	reason?: string @go(Reason)

	// Message is a human readable description of the details of the last
	// transition, complementing reason.
	// +optional
	message?: string @go(Message)

	// If set, this represents the .metadata.generation that the condition was
	// set based upon.
	// For instance, if .metadata.generation is currently 12, but the
	// .status.condition[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the Issuer.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration)
}

// IssuerConditionType represents an Issuer condition value.
#IssuerConditionType: string // #enumIssuerConditionType

#enumIssuerConditionType:
	#IssuerConditionReady

// IssuerConditionReady represents the fact that a given Issuer condition
// is in ready state and able to issue certificates.
// If the `status` of this condition is `False`, CertificateRequest controllers
// should prevent attempts to sign certificates.
#IssuerConditionReady: #IssuerConditionType & "Ready"
