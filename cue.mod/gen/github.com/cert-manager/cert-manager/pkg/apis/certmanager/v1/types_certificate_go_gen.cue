// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1

package v1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	cmmeta "github.com/cert-manager/cert-manager/pkg/apis/meta/v1"
)

// A Certificate resource should be created to ensure an up to date and signed
// X.509 certificate is stored in the Kubernetes Secret resource named in `spec.secretName`.
//
// The stored certificate will be renewed before it expires (as configured by `spec.renewBefore`).
#Certificate: {
	metav1.#TypeMeta

	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Specification of the desired state of the Certificate resource.
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	spec?: #CertificateSpec @go(Spec)

	// Status of the Certificate.
	// This is set and managed automatically.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	status?: #CertificateStatus @go(Status)
}

// CertificateList is a list of Certificates.
#CertificateList: {
	metav1.#TypeMeta

	// Standard list metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	// +optional
	metadata?: metav1.#ListMeta @go(ListMeta)

	// List of Certificates
	items: [...#Certificate] @go(Items,[]Certificate)
}

// +kubebuilder:validation:Enum=RSA;ECDSA;Ed25519
#PrivateKeyAlgorithm: string // #enumPrivateKeyAlgorithm

#enumPrivateKeyAlgorithm:
	#RSAKeyAlgorithm |
	#ECDSAKeyAlgorithm |
	#Ed25519KeyAlgorithm

// RSA private key algorithm.
#RSAKeyAlgorithm: #PrivateKeyAlgorithm & "RSA"

// ECDSA private key algorithm.
#ECDSAKeyAlgorithm: #PrivateKeyAlgorithm & "ECDSA"

// Ed25519 private key algorithm.
#Ed25519KeyAlgorithm: #PrivateKeyAlgorithm & "Ed25519"

// +kubebuilder:validation:Enum=PKCS1;PKCS8
#PrivateKeyEncoding: string // #enumPrivateKeyEncoding

#enumPrivateKeyEncoding:
	#PKCS1 |
	#PKCS8

// PKCS1 private key encoding.
// PKCS1 produces a PEM block that contains the private key algorithm
// in the header and the private key in the body. A key that uses this
// can be recognised by its `BEGIN RSA PRIVATE KEY` or `BEGIN EC PRIVATE KEY` header.
// NOTE: This encoding is not supported for Ed25519 keys. Attempting to use
// this encoding with an Ed25519 key will be ignored and default to PKCS8.
#PKCS1: #PrivateKeyEncoding & "PKCS1"

// PKCS8 private key encoding.
// PKCS8 produces a PEM block with a static header and both the private
// key algorithm and the private key in the body. A key that uses this
// encoding can be recognised by its `BEGIN PRIVATE KEY` header.
#PKCS8: #PrivateKeyEncoding & "PKCS8"

// CertificateSpec defines the desired state of Certificate.
//
// NOTE: The specification contains a lot of "requested" certificate attributes, it is
// important to note that the issuer can choose to ignore or change any of
// these requested attributes. How the issuer maps a certificate request to a
// signed certificate is the full responsibility of the issuer itself. For example,
// as an edge case, an issuer that inverts the isCA value is free to do so.
//
// A valid Certificate requires at least one of a CommonName, LiteralSubject, DNSName, or
// URI to be valid.
#CertificateSpec: {
	// Requested set of X509 certificate subject attributes.
	// More info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6
	//
	// The common name attribute is specified separately in the `commonName` field.
	// Cannot be set if the `literalSubject` field is set.
	// +optional
	subject?: null | #X509Subject @go(Subject,*X509Subject)

	// Requested X.509 certificate subject, represented using the LDAP "String
	// Representation of a Distinguished Name" [1].
	// Important: the LDAP string format also specifies the order of the attributes
	// in the subject, this is important when issuing certs for LDAP authentication.
	// Example: `CN=foo,DC=corp,DC=example,DC=com`
	// More info [1]: https://datatracker.ietf.org/doc/html/rfc4514
	// More info: https://github.com/cert-manager/cert-manager/issues/3203
	// More info: https://github.com/cert-manager/cert-manager/issues/4424
	//
	// Cannot be set if the `subject` or `commonName` field is set.
	// +optional
	literalSubject?: string @go(LiteralSubject)

	// Requested common name X509 certificate subject attribute.
	// More info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6
	// NOTE: TLS clients will ignore this value when any subject alternative name is
	// set (see https://tools.ietf.org/html/rfc6125#section-6.4.4).
	//
	// Should have a length of 64 characters or fewer to avoid generating invalid CSRs.
	// Cannot be set if the `literalSubject` field is set.
	// +optional
	commonName?: string @go(CommonName)

	// Requested 'duration' (i.e. lifetime) of the Certificate. Note that the
	// issuer may choose to ignore the requested duration, just like any other
	// requested attribute.
	//
	// If unset, this defaults to 90 days.
	// Minimum accepted duration is 1 hour.
	// Value must be in units accepted by Go time.ParseDuration https://golang.org/pkg/time/#ParseDuration.
	// +optional
	duration?: null | metav1.#Duration @go(Duration,*metav1.Duration)

	// How long before the currently issued certificate's expiry cert-manager should
	// renew the certificate. For example, if a certificate is valid for 60 minutes,
	// and `renewBefore=10m`, cert-manager will begin to attempt to renew the certificate
	// 50 minutes after it was issued (i.e. when there are 10 minutes remaining until
	// the certificate is no longer valid).
	//
	// NOTE: The actual lifetime of the issued certificate is used to determine the
	// renewal time. If an issuer returns a certificate with a different lifetime than
	// the one requested, cert-manager will use the lifetime of the issued certificate.
	//
	// If unset, this defaults to 1/3 of the issued certificate's lifetime.
	// Minimum accepted value is 5 minutes.
	// Value must be in units accepted by Go time.ParseDuration https://golang.org/pkg/time/#ParseDuration.
	// +optional
	renewBefore?: null | metav1.#Duration @go(RenewBefore,*metav1.Duration)

	// Requested DNS subject alternative names.
	// +optional
	dnsNames?: [...string] @go(DNSNames,[]string)

	// Requested IP address subject alternative names.
	// +optional
	ipAddresses?: [...string] @go(IPAddresses,[]string)

	// Requested URI subject alternative names.
	// +optional
	uris?: [...string] @go(URIs,[]string)

	// `otherNames` is an escape hatch for SAN that allows any type. We currently restrict the support to string like otherNames, cf RFC 5280 p 37
	// Any UTF8 String valued otherName can be passed with by setting the keys oid: x.x.x.x and UTF8Value: somevalue for `otherName`.
	// Most commonly this would be UPN set with oid: 1.3.6.1.4.1.311.20.2.3
	// You should ensure that any OID passed is valid for the UTF8String type as we do not explicitly validate this.
	// +optional
	otherNames?: [...#OtherName] @go(OtherNames,[]OtherName)

	// Requested email subject alternative names.
	// +optional
	emailAddresses?: [...string] @go(EmailAddresses,[]string)

	// Name of the Secret resource that will be automatically created and
	// managed by this Certificate resource. It will be populated with a
	// private key and certificate, signed by the denoted issuer. The Secret
	// resource lives in the same namespace as the Certificate resource.
	secretName: string @go(SecretName)

	// Defines annotations and labels to be copied to the Certificate's Secret.
	// Labels and annotations on the Secret will be changed as they appear on the
	// SecretTemplate when added or removed. SecretTemplate annotations are added
	// in conjunction with, and cannot overwrite, the base set of annotations
	// cert-manager sets on the Certificate's Secret.
	// +optional
	secretTemplate?: null | #CertificateSecretTemplate @go(SecretTemplate,*CertificateSecretTemplate)

	// Additional keystore output formats to be stored in the Certificate's Secret.
	// +optional
	keystores?: null | #CertificateKeystores @go(Keystores,*CertificateKeystores)

	// Reference to the issuer responsible for issuing the certificate.
	// If the issuer is namespace-scoped, it must be in the same namespace
	// as the Certificate. If the issuer is cluster-scoped, it can be used
	// from any namespace.
	//
	// The `name` field of the reference must always be specified.
	issuerRef: cmmeta.#ObjectReference @go(IssuerRef)

	// Requested basic constraints isCA value.
	// The isCA value is used to set the `isCA` field on the created CertificateRequest
	// resources. Note that the issuer may choose to ignore the requested isCA value, just
	// like any other requested attribute.
	//
	// If true, this will automatically add the `cert sign` usage to the list
	// of requested `usages`.
	// +optional
	isCA?: bool @go(IsCA)

	// Requested key usages and extended key usages.
	// These usages are used to set the `usages` field on the created CertificateRequest
	// resources. If `encodeUsagesInRequest` is unset or set to `true`, the usages
	// will additionally be encoded in the `request` field which contains the CSR blob.
	//
	// If unset, defaults to `digital signature` and `key encipherment`.
	// +optional
	usages?: [...#KeyUsage] @go(Usages,[]KeyUsage)

	// Private key options. These include the key algorithm and size, the used
	// encoding and the rotation policy.
	// +optional
	privateKey?: null | #CertificatePrivateKey @go(PrivateKey,*CertificatePrivateKey)

	// Whether the KeyUsage and ExtKeyUsage extensions should be set in the encoded CSR.
	//
	// This option defaults to true, and should only be disabled if the target
	// issuer does not support CSRs with these X509 KeyUsage/ ExtKeyUsage extensions.
	// +optional
	encodeUsagesInRequest?: null | bool @go(EncodeUsagesInRequest,*bool)

	// The maximum number of CertificateRequest revisions that are maintained in
	// the Certificate's history. Each revision represents a single `CertificateRequest`
	// created by this Certificate, either when it was created, renewed, or Spec
	// was changed. Revisions will be removed by oldest first if the number of
	// revisions exceeds this number.
	//
	// If set, revisionHistoryLimit must be a value of `1` or greater.
	// If unset (`nil`), revisions will not be garbage collected.
	// Default value is `nil`.
	// +optional
	revisionHistoryLimit?: null | int32 @go(RevisionHistoryLimit,*int32)

	// Defines extra output formats of the private key and signed certificate chain
	// to be written to this Certificate's target Secret.
	//
	// This is a Beta Feature enabled by default. It can be disabled with the
	// `--feature-gates=AdditionalCertificateOutputFormats=false` option set on both
	// the controller and webhook components.
	// +optional
	additionalOutputFormats?: [...#CertificateAdditionalOutputFormat] @go(AdditionalOutputFormats,[]CertificateAdditionalOutputFormat)

	// x.509 certificate NameConstraint extension which MUST NOT be used in a non-CA certificate.
	// More Info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.10
	//
	// This is an Alpha Feature and is only enabled with the
	// `--feature-gates=NameConstraints=true` option set on both
	// the controller and webhook components.
	// +optional
	nameConstraints?: null | #NameConstraints @go(NameConstraints,*NameConstraints)
}

#OtherName: {
	// OID is the object identifier for the otherName SAN.
	// The object identifier must be expressed as a dotted string, for
	// example, "1.2.840.113556.1.4.221".
	oid?: string @go(OID)

	// utf8Value is the string value of the otherName SAN.
	// The utf8Value accepts any valid UTF8 string to set as value for the otherName SAN.
	utf8Value?: string @go(UTF8Value)
}

// CertificatePrivateKey contains configuration options for private keys
// used by the Certificate controller.
// These include the key algorithm and size, the used encoding and the
// rotation policy.
#CertificatePrivateKey: {
	// RotationPolicy controls how private keys should be regenerated when a
	// re-issuance is being processed.
	//
	// If set to `Never`, a private key will only be generated if one does not
	// already exist in the target `spec.secretName`. If one does exists but it
	// does not have the correct algorithm or size, a warning will be raised
	// to await user intervention.
	// If set to `Always`, a private key matching the specified requirements
	// will be generated whenever a re-issuance occurs.
	// Default is `Never` for backward compatibility.
	// +optional
	rotationPolicy?: #PrivateKeyRotationPolicy @go(RotationPolicy)

	// The private key cryptography standards (PKCS) encoding for this
	// certificate's private key to be encoded in.
	//
	// If provided, allowed values are `PKCS1` and `PKCS8` standing for PKCS#1
	// and PKCS#8, respectively.
	// Defaults to `PKCS1` if not specified.
	// +optional
	encoding?: #PrivateKeyEncoding @go(Encoding)

	// Algorithm is the private key algorithm of the corresponding private key
	// for this certificate.
	//
	// If provided, allowed values are either `RSA`, `ECDSA` or `Ed25519`.
	// If `algorithm` is specified and `size` is not provided,
	// key size of 2048 will be used for `RSA` key algorithm and
	// key size of 256 will be used for `ECDSA` key algorithm.
	// key size is ignored when using the `Ed25519` key algorithm.
	// +optional
	algorithm?: #PrivateKeyAlgorithm @go(Algorithm)

	// Size is the key bit size of the corresponding private key for this certificate.
	//
	// If `algorithm` is set to `RSA`, valid values are `2048`, `4096` or `8192`,
	// and will default to `2048` if not specified.
	// If `algorithm` is set to `ECDSA`, valid values are `256`, `384` or `521`,
	// and will default to `256` if not specified.
	// If `algorithm` is set to `Ed25519`, Size is ignored.
	// No other values are allowed.
	// +optional
	size?: int @go(Size)
}

// Denotes how private keys should be generated or sourced when a Certificate
// is being issued.
// +kubebuilder:validation:Enum=Never;Always
#PrivateKeyRotationPolicy: string

// CertificateOutputFormatType specifies which additional output formats should
// be written to the Certificate's target Secret.
// Allowed values are `DER` or `CombinedPEM`.
// When Type is set to `DER` an additional entry `key.der` will be written to
// the Secret, containing the binary format of the private key.
// When Type is set to `CombinedPEM` an additional entry `tls-combined.pem`
// will be written to the Secret, containing the PEM formatted private key and
// signed certificate chain (tls.key + tls.crt concatenated).
// +kubebuilder:validation:Enum=DER;CombinedPEM
#CertificateOutputFormatType: string // #enumCertificateOutputFormatType

#enumCertificateOutputFormatType:
	#CertificateOutputFormatDER |
	#CertificateOutputFormatCombinedPEM

// CertificateOutputFormatDERKey is the name of the data entry in the Secret
// resource used to store the DER formatted private key.
#CertificateOutputFormatDERKey: "key.der"

// CertificateOutputFormatDER  writes the Certificate's private key in DER
// binary format to the `key.der` target Secret Data key.
#CertificateOutputFormatDER: #CertificateOutputFormatType & "DER"

// CertificateOutputFormatCombinedPEMKey is the name of the data entry in the Secret
// resource used to store the combined PEM (key + signed certificate).
#CertificateOutputFormatCombinedPEMKey: "tls-combined.pem"

// CertificateOutputFormatCombinedPEM  writes the Certificate's signed
// certificate chain and private key, in PEM format, to the
// `tls-combined.pem` target Secret Data key. The value at this key will
// include the private key PEM document, followed by at least one new line
// character, followed by the chain of signed certificate PEM documents
// (`<private key> + \n + <signed certificate chain>`).
#CertificateOutputFormatCombinedPEM: #CertificateOutputFormatType & "CombinedPEM"

// CertificateAdditionalOutputFormat defines an additional output format of a
// Certificate resource. These contain supplementary data formats of the signed
// certificate chain and paired private key.
#CertificateAdditionalOutputFormat: {
	// Type is the name of the format type that should be written to the
	// Certificate's target Secret.
	type: #CertificateOutputFormatType @go(Type)
}

// X509Subject Full X509 name specification
#X509Subject: {
	// Organizations to be used on the Certificate.
	// +optional
	organizations?: [...string] @go(Organizations,[]string)

	// Countries to be used on the Certificate.
	// +optional
	countries?: [...string] @go(Countries,[]string)

	// Organizational Units to be used on the Certificate.
	// +optional
	organizationalUnits?: [...string] @go(OrganizationalUnits,[]string)

	// Cities to be used on the Certificate.
	// +optional
	localities?: [...string] @go(Localities,[]string)

	// State/Provinces to be used on the Certificate.
	// +optional
	provinces?: [...string] @go(Provinces,[]string)

	// Street addresses to be used on the Certificate.
	// +optional
	streetAddresses?: [...string] @go(StreetAddresses,[]string)

	// Postal codes to be used on the Certificate.
	// +optional
	postalCodes?: [...string] @go(PostalCodes,[]string)

	// Serial number to be used on the Certificate.
	// +optional
	serialNumber?: string @go(SerialNumber)
}

// CertificateKeystores configures additional keystore output formats to be
// created in the Certificate's output Secret.
#CertificateKeystores: {
	// JKS configures options for storing a JKS keystore in the
	// `spec.secretName` Secret resource.
	// +optional
	jks?: null | #JKSKeystore @go(JKS,*JKSKeystore)

	// PKCS12 configures options for storing a PKCS12 keystore in the
	// `spec.secretName` Secret resource.
	// +optional
	pkcs12?: null | #PKCS12Keystore @go(PKCS12,*PKCS12Keystore)
}

// JKS configures options for storing a JKS keystore in the `spec.secretName`
// Secret resource.
#JKSKeystore: {
	// Create enables JKS keystore creation for the Certificate.
	// If true, a file named `keystore.jks` will be created in the target
	// Secret resource, encrypted using the password stored in
	// `passwordSecretRef`.
	// The keystore file will be updated immediately.
	// If the issuer provided a CA certificate, a file named `truststore.jks`
	// will also be created in the target Secret resource, encrypted using the
	// password stored in `passwordSecretRef`
	// containing the issuing Certificate Authority
	create: bool @go(Create)

	// PasswordSecretRef is a reference to a key in a Secret resource
	// containing the password used to encrypt the JKS keystore.
	passwordSecretRef: cmmeta.#SecretKeySelector @go(PasswordSecretRef)

	// Alias specifies the alias of the key in the keystore, required by the JKS format.
	// If not provided, the default alias `certificate` will be used.
	// +optional
	alias?: null | string @go(Alias,*string)
}

// PKCS12 configures options for storing a PKCS12 keystore in the
// `spec.secretName` Secret resource.
#PKCS12Keystore: {
	// Create enables PKCS12 keystore creation for the Certificate.
	// If true, a file named `keystore.p12` will be created in the target
	// Secret resource, encrypted using the password stored in
	// `passwordSecretRef`.
	// The keystore file will be updated immediately.
	// If the issuer provided a CA certificate, a file named `truststore.p12` will
	// also be created in the target Secret resource, encrypted using the
	// password stored in `passwordSecretRef` containing the issuing Certificate
	// Authority
	create: bool @go(Create)

	// PasswordSecretRef is a reference to a key in a Secret resource
	// containing the password used to encrypt the PKCS12 keystore.
	passwordSecretRef: cmmeta.#SecretKeySelector @go(PasswordSecretRef)

	// Profile specifies the key and certificate encryption algorithms and the HMAC algorithm
	// used to create the PKCS12 keystore. Default value is `LegacyRC2` for backward compatibility.
	//
	// If provided, allowed values are:
	// `LegacyRC2`: Deprecated. Not supported by default in OpenSSL 3 or Java 20.
	// `LegacyDES`: Less secure algorithm. Use this option for maximal compatibility.
	// `Modern2023`: Secure algorithm. Use this option in case you have to always use secure algorithms
	// (eg. because of company policy). Please note that the security of the algorithm is not that important
	// in reality, because the unencrypted certificate and private key are also stored in the Secret.
	// +optional
	profile?: #PKCS12Profile @go(Profile)
}

// +kubebuilder:validation:Enum=LegacyRC2;LegacyDES;Modern2023
#PKCS12Profile: string // #enumPKCS12Profile

#enumPKCS12Profile:
	#LegacyRC2PKCS12Profile |
	#LegacyDESPKCS12Profile |
	#Modern2023PKCS12Profile

// see: https://pkg.go.dev/software.sslmate.com/src/go-pkcs12#LegacyRC2
#LegacyRC2PKCS12Profile: #PKCS12Profile & "LegacyRC2"

// see: https://pkg.go.dev/software.sslmate.com/src/go-pkcs12#LegacyDES
#LegacyDESPKCS12Profile: #PKCS12Profile & "LegacyDES"

// see: https://pkg.go.dev/software.sslmate.com/src/go-pkcs12#Modern2023
#Modern2023PKCS12Profile: #PKCS12Profile & "Modern2023"

// CertificateStatus defines the observed state of Certificate
#CertificateStatus: {
	// List of status conditions to indicate the status of certificates.
	// Known condition types are `Ready` and `Issuing`.
	// +listType=map
	// +listMapKey=type
	// +optional
	conditions?: [...#CertificateCondition] @go(Conditions,[]CertificateCondition)

	// LastFailureTime is set only if the lastest issuance for this
	// Certificate failed and contains the time of the failure. If an
	// issuance has failed, the delay till the next issuance will be
	// calculated using formula time.Hour * 2 ^ (failedIssuanceAttempts -
	// 1). If the latest issuance has succeeded this field will be unset.
	// +optional
	lastFailureTime?: null | metav1.#Time @go(LastFailureTime,*metav1.Time)

	// The time after which the certificate stored in the secret named
	// by this resource in `spec.secretName` is valid.
	// +optional
	notBefore?: null | metav1.#Time @go(NotBefore,*metav1.Time)

	// The expiration time of the certificate stored in the secret named
	// by this resource in `spec.secretName`.
	// +optional
	notAfter?: null | metav1.#Time @go(NotAfter,*metav1.Time)

	// RenewalTime is the time at which the certificate will be next
	// renewed.
	// If not set, no upcoming renewal is scheduled.
	// +optional
	renewalTime?: null | metav1.#Time @go(RenewalTime,*metav1.Time)

	// The current 'revision' of the certificate as issued.
	//
	// When a CertificateRequest resource is created, it will have the
	// `cert-manager.io/certificate-revision` set to one greater than the
	// current value of this field.
	//
	// Upon issuance, this field will be set to the value of the annotation
	// on the CertificateRequest resource used to issue the certificate.
	//
	// Persisting the value on the CertificateRequest resource allows the
	// certificates controller to know whether a request is part of an old
	// issuance or if it is part of the ongoing revision's issuance by
	// checking if the revision value in the annotation is greater than this
	// field.
	// +optional
	revision?: null | int @go(Revision,*int)

	// The name of the Secret resource containing the private key to be used
	// for the next certificate iteration.
	// The keymanager controller will automatically set this field if the
	// `Issuing` condition is set to `True`.
	// It will automatically unset this field when the Issuing condition is
	// not set or False.
	// +optional
	nextPrivateKeySecretName?: null | string @go(NextPrivateKeySecretName,*string)

	// The number of continuous failed issuance attempts up till now. This
	// field gets removed (if set) on a successful issuance and gets set to
	// 1 if unset and an issuance has failed. If an issuance has failed, the
	// delay till the next issuance will be calculated using formula
	// time.Hour * 2 ^ (failedIssuanceAttempts - 1).
	// +optional
	failedIssuanceAttempts?: null | int @go(FailedIssuanceAttempts,*int)
}

// CertificateCondition contains condition information for an Certificate.
#CertificateCondition: {
	// Type of the condition, known values are (`Ready`, `Issuing`).
	type: #CertificateConditionType @go(Type)

	// Status of the condition, one of (`True`, `False`, `Unknown`).
	status: cmmeta.#ConditionStatus @go(Status)

	// LastTransitionTime is the timestamp corresponding to the last status
	// change of this condition.
	// +optional
	lastTransitionTime?: null | metav1.#Time @go(LastTransitionTime,*metav1.Time)

	// Reason is a brief machine readable explanation for the condition's last
	// transition.
	// +optional
	reason?: string @go(Reason)

	// Message is a human readable description of the details of the last
	// transition, complementing reason.
	// +optional
	message?: string @go(Message)

	// If set, this represents the .metadata.generation that the condition was
	// set based upon.
	// For instance, if .metadata.generation is currently 12, but the
	// .status.condition[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the Certificate.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration)
}

// CertificateConditionType represents an Certificate condition value.
#CertificateConditionType: string // #enumCertificateConditionType

#enumCertificateConditionType:
	#CertificateConditionReady |
	#CertificateConditionIssuing

// CertificateConditionReady indicates that a certificate is ready for use.
// This is defined as:
// - The target secret exists
// - The target secret contains a certificate that has not expired
// - The target secret contains a private key valid for the certificate
// - The commonName and dnsNames attributes match those specified on the Certificate
#CertificateConditionReady: #CertificateConditionType & "Ready"

// A condition added to Certificate resources when an issuance is required.
// This condition will be automatically added and set to true if:
//   * No keypair data exists in the target Secret
//   * The data stored in the Secret cannot be decoded
//   * The private key and certificate do not have matching public keys
//   * If a CertificateRequest for the current revision exists and the
//     certificate data stored in the Secret does not match the
//    `status.certificate` on the CertificateRequest.
//   * If no CertificateRequest resource exists for the current revision,
//     the options on the Certificate resource are compared against the
//     X.509 data in the Secret, similar to what's done in earlier versions.
//     If there is a mismatch, an issuance is triggered.
// This condition may also be added by external API consumers to trigger
// a re-issuance manually for any other reason.
//
// It will be removed by the 'issuing' controller upon completing issuance.
#CertificateConditionIssuing: #CertificateConditionType & "Issuing"

// CertificateSecretTemplate defines the default labels and annotations
// to be copied to the Kubernetes Secret resource named in `CertificateSpec.secretName`.
#CertificateSecretTemplate: {
	// Annotations is a key value map to be copied to the target Kubernetes Secret.
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string)

	// Labels is a key value map to be copied to the target Kubernetes Secret.
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string)
}

// NameConstraints is a type to represent x509 NameConstraints
#NameConstraints: {
	// if true then the name constraints are marked critical.
	//
	// +optional
	critical?: bool @go(Critical)

	// Permitted contains the constraints in which the names must be located.
	//
	// +optional
	permitted?: null | #NameConstraintItem @go(Permitted,*NameConstraintItem)

	// Excluded contains the constraints which must be disallowed. Any name matching a
	// restriction in the excluded field is invalid regardless
	// of information appearing in the permitted
	//
	// +optional
	excluded?: null | #NameConstraintItem @go(Excluded,*NameConstraintItem)
}

#NameConstraintItem: {
	// DNSDomains is a list of DNS domains that are permitted or excluded.
	//
	// +optional
	dnsDomains?: [...string] @go(DNSDomains,[]string)

	// IPRanges is a list of IP Ranges that are permitted or excluded.
	// This should be a valid CIDR notation.
	//
	// +optional
	ipRanges?: [...string] @go(IPRanges,[]string)

	// EmailAddresses is a list of Email Addresses that are permitted or excluded.
	//
	// +optional
	emailAddresses?: [...string] @go(EmailAddresses,[]string)

	// URIDomains is a list of URI domains that are permitted or excluded.
	//
	// +optional
	uriDomains?: [...string] @go(URIDomains,[]string)
}
