// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/spf13/pflag

// Package pflag is a drop-in replacement for Go's flag package, implementing
// POSIX/GNU-style --flags.
//
// pflag is compatible with the GNU extensions to the POSIX recommendations
// for command-line options. See
// http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
//
// Usage:
//
// pflag is a drop-in replacement of Go's native flag package. If you import
// pflag under the name "flag" then all code should continue to function
// with no changes.
//
// 	import flag "github.com/spf13/pflag"
//
// There is one exception to this: if you directly instantiate the Flag struct
// there is one more field "Shorthand" that you will need to set.
// Most code never instantiates this struct directly, and instead uses
// functions such as String(), BoolVar(), and Var(), and is therefore
// unaffected.
//
// Define flags using flag.String(), Bool(), Int(), etc.
//
// This declares an integer flag, -flagname, stored in the pointer ip, with type *int.
//
// 	var ip = flag.Int("flagname", 1234, "help message for flagname")
//
// If you like, you can bind the flag to a variable using the Var() functions.
//
// 	var flagvar int
// 	func init() {
// 		flag.IntVar(&flagvar, "flagname", 1234, "help message for flagname")
// 	}
//
// Or you can create custom flags that satisfy the Value interface (with
// pointer receivers) and couple them to flag parsing by
//
// 	flag.Var(&flagVal, "name", "help message for flagname")
//
// For such flags, the default value is just the initial value of the variable.
//
// After all flags are defined, call
//
// 	flag.Parse()
//
// to parse the command line into the defined flags.
//
// Flags may then be used directly. If you're using the flags themselves,
// they are all pointers; if you bind to variables, they're values.
//
// 	fmt.Println("ip has value ", *ip)
// 	fmt.Println("flagvar has value ", flagvar)
//
// After parsing, the arguments after the flag are available as the
// slice flag.Args() or individually as flag.Arg(i).
// The arguments are indexed from 0 through flag.NArg()-1.
//
// The pflag package also defines some new functions that are not in flag,
// that give one-letter shorthands for flags. You can use these by appending
// 'P' to the name of any function that defines a flag.
//
// 	var ip = flag.IntP("flagname", "f", 1234, "help message")
// 	var flagvar bool
// 	func init() {
// 		flag.BoolVarP(&flagvar, "boolname", "b", true, "help message")
// 	}
// 	flag.VarP(&flagval, "varname", "v", "help message")
//
// Shorthand letters can be used with single dashes on the command line.
// Boolean shorthand flags can be combined with other shorthand flags.
//
// Command line flag syntax:
//
// 	--flag    // boolean flags only
// 	--flag=x
//
// Unlike the flag package, a single dash before an option means something
// different than a double dash. Single dashes signify a series of shorthand
// letters for flags. All but the last shorthand letter must be boolean flags.
//
// 	// boolean flags
// 	-f
// 	-abc
// 	// non-boolean flags
// 	-n 1234
// 	-Ifile
// 	// mixed
// 	-abcs "hello"
// 	-abcn1234
//
// Flag parsing stops after the terminator "--". Unlike the flag package,
// flags can be interspersed with arguments anywhere on the command line
// before this terminator.
//
// Integer flags accept 1234, 0664, 0x1234 and may be negative.
// Boolean flags (in their long form) accept 1, 0, t, f, true, false,
// TRUE, FALSE, True, False.
// Duration flags accept any input valid for time.ParseDuration.
//
// The default set of command-line flags is controlled by
// top-level functions.  The FlagSet type allows one to define
// independent sets of flags, such as to implement subcommands
// in a command-line interface. The methods of FlagSet are
// analogous to the top-level functions for the command-line
// flag set.
//
package pflag

// ErrorHandling defines how to handle flag parsing errors.
#ErrorHandling: int // #enumErrorHandling

#enumErrorHandling:
	#ContinueOnError |
	#ExitOnError |
	#PanicOnError

#values_ErrorHandling: {
	ContinueOnError: #ContinueOnError
	ExitOnError:     #ExitOnError
	PanicOnError:    #PanicOnError
}

// ContinueOnError will return an err from Parse() if an error is found
#ContinueOnError: #ErrorHandling & 0

// ExitOnError will call os.Exit(2) if an error is found when parsing
#ExitOnError: #ErrorHandling & 1

// PanicOnError will panic() if an error is found when parsing flags
#PanicOnError: #ErrorHandling & 2

// ParseErrorsWhitelist defines the parsing errors that can be ignored
#ParseErrorsWhitelist: {
	// UnknownFlags will ignore unknown flags errors and continue parsing rest of the flags
	UnknownFlags: bool
}

// NormalizedName is a flag name that has been normalized according to rules
// for the FlagSet (e.g. making '-' and '_' equivalent).
#NormalizedName: string

// A FlagSet represents a set of defined flags.
#FlagSet: {
	// SortFlags is used to indicate, if user wants to have sorted flags in
	// help/usage messages.
	SortFlags: bool

	// ParseErrorsWhitelist is used to configure a whitelist of errors
	ParseErrorsWhitelist: #ParseErrorsWhitelist @go(,github.com/spf13/pgoflag.ParseErrorsWhitelist)
}

// A Flag represents the state of a flag.
#Flag: {
	Name:                string
	Shorthand:           string
	Usage:               string
	Value:               #Value @go(,github.com/spf13/pgoflag.Value)
	DefValue:            string
	Changed:             bool
	NoOptDefVal:         string
	Deprecated:          string
	Hidden:              bool
	ShorthandDeprecated: string
	Annotations: {[string]: [...string]} @go(,map[string][]string)
}

// Value is the interface to the dynamic value stored in a flag.
// (The default value is represented as a string.)
#Value: _

// SliceValue is a secondary interface to all flags which hold a list
// of values.  This allows full control over the value of list flags,
// and avoids complicated marshalling and unmarshalling to csv.
#SliceValue: _
