// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/go-logr/logr

// Package logr defines a general-purpose logging API and abstract interfaces
// to back that API.  Packages in the Go ecosystem can depend on this package,
// while callers can implement logging with whatever backend is appropriate.
//
// # Usage
//
// Logging is done using a Logger instance.  Logger is a concrete type with
// methods, which defers the actual logging to a LogSink interface.  The main
// methods of Logger are Info() and Error().  Arguments to Info() and Error()
// are key/value pairs rather than printf-style formatted strings, emphasizing
// "structured logging".
//
// With Go's standard log package, we might write:
//
//	log.Printf("setting target value %s", targetValue)
//
// With logr's structured logging, we'd write:
//
//	logger.Info("setting target", "value", targetValue)
//
// Errors are much the same.  Instead of:
//
//	log.Printf("failed to open the pod bay door for user %s: %v", user, err)
//
// We'd write:
//
//	logger.Error(err, "failed to open the pod bay door", "user", user)
//
// Info() and Error() are very similar, but they are separate methods so that
// LogSink implementations can choose to do things like attach additional
// information (such as stack traces) on calls to Error(). Error() messages are
// always logged, regardless of the current verbosity.  If there is no error
// instance available, passing nil is valid.
//
// # Verbosity
//
// Often we want to log information only when the application in "verbose
// mode".  To write log lines that are more verbose, Logger has a V() method.
// The higher the V-level of a log line, the less critical it is considered.
// Log-lines with V-levels that are not enabled (as per the LogSink) will not
// be written.  Level V(0) is the default, and logger.V(0).Info() has the same
// meaning as logger.Info().  Negative V-levels have the same meaning as V(0).
// Error messages do not have a verbosity level and are always logged.
//
// Where we might have written:
//
//	if flVerbose >= 2 {
//	    log.Printf("an unusual thing happened")
//	}
//
// We can write:
//
//	logger.V(2).Info("an unusual thing happened")
//
// # Logger Names
//
// Logger instances can have name strings so that all messages logged through
// that instance have additional context.  For example, you might want to add
// a subsystem name:
//
//	logger.WithName("compactor").Info("started", "time", time.Now())
//
// The WithName() method returns a new Logger, which can be passed to
// constructors or other functions for further use.  Repeated use of WithName()
// will accumulate name "segments".  These name segments will be joined in some
// way by the LogSink implementation.  It is strongly recommended that name
// segments contain simple identifiers (letters, digits, and hyphen), and do
// not contain characters that could muddle the log output or confuse the
// joining operation (e.g. whitespace, commas, periods, slashes, brackets,
// quotes, etc).
//
// # Saved Values
//
// Logger instances can store any number of key/value pairs, which will be
// logged alongside all messages logged through that instance.  For example,
// you might want to create a Logger instance per managed object:
//
// With the standard log package, we might write:
//
//	log.Printf("decided to set field foo to value %q for object %s/%s",
//	    targetValue, object.Namespace, object.Name)
//
// With logr we'd write:
//
//	// Elsewhere: set up the logger to log the object name.
//	obj.logger = mainLogger.WithValues(
//	    "name", obj.name, "namespace", obj.namespace)
//
//	// later on...
//	obj.logger.Info("setting foo", "value", targetValue)
//
// # Best Practices
//
// Logger has very few hard rules, with the goal that LogSink implementations
// might have a lot of freedom to differentiate.  There are, however, some
// things to consider.
//
// The log message consists of a constant message attached to the log line.
// This should generally be a simple description of what's occurring, and should
// never be a format string.  Variable information can then be attached using
// named values.
//
// Keys are arbitrary strings, but should generally be constant values.  Values
// may be any Go value, but how the value is formatted is determined by the
// LogSink implementation.
//
// Logger instances are meant to be passed around by value. Code that receives
// such a value can call its methods without having to check whether the
// instance is ready for use.
//
// The zero logger (= Logger{}) is identical to Discard() and discards all log
// entries. Code that receives a Logger by value can simply call it, the methods
// will never crash. For cases where passing a logger is optional, a pointer to Logger
// should be used.
//
// # Key Naming Conventions
//
// Keys are not strictly required to conform to any specification or regex, but
// it is recommended that they:
//   - be human-readable and meaningful (not auto-generated or simple ordinals)
//   - be constant (not dependent on input data)
//   - contain only printable characters
//   - not contain whitespace or punctuation
//   - use lower case for simple keys and lowerCamelCase for more complex ones
//
// These guidelines help ensure that log data is processed properly regardless
// of the log implementation.  For example, log implementations will try to
// output JSON data or will store data for later database (e.g. SQL) queries.
//
// While users are generally free to use key names of their choice, it's
// generally best to avoid using the following keys, as they're frequently used
// by implementations:
//   - "caller": the calling information (file/line) of a particular log line
//   - "error": the underlying error value in the `Error` method
//   - "level": the log level
//   - "logger": the name of the associated logger
//   - "msg": the log message
//   - "stacktrace": the stack trace associated with a particular log line or
//     error (often from the `Error` message)
//   - "ts": the timestamp for a log line
//
// Implementations are encouraged to make use of these keys to represent the
// above concepts, when necessary (for example, in a pure-JSON output form, it
// would be necessary to represent at least message and timestamp as ordinary
// named values).
//
// # Break Glass
//
// Implementations may choose to give callers access to the underlying
// logging implementation.  The recommended pattern for this is:
//
//	// Underlier exposes access to the underlying logging implementation.
//	// Since callers only have a logr.Logger, they have to know which
//	// implementation is in use, so this interface is less of an abstraction
//	// and more of way to test type conversion.
//	type Underlier interface {
//	    GetUnderlying() <underlying-type>
//	}
//
// Logger grants access to the sink to enable type assertions like this:
//
//	func DoSomethingWithImpl(log logr.Logger) {
//	    if underlier, ok := log.GetSink().(impl.Underlier); ok {
//	       implLogger := underlier.GetUnderlying()
//	       ...
//	    }
//	}
//
// Custom `With*` functions can be implemented by copying the complete
// Logger struct and replacing the sink in the copy:
//
//	// WithFooBar changes the foobar parameter in the log sink and returns a
//	// new logger with that modified sink.  It does nothing for loggers where
//	// the sink doesn't support that parameter.
//	func WithFoobar(log logr.Logger, foobar int) logr.Logger {
//	   if foobarLogSink, ok := log.GetSink().(FoobarSink); ok {
//	      log = log.WithSink(foobarLogSink.WithFooBar(foobar))
//	   }
//	   return log
//	}
//
// Don't use New to construct a new Logger with a LogSink retrieved from an
// existing Logger. Source code attribution might not work correctly and
// unexported fields in Logger get lost.
//
// Beware that the same LogSink instance may be shared by different logger
// instances. Calling functions that modify the LogSink will affect all of
// those.
package logr

// RuntimeInfo holds information that the logr "core" library knows which
// LogSinks might want to know.
#RuntimeInfo: {
	// CallDepth is the number of call frames the logr library adds between the
	// end-user and the LogSink.  LogSink implementations which choose to print
	// the original logging site (e.g. file & line) should climb this many
	// additional frames to find it.
	CallDepth: int
}

// LogSink represents a logging implementation.  End-users will generally not
// interact with this type.
#LogSink: _

// CallDepthLogSink represents a LogSink that knows how to climb the call stack
// to identify the original call site and can offset the depth by a specified
// number of frames.  This is useful for users who have helper functions
// between the "real" call site and the actual calls to Logger methods.
// Implementations that log information about the call site (such as file,
// function, or line) would otherwise log information about the intermediate
// helper functions.
//
// This is an optional interface and implementations are not required to
// support it.
#CallDepthLogSink: _

// CallStackHelperLogSink represents a LogSink that knows how to climb
// the call stack to identify the original call site and can skip
// intermediate helper functions if they mark themselves as
// helper. Go's testing package uses that approach.
//
// This is useful for users who have helper functions between the
// "real" call site and the actual calls to Logger methods.
// Implementations that log information about the call site (such as
// file, function, or line) would otherwise log information about the
// intermediate helper functions.
//
// This is an optional interface and implementations are not required
// to support it. Implementations that choose to support this must not
// simply implement it as WithCallDepth(1), because
// Logger.WithCallStackHelper will call both methods if they are
// present. This should only be implemented for LogSinks that actually
// need it, as with testing.T.
#CallStackHelperLogSink: _

// Marshaler is an optional interface that logged values may choose to
// implement. Loggers with structured output, such as JSON, should
// log the object return by the MarshalLog method instead of the
// original value.
#Marshaler: _
