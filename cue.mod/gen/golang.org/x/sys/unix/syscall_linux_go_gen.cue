// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go golang.org/x/sys/unix

package unix

#ImplementsGetwd: true

#WaitStatus: uint32

_#mask:    0x7F
_#core:    0x80
_#exited:  0x00
_#stopped: 0x7F
_#shift:   8

// SockaddrLinklayer implements the Sockaddr interface for AF_PACKET type sockets.
#SockaddrLinklayer: {
	Protocol: uint16
	Ifindex:  int
	Hatype:   uint16
	Pkttype:  uint8
	Halen:    uint8
	Addr:     bytes @go(,[8]byte)
}

// SockaddrNetlink implements the Sockaddr interface for AF_NETLINK type sockets.
#SockaddrNetlink: {
	Family: uint16
	Pad:    uint16
	Pid:    uint32
	Groups: uint32
}

// SockaddrHCI implements the Sockaddr interface for AF_BLUETOOTH type sockets
// using the HCI protocol.
#SockaddrHCI: {
	Dev:     uint16
	Channel: uint16
}

// SockaddrL2 implements the Sockaddr interface for AF_BLUETOOTH type sockets
// using the L2CAP protocol.
#SockaddrL2: {
	PSM: uint16
	CID: uint16
	Addr: 6 * [uint8] @go(,[6]uint8)
	AddrType: uint8
}

// SockaddrRFCOMM implements the Sockaddr interface for AF_BLUETOOTH type sockets
// using the RFCOMM protocol.
//
// Server example:
//
//	fd, _ := Socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM)
//	_ = unix.Bind(fd, &unix.SockaddrRFCOMM{
//		Channel: 1,
//		Addr:    [6]uint8{0, 0, 0, 0, 0, 0}, // BDADDR_ANY or 00:00:00:00:00:00
//	})
//	_ = Listen(fd, 1)
//	nfd, sa, _ := Accept(fd)
//	fmt.Printf("conn addr=%v fd=%d", sa.(*unix.SockaddrRFCOMM).Addr, nfd)
//	Read(nfd, buf)
//
// Client example:
//
//	fd, _ := Socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM)
//	_ = Connect(fd, &SockaddrRFCOMM{
//		Channel: 1,
//		Addr:    [6]byte{0x11, 0x22, 0x33, 0xaa, 0xbb, 0xcc}, // CC:BB:AA:33:22:11
//	})
//	Write(fd, []byte(`hello`))
#SockaddrRFCOMM: {
	// Addr represents a bluetooth address, byte ordering is little-endian.
	Addr: 6 * [uint8] @go(,[6]uint8)

	// Channel is a designated bluetooth channel, only 1-30 are available for use.
	// Since Linux 2.6.7 and further zero value is the first available channel.
	Channel: uint8
}

// SockaddrCAN implements the Sockaddr interface for AF_CAN type sockets.
// The RxID and TxID fields are used for transport protocol addressing in
// (CAN_TP16, CAN_TP20, CAN_MCNET, and CAN_ISOTP), they can be left with
// zero values for CAN_RAW and CAN_BCM sockets as they have no meaning.
//
// The SockaddrCAN struct must be bound to the socket file descriptor
// using Bind before the CAN socket can be used.
//
//	// Read one raw CAN frame
//	fd, _ := Socket(AF_CAN, SOCK_RAW, CAN_RAW)
//	addr := &SockaddrCAN{Ifindex: index}
//	Bind(fd, addr)
//	frame := make([]byte, 16)
//	Read(fd, frame)
//
// The full SocketCAN documentation can be found in the linux kernel
// archives at: https://www.kernel.org/doc/Documentation/networking/can.txt
#SockaddrCAN: {
	Ifindex: int
	RxID:    uint32
	TxID:    uint32
}

// SockaddrCANJ1939 implements the Sockaddr interface for AF_CAN using J1939
// protocol (https://en.wikipedia.org/wiki/SAE_J1939). For more information
// on the purposes of the fields, check the official linux kernel documentation
// available here: https://www.kernel.org/doc/Documentation/networking/j1939.rst
#SockaddrCANJ1939: {
	Ifindex: int
	Name:    uint64
	PGN:     uint32
	Addr:    uint8
}

// SockaddrALG implements the Sockaddr interface for AF_ALG type sockets.
// SockaddrALG enables userspace access to the Linux kernel's cryptography
// subsystem. The Type and Name fields specify which type of hash or cipher
// should be used with a given socket.
//
// To create a file descriptor that provides access to a hash or cipher, both
// Bind and Accept must be used. Once the setup process is complete, input
// data can be written to the socket, processed by the kernel, and then read
// back as hash output or ciphertext.
//
// Here is an example of using an AF_ALG socket with SHA1 hashing.
// The initial socket setup process is as follows:
//
//	// Open a socket to perform SHA1 hashing.
//	fd, _ := unix.Socket(unix.AF_ALG, unix.SOCK_SEQPACKET, 0)
//	addr := &unix.SockaddrALG{Type: "hash", Name: "sha1"}
//	unix.Bind(fd, addr)
//	// Note: unix.Accept does not work at this time; must invoke accept()
//	// manually using unix.Syscall.
//	hashfd, _, _ := unix.Syscall(unix.SYS_ACCEPT, uintptr(fd), 0, 0)
//
// Once a file descriptor has been returned from Accept, it may be used to
// perform SHA1 hashing. The descriptor is not safe for concurrent use, but
// may be re-used repeatedly with subsequent Write and Read operations.
//
// When hashing a small byte slice or string, a single Write and Read may
// be used:
//
//	// Assume hashfd is already configured using the setup process.
//	hash := os.NewFile(hashfd, "sha1")
//	// Hash an input string and read the results. Each Write discards
//	// previous hash state. Read always reads the current state.
//	b := make([]byte, 20)
//	for i := 0; i < 2; i++ {
//	    io.WriteString(hash, "Hello, world.")
//	    hash.Read(b)
//	    fmt.Println(hex.EncodeToString(b))
//	}
//	// Output:
//	// 2ae01472317d1935a84797ec1983ae243fc6aa28
//	// 2ae01472317d1935a84797ec1983ae243fc6aa28
//
// For hashing larger byte slices, or byte streams such as those read from
// a file or socket, use Sendto with MSG_MORE to instruct the kernel to update
// the hash digest instead of creating a new one for a given chunk and finalizing it.
//
//	// Assume hashfd and addr are already configured using the setup process.
//	hash := os.NewFile(hashfd, "sha1")
//	// Hash the contents of a file.
//	f, _ := os.Open("/tmp/linux-4.10-rc7.tar.xz")
//	b := make([]byte, 4096)
//	for {
//	    n, err := f.Read(b)
//	    if err == io.EOF {
//	        break
//	    }
//	    unix.Sendto(hashfd, b[:n], unix.MSG_MORE, addr)
//	}
//	hash.Read(b)
//	fmt.Println(hex.EncodeToString(b))
//	// Output: 85cdcad0c06eef66f805ecce353bec9accbeecc5
//
// For more information, see: http://www.chronox.de/crypto-API/crypto/userspace-if.html.
#SockaddrALG: {
	Type:    string
	Name:    string
	Feature: uint32
	Mask:    uint32
}

// SockaddrVM implements the Sockaddr interface for AF_VSOCK type sockets.
// SockaddrVM provides access to Linux VM sockets: a mechanism that enables
// bidirectional communication between a hypervisor and its guest virtual
// machines.
#SockaddrVM: {
	// CID and Port specify a context ID and port address for a VM socket.
	// Guests have a unique CID, and hosts may have a well-known CID of:
	//  - VMADDR_CID_HYPERVISOR: refers to the hypervisor process.
	//  - VMADDR_CID_LOCAL: refers to local communication (loopback).
	//  - VMADDR_CID_HOST: refers to other processes on the host.
	CID:   uint32
	Port:  uint32
	Flags: uint8
}

#SockaddrXDP: {
	Flags:        uint16
	Ifindex:      uint32
	QueueID:      uint32
	SharedUmemFD: uint32
}

_#px_proto_oe: 0

#SockaddrPPPoE: {
	SID:    uint16
	Remote: bytes @go(,[]byte)
	Dev:    string
}

// SockaddrTIPC implements the Sockaddr interface for AF_TIPC type sockets.
// For more information on TIPC, see: http://tipc.sourceforge.net/.
#SockaddrTIPC: {
	// Scope is the publication scopes when binding service/service range.
	// Should be set to TIPC_CLUSTER_SCOPE or TIPC_NODE_SCOPE.
	Scope: int

	// Addr is the type of address used to manipulate a socket. Addr must be
	// one of:
	//  - *TIPCSocketAddr: "id" variant in the C addr union
	//  - *TIPCServiceRange: "nameseq" variant in the C addr union
	//  - *TIPCServiceName: "name" variant in the C addr union
	//
	// If nil, EINVAL will be returned when the structure is used.
	Addr: #TIPCAddr
}

// TIPCAddr is implemented by types that can be used as an address for
// SockaddrTIPC. It is only implemented by *TIPCSocketAddr, *TIPCServiceRange,
// and *TIPCServiceName.
#TIPCAddr: _

// SockaddrL2TPIP implements the Sockaddr interface for IPPROTO_L2TP/AF_INET sockets.
#SockaddrL2TPIP: {
	Addr:   bytes @go(,[4]byte)
	ConnId: uint32
}

// SockaddrL2TPIP6 implements the Sockaddr interface for IPPROTO_L2TP/AF_INET6 sockets.
#SockaddrL2TPIP6: {
	Addr:   bytes @go(,[16]byte)
	ZoneId: uint32
	ConnId: uint32
}

// SockaddrIUCV implements the Sockaddr interface for AF_IUCV sockets.
#SockaddrIUCV: {
	UserID: string
	Name:   string
}

#SockaddrNFC: {
	DeviceIdx:   uint32
	TargetIdx:   uint32
	NFCProtocol: uint32
}

#SockaddrNFCLLCP: {
	DeviceIdx:      uint32
	TargetIdx:      uint32
	NFCProtocol:    uint32
	DestinationSAP: uint8
	SourceSAP:      uint8
	ServiceName:    string
}

_#elfNT_PRSTATUS: 1

_#minIovec: 8

_#mremapFixed:     2
_#mremapDontunmap: 4
_#mremapMaymove:   1

// fileHandle is the argument to nameToHandleAt and openByHandleAt. We
// originally tried to generate it via unix/linux/types.go with "type
// fileHandle C.struct_file_handle" but that generated empty structs
// for mips64 and mips64le. Instead, hard code it for now (it's the
// same everywhere else) until the mips64 generator issue is fixed.
_#fileHandle: {
	Bytes: uint32
	Type:  int32
}

// RemoteIovec is Iovec with the pointer replaced with an integer.
// It is used for ProcessVMReadv and ProcessVMWritev, where the pointer
// refers to a location in a different process' address space, which
// would confuse the Go garbage collector.
#RemoteIovec: {
	Base: uint64 @go(,uintptr)
	Len:  int
}

// A value which may be passed to the which parameter for Getitimer and
// Setitimer.
#ItimerWhich: int // #enumItimerWhich

#enumItimerWhich:
	#ItimerReal |
	#ItimerVirtual |
	#ItimerProf

#values_ItimerWhich: {
	ItimerReal:    #ItimerReal
	ItimerVirtual: #ItimerVirtual
	ItimerProf:    #ItimerProf
}

#ItimerReal:    #ItimerWhich & 0
#ItimerVirtual: #ItimerWhich & 1
#ItimerProf:    #ItimerWhich & 2
