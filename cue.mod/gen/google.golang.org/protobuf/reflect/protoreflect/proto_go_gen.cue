// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go google.golang.org/protobuf/reflect/protoreflect

// Package protoreflect provides interfaces to dynamically manipulate messages.
//
// This package includes type descriptors which describe the structure of types
// defined in proto source files and value interfaces which provide the
// ability to examine and manipulate the contents of messages.
//
// # Protocol Buffer Descriptors
//
// Protobuf descriptors (e.g., [EnumDescriptor] or [MessageDescriptor])
// are immutable objects that represent protobuf type information.
// They are wrappers around the messages declared in descriptor.proto.
// Protobuf descriptors alone lack any information regarding Go types.
//
// Enums and messages generated by this module implement [Enum] and [ProtoMessage],
// where the Descriptor and ProtoReflect.Descriptor accessors respectively
// return the protobuf descriptor for the values.
//
// The protobuf descriptor interfaces are not meant to be implemented by
// user code since they might need to be extended in the future to support
// additions to the protobuf language.
// The [google.golang.org/protobuf/reflect/protodesc] package converts between
// google.protobuf.DescriptorProto messages and protobuf descriptors.
//
// # Go Type Descriptors
//
// A type descriptor (e.g., [EnumType] or [MessageType]) is a constructor for
// a concrete Go type that represents the associated protobuf descriptor.
// There is commonly a one-to-one relationship between protobuf descriptors and
// Go type descriptors, but it can potentially be a one-to-many relationship.
//
// Enums and messages generated by this module implement [Enum] and [ProtoMessage],
// where the Type and ProtoReflect.Type accessors respectively
// return the protobuf descriptor for the values.
//
// The [google.golang.org/protobuf/types/dynamicpb] package can be used to
// create Go type descriptors from protobuf descriptors.
//
// # Value Interfaces
//
// The [Enum] and [Message] interfaces provide a reflective view over an
// enum or message instance. For enums, it provides the ability to retrieve
// the enum value number for any concrete enum type. For messages, it provides
// the ability to access or manipulate fields of the message.
//
// To convert a [google.golang.org/protobuf/proto.Message] to a [protoreflect.Message], use the
// former's ProtoReflect method. Since the ProtoReflect method is new to the
// v2 message interface, it may not be present on older message implementations.
// The [github.com/golang/protobuf/proto.MessageReflect] function can be used
// to obtain a reflective view on older messages.
//
// # Relationships
//
// The following diagrams demonstrate the relationships between
// various types declared in this package.
//
//	                       ┌───────────────────────────────────┐
//	                       V                                   │
//	   ┌────────────── New(n) ─────────────┐                   │
//	   │                                   │                   │
//	   │      ┌──── Descriptor() ──┐       │  ┌── Number() ──┐ │
//	   │      │                    V       V  │              V │
//	╔════════════╗  ╔════════════════╗  ╔════════╗  ╔════════════╗
//	║  EnumType  ║  ║ EnumDescriptor ║  ║  Enum  ║  ║ EnumNumber ║
//	╚════════════╝  ╚════════════════╝  ╚════════╝  ╚════════════╝
//	      Λ           Λ                   │ │
//	      │           └─── Descriptor() ──┘ │
//	      │                                 │
//	      └────────────────── Type() ───────┘
//
// • An [EnumType] describes a concrete Go enum type.
// It has an EnumDescriptor and can construct an Enum instance.
//
// • An [EnumDescriptor] describes an abstract protobuf enum type.
//
// • An [Enum] is a concrete enum instance. Generated enums implement Enum.
//
//	  ┌──────────────── New() ─────────────────┐
//	  │                                        │
//	  │         ┌─── Descriptor() ─────┐       │   ┌── Interface() ───┐
//	  │         │                      V       V   │                  V
//	╔═════════════╗  ╔═══════════════════╗  ╔═════════╗  ╔══════════════╗
//	║ MessageType ║  ║ MessageDescriptor ║  ║ Message ║  ║ ProtoMessage ║
//	╚═════════════╝  ╚═══════════════════╝  ╚═════════╝  ╚══════════════╝
//	       Λ           Λ                      │ │  Λ                  │
//	       │           └──── Descriptor() ────┘ │  └─ ProtoReflect() ─┘
//	       │                                    │
//	       └─────────────────── Type() ─────────┘
//
// • A [MessageType] describes a concrete Go message type.
// It has a [MessageDescriptor] and can construct a [Message] instance.
// Just as how Go's [reflect.Type] is a reflective description of a Go type,
// a [MessageType] is a reflective description of a Go type for a protobuf message.
//
// • A [MessageDescriptor] describes an abstract protobuf message type.
// It has no understanding of Go types. In order to construct a [MessageType]
// from just a [MessageDescriptor], you can consider looking up the message type
// in the global registry using the FindMessageByName method on
// [google.golang.org/protobuf/reflect/protoregistry.GlobalTypes]
// or constructing a dynamic [MessageType] using
// [google.golang.org/protobuf/types/dynamicpb.NewMessageType].
//
// • A [Message] is a reflective view over a concrete message instance.
// Generated messages implement [ProtoMessage], which can convert to a [Message].
// Just as how Go's [reflect.Value] is a reflective view over a Go value,
// a [Message] is a reflective view over a concrete protobuf message instance.
// Using Go reflection as an analogy, the [ProtoMessage.ProtoReflect] method is similar to
// calling [reflect.ValueOf], and the [Message.Interface] method is similar to
// calling [reflect.Value.Interface].
//
//	      ┌── TypeDescriptor() ──┐    ┌───── Descriptor() ─────┐
//	      │                      V    │                        V
//	╔═══════════════╗  ╔═════════════════════════╗  ╔═════════════════════╗
//	║ ExtensionType ║  ║ ExtensionTypeDescriptor ║  ║ ExtensionDescriptor ║
//	╚═══════════════╝  ╚═════════════════════════╝  ╚═════════════════════╝
//	      Λ                      │   │ Λ                      │ Λ
//	      └─────── Type() ───────┘   │ └─── may implement ────┘ │
//	                                 │                          │
//	                                 └────── implements ────────┘
//
// • An [ExtensionType] describes a concrete Go implementation of an extension.
// It has an [ExtensionTypeDescriptor] and can convert to/from
// an abstract [Value] and a Go value.
//
// • An [ExtensionTypeDescriptor] is an [ExtensionDescriptor]
// which also has an [ExtensionType].
//
// • An [ExtensionDescriptor] describes an abstract protobuf extension field and
// may not always be an [ExtensionTypeDescriptor].
package protoreflect

import (
	"google.golang.org/protobuf/internal/pragma"
	"google.golang.org/protobuf/encoding/protowire"
)

_#doNotImplement: pragma.#DoNotImplement

// ProtoMessage is the top-level interface that all proto messages implement.
// This is declared in the protoreflect package to avoid a cyclic dependency;
// use the [google.golang.org/protobuf/proto.Message] type instead, which aliases this type.
#ProtoMessage: _

// Syntax is the language version of the proto file.
#Syntax: _#syntax // #enumSyntax

#enumSyntax:
	#Proto2 |
	#Proto3 |
	#Editions

#values_Syntax: {
	Proto2:   #Proto2
	Proto3:   #Proto3
	Editions: #Editions
}

_#syntax: int8

#Proto2:   #Syntax & 2
#Proto3:   #Syntax & 3
#Editions: #Syntax & 4

// Cardinality determines whether a field is optional, required, or repeated.
#Cardinality: _#cardinality // #enumCardinality

#enumCardinality:
	#Optional |
	#Required |
	#Repeated

#values_Cardinality: {
	Optional: #Optional
	Required: #Required
	Repeated: #Repeated
}

_#cardinality: int8

#Optional: #Cardinality & 1
#Required: #Cardinality & 2
#Repeated: #Cardinality & 3

// Kind indicates the basic proto kind of a field.
#Kind: _#kind // #enumKind

#enumKind:
	#BoolKind |
	#EnumKind |
	#Int32Kind |
	#Sint32Kind |
	#Uint32Kind |
	#Int64Kind |
	#Sint64Kind |
	#Uint64Kind |
	#Sfixed32Kind |
	#Fixed32Kind |
	#FloatKind |
	#Sfixed64Kind |
	#Fixed64Kind |
	#DoubleKind |
	#StringKind |
	#BytesKind |
	#MessageKind |
	#GroupKind

#values_Kind: {
	BoolKind:     #BoolKind
	EnumKind:     #EnumKind
	Int32Kind:    #Int32Kind
	Sint32Kind:   #Sint32Kind
	Uint32Kind:   #Uint32Kind
	Int64Kind:    #Int64Kind
	Sint64Kind:   #Sint64Kind
	Uint64Kind:   #Uint64Kind
	Sfixed32Kind: #Sfixed32Kind
	Fixed32Kind:  #Fixed32Kind
	FloatKind:    #FloatKind
	Sfixed64Kind: #Sfixed64Kind
	Fixed64Kind:  #Fixed64Kind
	DoubleKind:   #DoubleKind
	StringKind:   #StringKind
	BytesKind:    #BytesKind
	MessageKind:  #MessageKind
	GroupKind:    #GroupKind
}

_#kind: int8

#BoolKind:     #Kind & 8
#EnumKind:     #Kind & 14
#Int32Kind:    #Kind & 5
#Sint32Kind:   #Kind & 17
#Uint32Kind:   #Kind & 13
#Int64Kind:    #Kind & 3
#Sint64Kind:   #Kind & 18
#Uint64Kind:   #Kind & 4
#Sfixed32Kind: #Kind & 15
#Fixed32Kind:  #Kind & 7
#FloatKind:    #Kind & 2
#Sfixed64Kind: #Kind & 16
#Fixed64Kind:  #Kind & 6
#DoubleKind:   #Kind & 1
#StringKind:   #Kind & 9
#BytesKind:    #Kind & 12
#MessageKind:  #Kind & 11
#GroupKind:    #Kind & 10

// FieldNumber is the field number in a message.
#FieldNumber: protowire.#Number

// FieldNumbers represent a list of field numbers.
#FieldNumbers: _

// FieldRanges represent a list of field number ranges.
#FieldRanges: _

// EnumNumber is the numeric value for an enum.
#EnumNumber: int32

// EnumRanges represent a list of enum number ranges.
#EnumRanges: _

// Name is the short name for a proto declaration. This is not the name
// as used in Go source code, which might not be identical to the proto name.
#Name: string

// Names represent a list of names.
#Names: _

// FullName is a qualified name that uniquely identifies a proto declaration.
// A qualified name is the concatenation of the proto package along with the
// fully-declared name (i.e., name of parent preceding the name of the child),
// with a '.' delimiter placed between each [Name].
//
// This should not have any leading or trailing dots.
#FullName: string
